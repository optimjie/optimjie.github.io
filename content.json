{"pages":[{"title":"about","text":"ç®—æ³•åˆå­¦è€…","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"03-æ ‘2 List Leaves","text":"è¿™é“é¢˜èŠ±è´¹äº†æˆ‘å››ä¸ªå°æ—¶ï¼Œä½†æ˜¯å¾ˆå¼€å¿ƒä¸€æ¬¡ACï¼Œè®°å½•ä¸€ä¸‹ã€‚èŠ±è¿™ä¹ˆé•¿æ—¶é—´çš„ä¸»è¦åŸå› æ˜¯ï¼Œåœ¨ç¬¬ä¸€æ¬¡æƒ³çš„æ—¶å€™åœ¨æ„é€ æ ‘çš„ç»“ç‚¹çš„æ—¶å€™ï¼Œæ²¡æœ‰åŠ å…¥ç»“ç‚¹çš„ä¸‹æ ‡ï¼Œå¯¼è‡´åé¢è¶Šåšè¶Šéº»çƒ¦ï¼Œå¥½åœ¨åŠæ—¶ä¿®æ”¹ï¼ŒåªèŠ±äº†4ä¸ªå°æ—¶ğŸ˜ğŸ˜ã€‚ é¢˜ç›®æè¿°Given a tree, you are supposed to list all the leaves in the order of top down, and left to right. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤10) which is the total number of nodes in the tree â€“ and hence the nodes are numbered from 0 to Nâˆ’1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a â€œ-â€œ will be put at the position. Any pair of children are separated by a space. Output Specification:For each test case, print in one line all the leavesâ€™ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input:12345678981 -- -0 -2 7- -- -5 -4 6 Sample Output:14 1 5 ACä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define Null -1#define MAXSIZE 10typedef struct BiTNode{ int lchild; int rchild; int index;}BiTNode;typedef BiTNode QElemType;typedef struct SqQueue{ QElemType Data[MAXSIZE]; int front; int rear;}SqQueue;int CreateBiTree(vector&lt;BiTNode&gt; &amp;v, int n, int &amp;leaves);void InitQueue(SqQueue &amp;Q);void AddQueue(SqQueue &amp;Q, BiTNode e);void DeleteQueue(SqQueue &amp;Q);bool QueueEmpty(SqQueue Q);bool QueueFull(SqQueue Q);int main(){ int n; cin &gt;&gt; n; int root; vector&lt;BiTNode&gt; v; int leaves = 0; root = CreateBiTree(v, n, leaves); SqQueue Q; InitQueue(Q); AddQueue(Q, v[root]); int cnt = 0; while (!QueueEmpty(Q)) { if (Q.Data[Q.front].lchild == Null &amp;&amp; Q.Data[Q.front].rchild == Null) { cnt++; if (cnt == leaves) cout &lt;&lt; Q.Data[Q.front].index; else cout &lt;&lt; Q.Data[Q.front].index &lt;&lt; \" \"; } int t = Q.Data[Q.front].index; DeleteQueue(Q); if (v[t].lchild != Null) AddQueue(Q, v[v[t].lchild]); if (v[t].rchild != Null) AddQueue(Q, v[v[t].rchild]); } return 0;}int CreateBiTree(vector&lt;BiTNode&gt; &amp;v, int n, int &amp;leaves){ char l, r; BiTNode tmp; vector&lt;int&gt; arr(n, 1); for (int i = 0; i &lt; n; i++) { tmp.index = i; cin &gt;&gt; l &gt;&gt; r; if (l == '-') tmp.lchild = Null; else { tmp.lchild = l - '0'; arr[tmp.lchild] = 0; } if (r == '-') tmp.rchild = Null; else { tmp.rchild = r - '0'; arr[tmp.rchild] = 0; } if (tmp.lchild == Null &amp;&amp; tmp.rchild == Null) leaves++; v.push_back(tmp); } int i = 0; for (; i &lt; n; i++) { if (arr[i] != 0) break; } return i;}void InitQueue(SqQueue &amp;Q){ Q.front = 0; Q.rear = 0;}void AddQueue(SqQueue &amp;Q, BiTNode e){ if (!QueueFull(Q)) { Q.Data[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXSIZE; }}void DeleteQueue(SqQueue &amp;Q){ if (!QueueEmpty(Q)) { Q.front = (Q.front + 1) % MAXSIZE; }}bool QueueEmpty(SqQueue Q){ if (Q.front == Q.rear) return true; return false;}bool QueueFull(SqQueue Q){ if ((Q.front + MAXSIZE - Q.rear) % MAXSIZE == 1) return true; return false;}","link":"/2019/10/24/03-æ ‘2-List-Leaves/"},{"title":"Cppä¸­æˆå‘˜å‡½æ•°ä¸å…¨å±€å‡½æ•°ä»¥åŠæ„é€ å‡½æ•°ä¸ææ„å‡½æ•°çš„è°ƒç”¨è¿‡ç¨‹","text":"","link":"/2019/09/22/Cppä¸­æˆå‘˜å‡½æ•°ä¸å…¨å±€å‡½æ•°ä»¥åŠæ„é€ å‡½æ•°ä¸ææ„å‡½æ•°çš„è°ƒç”¨è¿‡ç¨‹/"},{"title":"Cppä¸­æ•°ç»„ç±»çš„å®ç°ä»¥åŠæ“ä½œç¬¦çš„é‡è½½","text":"Cppä¸­æ•°ç»„ç±»çš„å®ç°ä»¥åŠæ“ä½œç¬¦çš„é‡è½½ã€‚ã€‚ Array.h12345678910111213141516171819202122#pragma onceclass Array{public: int mLength; int* mSpace;public: Array(int length); Array(const Array&amp; obj); int&amp; operator[](int i); Array&amp; operator=(Array &amp;obj); bool operator==(Array &amp;obj); bool operator!=(Array &amp;obj); int length(); void setData(int index, int value); int getData(int index); ~Array();}; main.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int main(){ //å®šä¹‰ä¸€ä¸ªArrayç±»å‹çš„å•Šå¯¹è±¡å¹¶è°ƒç”¨Arrayç±»çš„æœ‰å‚æ„é€ å‡½æ•° Array a1(10); //å¯¹æ•°ç»„çš„å…ƒç´ è¿›è¡Œåˆå§‹åŒ– for (int i = 0; i &lt; a1.length(); i++) { //a1.setData(i, i); //åˆæ­¥ a1[i] = i; //æå‡ []é‡è½½ } //å¯¹æ•°ç»„çš„å…ƒç´ è¿›è¡Œè¾“å‡º for (int i = 0; i &lt; a1.length(); i++) { //printf(\"array %d: %d\\n\", i, a1.getData(i)); //åˆæ­¥ cout &lt;&lt; a1[i]; } cout &lt;&lt; a1; // &lt;&lt;é‡è½½ //ç”¨a1å¯¹è±¡åˆå§‹åŒ–a2å¯¹è±¡ï¼Œè°ƒç”¨a2å¯¹è±¡çš„æ‹·è´æ„é€ å‡½æ•° //æ€»ç»“1 Array a2 = a1; for (int i = 0; i &lt; a2.length(); i++) { //printf(\"array %d: %d\\n\", i, a2.getData(i)); cout &lt;&lt; a1[i]; } Array a3(5); a3 = a1; //c++ç¼–è¯‘å™¨æä¾›çš„ç­‰å·æ“ä½œç¬¦ä¸ºæµ…æ‹·è´éœ€é‡è½½ = //æ€»ç»“2 cout &lt;&lt; \"a3:\" &lt;&lt; a3; if (a1 == a3) { cout &lt;&lt; \"ç›¸ç­‰\" &lt;&lt; endl; } else { cout &lt;&lt; \"ä¸ç›¸ç­‰\" &lt;&lt; endl; } if (a1 != a3) { cout &lt;&lt; \"ä¸ç›¸ç­‰\" &lt;&lt; endl; } else { cout &lt;&lt; \"ç›¸ç­‰\" &lt;&lt; endl; } return 0;} é‡è½½&lt;&lt;å‡½æ•°123456789ostream&amp; operator&lt;&lt;(ostream &amp;out, Array &amp;obj){ for (int i = 0; i &lt; obj.length(); i++) { //out &lt;&lt; obj.mSpace[i] &lt;&lt; \" \"; out &lt;&lt; obj[i] &lt;&lt; \" \"; } return out;} æˆå‘˜å‡½æ•°å®ç°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Array::Array(int length){ mLength = length; mSpace = new int[mLength];}Array::Array(const Array&amp; obj){ mLength = obj.mLength; mSpace = new int [mLength]; for (int i = 0; i &lt; mLength; i++) { mSpace[i] = obj.mSpace[i]; }}int Array::length(){ return mLength;}void Array::setData(int index, int value){ mSpace[index] = value;}int Array::getData(int index){ return mSpace[index];}Array::~Array(){ delete[] mSpace; mSpace = NULL; mLength = 0; }int&amp; Array::operator[](int i){ return this-&gt;mSpace[i];}Array&amp; Array::operator=(Array &amp;obj){ delete[] this-&gt;mSpace; this-&gt;mLength = 0; this-&gt;mLength = obj.mLength; this-&gt;mSpace = new int[mLength]; for (int i = 0; i &lt; mLength; i++) { mSpace[i] = obj[i]; } return *this;}bool Array::operator==(Array &amp;obj){ if (this-&gt;mLength != obj.mLength) { return false; } for (int i = 0; i &lt; mLength; i++) { if (mSpace[i] != obj[i]) { return false; } } return true;}bool Array::operator!=(Array &amp;obj){ return !(*this == obj);} æ€»ç»“ï¼šæ‹·è´æ„é€ å‡½æ•°çš„å››ç§è°ƒç”¨æ–¹æ³•ï¼š1.Array a1(a2); 2.Array a1 = a2; 3.å‡½æ•°è°ƒç”¨è¿‡ç¨‹ä¸­ï¼Œä¾‹å¦‚ï¼šmainå‡½æ•°ä¸­è°ƒç”¨få‡½æ•°f(a1);ï¼Œå…¶ä¸­a1ä¸ºArrayç±»å‹çš„ä¸€ä¸ªå¯¹è±¡ï¼Œfå‡½æ•°çš„å£°æ˜ä¸ºvoid f(Array a);è¿™æ—¶å‡½æ•°çš„è°ƒç”¨è¿‡ç¨‹ä¸­ä¼šè°ƒç”¨aå¯¹è±¡çš„æ‹·è´æ„é€ å‡½æ•°ã€‚ 4.è¢«è°ƒç”¨å‡½æ•°çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªå¯¹è±¡çš„æ—¶å€™ï¼Œè¿™æ—¶c++ç¼–è¯‘å™¨ä¼šåˆ›å»ºä¸€ä¸ªåŒ¿åå¯¹è±¡ï¼Œç„¶åè°ƒç”¨åŒ¿åå¯¹è±¡çš„æ‹·è´æ„é€ å‡½æ•°ã€‚è€Œè¿™ä¸ªåŒ¿åå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸå–å†³äºä¸»è°ƒç”¨å‡½æ•°çš„æ¥æ³•ï¼Œå¦‚æœæ˜¯ç±»çš„åˆå§‹åŒ–é‚£ä¹ˆåŒ¿åå¯¹è±¡è½¬æ­£ï¼Œç›´åˆ°ç¨‹åºè¿è¡Œå®Œæˆæ—¶æ‰ä¼šè°ƒç”¨ææ„å‡½æ•°ï¼Œè‹¥æ˜¯ç±»çš„èµ‹å€¼ï¼Œåˆ™åœ¨èµ‹å€¼å®Œä»¥åç«‹é©¬è°ƒç”¨åŒ¿åå¯¹è±¡çš„ææ„å‡½æ•°ã€‚ é‡è½½&lt;&lt;C++Primerç¬¬å…­é¡µä¸­è¯´ï¼Œ&lt;&lt;è¿ç®—ç¬¦æ¥å—ä¸¤ä¸ªè¿ç®—å¯¹è±¡ï¼šå·¦ä¾§çš„è¿ç®—å¯¹è±¡å¿…é¡»æ˜¯ä¸€ä¸ªostreamå¯¹è±¡ï¼ˆä¹Ÿå°±æ˜¯è¯´coutæ˜¯ä¸€ä¸ªostreamç±»å‹çš„å¯¹è±¡ï¼‰ï¼Œå³ä¾§çš„è¿ç®—å¯¹è±¡æ˜¯è¦æ‰“å°çš„å€¼ã€‚ ä½¿ç”¨è¿‡ç¨‹ä¸­æˆ‘ä»¬çš„è¾“å‡ºè¯­å¥å¯ä»¥ä½¿ç”¨å¤šæ¬¡&lt;&lt;è¿ç®—ç¬¦ï¼Œå› æ­¤&lt;&lt;è¿ç®—ç¬¦è¿”å›å…¶å·¦ä¾§çš„è¿ç®—å¯¹è±¡ï¼ˆå³ostreamç±»å‹ï¼‰ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯ç¬¬ä¸€æ¬¡çš„è¿ç®—ç»“æœèƒ½ä½œä¸ºç¬¬äºŒæ¬¡&lt;&lt;è¿ç®—ç¬¦çš„å·¦ä¾§è¿ç®—å¯¹è±¡ã€‚æœ‰äº†è¿™ä¸ªå‰æä¹‹åæˆ‘ä»¬åœ¨å†™&lt;&lt;è¿ç®—ç¬¦é‡è½½å‡½æ•°çš„æ—¶å€™ï¼Œå‡½æ•°åº”è¿”å›æœ¬èº«ï¼ˆå³è¿”å›ä¸€ä¸ªå¼•ç”¨ï¼‰ï¼Œå› æ­¤å‡½æ•°çš„å£°æ˜åº”ä¸ºostream&amp; operator&lt;&lt;(ostream &amp;out, Array &amp;obj)ã€‚ è¿ç®—ç¬¦é‡è½½å‡½æ•°å¯ä»¥ä¸ºå…¨å±€å‡½æ•°ä¹Ÿå¯ä»¥ä¸ºæˆå‘˜å‡½æ•°ï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹äºŒè€…å¯ä»¥ç›¸äº’è½¬æ¢ï¼Œä»¥äºŒå…ƒè¿ç®—ç¬¦ä¸ºä¾‹ï¼Œå…¨å±€å‡½æ•°éœ€è¦ä¸¤ä¸ªå‚æ•°ï¼Œå·¦æ“ä½œæ•°ä¸å³æ“ä½œæ•°ï¼Œè€Œæˆå‘˜å‡½æ•°å¯é€šè¿‡thisæŒ‡é’ˆâ€œéšè—â€ä¸€ä¸ªå‚æ•°ã€‚ä½†ä¹Ÿæœ‰ä¾‹å¤–ï¼Œåœ¨é‡è½½&lt;&lt;æ—¶å¿…é¡»ä½¿ç”¨æˆå‘˜å‡½æ•°ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½è¿›å…¥åˆ°ostreamç±»ä¸­å†™æˆå‘˜å‡½æ•°ã€‚","link":"/2019/09/24/Cppä¸­æ•°ç»„ç±»çš„å®ç°ä»¥åŠæ“ä½œç¬¦çš„é‡è½½/"},{"title":"Cppç±»çš„åŸºç¡€ç»ƒä¹ ï¼šå•†åº—è´§ç‰©","text":"æŸå•†åº—ç»é”€ä¸€ç§è´§ç‰©ã€‚è´§ç‰©è´­è¿›å’Œå–å‡ºæ—¶ä»¥ç®±ä¸ºå•ä½ï¼Œå„ç®±çš„é‡é‡ä¸ä¸€æ ·ï¼Œå› æ­¤ï¼Œå•†åº—éœ€è¦è®°å½•ç›®å‰åº“å­˜çš„æ€»é‡é‡ã€‚ç°åœ¨ç”¨C++æ¨¡æ‹Ÿå•†åº—è´§ç‰©è´­è¿›å’Œå–å‡ºçš„æƒ…å†µã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;using namespace std;class Goods{private: int weight; static int total_weight;public: Goods *pNext; Goods(int weight) { this-&gt;weight = weight; total_weight += weight; } //ä½¿ç”¨deleteé‡Šæ”¾å†…å­˜æ—¶ä¼šè°ƒç”¨ææ„å‡½æ•° ~Goods() { total_weight -= weight; } int GetWeight() { return weight; } static int GetTotalWeight() { return total_weight; }};int Goods::total_weight = 0;void menu(){ cout &lt;&lt; \"============================\" &lt;&lt; endl; cout &lt;&lt; \" å•†åº—è´§ç‰©ç³»ç»Ÿ\" &lt;&lt; endl; cout &lt;&lt; \" è¾“å…¥1è´­è¿›\" &lt;&lt; endl; cout &lt;&lt; \" è¾“å…¥2å–å‡º\" &lt;&lt; endl; cout &lt;&lt; \" è¾“å…¥0é€€å‡º\" &lt;&lt; endl; cout &lt;&lt; \"============================\" &lt;&lt; endl;}//æŸå•†åº—ç»é”€ä¸€ç§è´§ç‰©ã€‚è´§ç‰©è´­è¿›å’Œå–å‡ºæ—¶ä»¥ç®±ä¸ºå•ä½ï¼Œå„ç®±çš„é‡é‡ä¸ä¸€æ ·ï¼Œå› æ­¤ï¼Œ//å•†åº—éœ€è¦è®°å½•ç›®å‰åº“å­˜çš„æ€»é‡é‡ã€‚ç°åœ¨ç”¨C++æ¨¡æ‹Ÿå•†åº—è´§ç‰©è´­è¿›å’Œå–å‡ºçš„æƒ…å†µã€‚void Purchase(Goods * &amp;Head, Goods * &amp;Tail,int weight){ Goods *pNew = new Goods(weight);//è¿™ä¸ªæ—¶å€™ä¼šè°ƒç”¨pNewè¿™ä¸ªæŒ‡é’ˆå˜é‡æŒ‡å‘çš„å¯¹è±¡çš„æ„é€ å‡½æ•°å•Š pNew-&gt;pNext = NULL; if (Head == NULL &amp;&amp; Tail == NULL) { Head = Tail = pNew; } else { Tail-&gt;pNext = pNew; Tail = pNew; }}void Sale(Goods * &amp;Head){ if (Head == NULL) { cout &lt;&lt; \"æ²¡æœ‰è´§ç‰©!\" &lt;&lt; endl; return; } Goods *Temp = Head-&gt;pNext; delete Head; Head = Temp;}int main(){ Goods *Head = NULL; Goods *Tail = NULL; int choice = -1; int weight = 0; do { menu(); cin &gt;&gt; choice; //scanf(\"%d\", &amp;choice); ? ? ? switch (choice) { case 1: { cout &lt;&lt; \"è¯·è¾“å…¥é‡é‡:\"; cin &gt;&gt; weight; Purchase(Head, Tail, weight); break; } case 2: { Sale(Head); break; } case 0:exit(0); break; default:cout &lt;&lt; \"è¾“å…¥é”™è¯¯,è¯·é‡æ–°è¾“å…¥!\" &lt;&lt; endl; break; } cout &lt;&lt; \"æ€»é‡é‡ä¸º:\" &lt;&lt; Goods::GetTotalWeight() &lt;&lt; endl &lt;&lt; endl; } while (1); return 0;}","link":"/2019/09/20/Cppç±»çš„åŸºç¡€ç»ƒä¹ ï¼šå•†åº—è´§ç‰©/"},{"title":"PTAæ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†(ä¸­æ–‡)6-5","text":"æœ¬é¢˜ä¸ºæ— å¤´ç»“ç‚¹çš„é“¾è¡¨æ“ä½œé›†","link":"/2019/09/08/PTAæ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†(ä¸­æ–‡)6-5/"},{"title":"Dungeon Master","text":"You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an escape possible? If yes, how long will it take? InputThe input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a â€˜#â€™ and empty cells are represented by a â€˜.â€™. Your starting position is indicated by â€˜Sâ€™ and the exit by the letter â€˜Eâ€™. Thereâ€™s a single blank line after each level. Input is terminated by three zeroes for L, R and C. OutputEach maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the line Trapped! Sample Input123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample Output12Escaped in 11 minute(s).Trapped! ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, pair&lt;int, int&gt;&gt; PIII;const int N = 35;char g[N][N][N];bool vis[N][N][N];int l, r, c; // level row columnint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};int main(){ while (scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;c), l != 0 &amp;&amp; r != 0 &amp;&amp; c != 0) { // è¾“å…¥åœ°å›¾ for (int i = 0; i &lt; l; i++) for (int j = 0; j &lt; r; j++) scanf(\"%s\", g[i][j]); queue&lt;PIII&gt; q; int step = 0; q.push({ 0, { 0, 0 } }); vis[0][0][0] = true; bool success = false; while (q.size()) { PIII k = q.front(); if (g[k.first][k.second.first][k.second.second] == 'E') { success = true; break; } q.pop(); for (int i = 0; i &lt; 4; i++) { int x = k.second.first + dx[i], y = k.second.first + dy[i]; if ((x == r || y == -1 || y == c) &amp;&amp; k.first &lt; l - 1) { int next_level = k.first + 1; if (x == r || g[next_level][x][y] == '.') { vis[next_level][0][y] = true; q.push({ next_level, { 0, y } }); step++; } else if (y == -1 || g[next_level][x][0] == '.') { vis[next_level][x][0] = true; q.push({ next_level, { x, 0 } }); step++; } else if (y == c || g[next_level][x][c - 1] == '.') { vis[next_level][x][0] = true; q.push({ next_level, { x, c - 1 } }); step++; } } else if (x &gt;= 0 &amp;&amp; g[k.first][k.second.first][k.second.second] == '.' &amp;&amp; !vis[k.first][k.second.first][k.second.second]) { vis[k.first][k.second.first][k.second.second] = true; q.push({ k.first, { k.second.first, k.second.second } }); step++; } } } if (success) cout &lt;&lt; step &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; } return 0;}","link":"/2019/12/09/Dungeon-Master/"},{"title":"Xçš„å› å­é“¾","text":"é¢˜ç›®é¢˜ç›®æè¿°è¾“å…¥æ­£æ•´æ•°$X$ï¼Œæ±‚$X$çš„å¤§äº$1$çš„å› å­ç»„æˆçš„æ»¡è¶³ä»»æ„å‰ä¸€é¡¹éƒ½èƒ½æ•´é™¤åä¸€é¡¹çš„ä¸¥æ ¼é€’å¢åºåˆ—çš„æœ€å¤§é•¿åº¦ï¼Œä»¥åŠæ»¡è¶³æœ€å¤§é•¿åº¦çš„åºåˆ—çš„ä¸ªæ•°ã€‚ è¾“å…¥æ ¼å¼è¾“å…¥åŒ…å«å¤šç»„æ•°æ®ï¼Œæ¯ç»„æ•°æ®å ä¸€è¡Œï¼ŒåŒ…å«ä¸€ä¸ªæ­£æ•´æ•°è¡¨ç¤º$X$ã€‚ è¾“å‡ºæ ¼å¼å¯¹äºæ¯ç»„æ•°æ®ï¼Œè¾“å‡ºåºåˆ—çš„æœ€å¤§é•¿åº¦ä»¥åŠæ»¡è¶³æœ€å¤§é•¿åº¦çš„åºåˆ—çš„ä¸ªæ•°ã€‚ æ¯ä¸ªç»“æœå ä¸€è¡Œã€‚ æ•°æ®èŒƒå›´$1 \\le X \\le 2^{20}$ è¾“å…¥æ ·ä¾‹ï¼š 23410100 è¾“å‡ºæ ·ä¾‹ï¼š 1 11 12 12 24 6 é¢˜ç›®é“¾æ¥ åˆ†æç®—æ•°åŸºæœ¬å®šç†ï¼šä»»ä½•ä¸€ä¸ªå¤§äº$1$çš„è‡ªç„¶æ•°$N$,å¦‚æœ$N$ä¸ä¸ºè´¨æ•°ï¼Œé‚£ä¹ˆ$N$å¯ä»¥å”¯ä¸€åˆ†è§£æˆæœ‰é™ä¸ªè´¨æ•°çš„ä¹˜ç§¯$N=P_1^{a_1}P_2^{a_2}P_3^{a_3}â€¦â€¦P_n^{a_n}$ï¼Œè¿™é‡Œ$P1&lt;P2&lt;P3â€¦â€¦&lt;Pn$å‡ä¸ºè´¨æ•°ï¼Œå…¶ä¸­æŒ‡æ•°$a_i$æ˜¯æ­£æ•´æ•°ã€‚ åä¸€é¡¹èƒ½æ•´é™¤å‰ä¸€é¡¹ï¼Œå³åä¸€é¡¹ä¸ºå‰ä¸€é¡¹ä¹˜ä»»æ„ä¸€ä¸ªè´¨å› å­$P_i$ã€‚æœ€å¤§é•¿åº¦ç”±åˆ†è§£è´¨å› æ•°å¯å¾—ï¼Œå³$maxLength=\\sum\\limits_{n=1}^na_n$ã€‚ æœ¬é¢˜è¿˜é—®åˆ°äº†æ»¡è¶³æœ€é•¿åºåˆ—çš„ä¸ªæ•°ï¼Œå³æ±‚æ‰€æœ‰è´¨å› å­çš„å…¨æ’åˆ—ï¼Œä½†ç”±äºå…¶ä¸­æœ‰é‡å¤çš„å…ƒç´ ï¼Œæ‰€ä»¥è½¬æ¢æˆå¤šå†²å‡»ç»„åˆæ•°é—®é¢˜ã€‚ï¼ˆå¤šé‡é›†ç»„åˆæ•°ï¼šä¸€å…±æœ‰$k$ç§ç‰©å“ï¼Œæ¯ä¸€ç§æœ‰$n_i$ä¸ªï¼Œ$1\\le i\\le k$ï¼Œæ€»å…±æœ‰$n$ä¸ªç‰©å“ï¼Œåˆ™$n$ä¸ªç‰©å“çš„å…¨æ’åˆ—ä¸º$\\frac{n!}{n_1!n_2!n_3!â€¦n_k!}$ï¼‰ ç”¨åˆ°çš„çŸ¥è¯†1.ç®—æ•°åŸºæœ¬å®šç†ä»¥åŠè´¨å› æ•°åˆ†è§£ 2.å¤šé‡é›†ç»„åˆæ•° ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = (1 &lt;&lt; 20) + 10;int x;int fact[30], sum[30];LL f(int n){ LL res = 1; for (int i = 1; i &lt;= n; i++) res *= i; return res;}int main(){ while (scanf(\"%d\", &amp;x) != EOF) { int k = 0; for (int i = 2; i &lt;= x / i; i++) { if (x % i == 0) fact[++k] = i; while (x % i == 0) { sum[k]++; x /= i; } } if (x != 1) fact[++k] = x, sum[k]++; int tot = 0; for (int i = 1; i &lt;= k; i++) tot += sum[i]; LL res = f(tot); for (int i = 1; i &lt;= k; i++) res /= f(sum[i]); cout &lt;&lt; tot &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl; memset(sum, 0, sizeof(sum)); } return 0;}","link":"/2020/02/10/Xçš„å› å­é“¾/"},{"title":"å…­åº¦ç©ºé—´","text":"â€œå…­åº¦ç©ºé—´â€ç†è®ºåˆç§°ä½œâ€œå…­åº¦åˆ†éš”ï¼ˆSix Degrees of Separationï¼‰â€ç†è®ºã€‚è¿™ä¸ªç†è®ºå¯ä»¥é€šä¿—åœ°é˜è¿°ä¸ºï¼šâ€œä½ å’Œä»»ä½•ä¸€ä¸ªé™Œç”Ÿäººä¹‹é—´æ‰€é—´éš”çš„äººä¸ä¼šè¶…è¿‡å…­ä¸ªï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€å¤šé€šè¿‡äº”ä¸ªäººä½ å°±èƒ½å¤Ÿè®¤è¯†ä»»ä½•ä¸€ä¸ªé™Œç”Ÿäººã€‚â€å¦‚å›¾æ‰€ç¤ºã€‚ â€œå…­åº¦ç©ºé—´â€ç†è®ºè™½ç„¶å¾—åˆ°å¹¿æ³›çš„è®¤åŒï¼Œå¹¶ä¸”æ­£åœ¨å¾—åˆ°è¶Šæ¥è¶Šå¤šçš„åº”ç”¨ã€‚ä½†æ˜¯æ•°åå¹´æ¥ï¼Œè¯•å›¾éªŒè¯è¿™ä¸ªç†è®ºå§‹ç»ˆæ˜¯è®¸å¤šç¤¾ä¼šå­¦å®¶åŠªåŠ›è¿½æ±‚çš„ç›®æ ‡ã€‚ç„¶è€Œç”±äºå†å²çš„åŸå› ï¼Œè¿™æ ·çš„ç ”ç©¶å…·æœ‰å¤ªå¤§çš„å±€é™æ€§å’Œå›°éš¾ã€‚éšç€å½“ä»£äººçš„è”ç»œä¸»è¦ä¾èµ–äºç”µè¯ã€çŸ­ä¿¡ã€å¾®ä¿¡ä»¥åŠå› ç‰¹ç½‘ä¸Šå³æ—¶é€šä¿¡ç­‰å·¥å…·ï¼Œèƒ½å¤Ÿä½“ç°ç¤¾äº¤ç½‘ç»œå…³ç³»çš„ä¸€æ‰‹æ•°æ®å·²ç»é€æ¸ä½¿å¾—â€œå…­åº¦ç©ºé—´â€ç†è®ºçš„éªŒè¯æˆä¸ºå¯èƒ½ã€‚ å‡å¦‚ç»™ä½ ä¸€ä¸ªç¤¾äº¤ç½‘ç»œå›¾ï¼Œè¯·ä½ å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¡ç®—ç¬¦åˆâ€œå…­åº¦ç©ºé—´â€ç†è®ºçš„ç»“ç‚¹å ç»“ç‚¹æ€»æ•°çš„ç™¾åˆ†æ¯”ã€‚ è¾“å…¥æ ¼å¼:è¾“å…¥ç¬¬1è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºç¤¾äº¤ç½‘ç»œå›¾çš„ç»“ç‚¹æ•°Nï¼ˆ1&lt;Nâ‰¤103ï¼Œè¡¨ç¤ºäººæ•°ï¼‰ã€è¾¹æ•°Mï¼ˆâ‰¤33Ã—Nï¼Œè¡¨ç¤ºç¤¾äº¤å…³ç³»æ•°ï¼‰ã€‚éšåçš„Mè¡Œå¯¹åº”Mæ¡è¾¹ï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹æ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯è¯¥æ¡è¾¹ç›´æ¥è¿é€šçš„ä¸¤ä¸ªç»“ç‚¹çš„ç¼–å·ï¼ˆèŠ‚ç‚¹ä»1åˆ°Nç¼–å·ï¼‰ã€‚ è¾“å‡ºæ ¼å¼:å¯¹æ¯ä¸ªç»“ç‚¹è¾“å‡ºä¸è¯¥ç»“ç‚¹è·ç¦»ä¸è¶…è¿‡6çš„ç»“ç‚¹æ•°å ç»“ç‚¹æ€»æ•°çš„ç™¾åˆ†æ¯”ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹å2ä½ã€‚æ¯ä¸ªç»“èŠ‚ç‚¹è¾“å‡ºä¸€è¡Œï¼Œæ ¼å¼ä¸ºâ€œç»“ç‚¹ç¼–å·:ï¼ˆç©ºæ ¼ï¼‰ç™¾åˆ†æ¯”%â€ã€‚ è¾“å…¥æ ·ä¾‹:1234567891010 91 22 33 44 55 66 77 88 99 10 è¾“å‡ºæ ·ä¾‹ï¼š123456789101: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00% ACä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1010;int G[N][N], n, m;bool visited[N];int SDS(int i){ int cnt = 0; int level = 0, last = i, tail = -1; queue&lt;int&gt; q; visited[i] = true; q.push(i); cnt++; while (!q.empty()) { int k = q.front(); q.pop(); for (int j = 1; j &lt;= n; j++) { if (j == k) continue; if (!visited[j] &amp;&amp; G[k][j]) { q.push(j); tail = j; visited[j] = true; cnt++; } } if (k == last) { level++; last = tail; } if (level == 6) break; } return cnt;}int main(){ cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); G[a][b] = 1; G[b][a] = 1; } for (int i = 1; i &lt;= n; i++) { int ret = SDS(i); printf(\"%d: %.2f\", i, (double)ret / n * 100); puts(\"%\"); memset(visited, false, sizeof(visited)); } return 0;}","link":"/2019/11/16/å…­åº¦ç©ºé—´/"},{"title":"åˆ·é¢˜æ€»ç»“1","text":"åˆ·é¢˜æ€»ç»“ç¬¬ä¸€ç¯‡ã€‚ ä¹’ä¹“çƒé¢˜ç›®é“¾æ¥ å¾ˆç®€å•çš„ä¸€é“é¢˜ï¼Œä½†æ˜¯ä»ç»†èŠ‚ä¸­ä¹Ÿèƒ½çœ‹å‡ºå¾ˆå¤§çš„å·®è·ã€‚ è‡ªå·±çš„ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main(){ string s; string str; s += 'e'; bool flag = true; while(flag) { cin &gt;&gt; str; for(int i = 0; i &lt; str.size(); i++) { s += str[i]; if(str[i] == 'E') { flag = false; break; } } } int win = 0, lose = 0; for(int i = 1; i &lt; s.size() + 1; i++) { if(s[i] == 'W') win++; else if(s[i] == 'L') lose++; else ; int a = max(lose, win); int b = min(lose, win); if((a == 11 &amp;&amp; b &lt;= 9) || (b &gt;= 10 &amp;&amp; a &gt;= b + 2) || s[i] == 'E') { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } puts(\"\"); win = 0, lose = 0; for(int i = 1; i &lt; s.size() + 1; i++) { if(s[i] == 'W') win++; else if(s[i] == 'L') lose++; else ; int a = max(lose, win); int b = min(lose, win); if((a == 21 &amp;&amp; b &lt;= 19) || (b &gt;= 20 &amp;&amp; a &gt;= b + 2) || s[i] == 'E') { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } return 0;} yæ€»çš„ä»£ç 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;void solve(string s, int score){ int win = 0, lose = 0; for(int i = 0; i &lt; s.size(); i++) { if(s[i] == 'W') win++; else lose++; if (max(win, lose) &gt;= score &amp;&amp; abs(win - lose) &gt;= 2) { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } printf(\"%d:%d\\n\", win, lose);}int main(){ string s; char c; while(cin &gt;&gt; c, c != 'E') s += c; solve(s, 11); puts(\"\"); solve(s, 21); return 0;} æ€»ç»“while(cin &gt;&gt; c, c != 'E') s += c;è¿™å¥è¯æŒºå¥½çš„ï¼Œä»¥åå¯ç”¨ã€‚æ¸…æ™°çš„æ€è·¯ï¼šéå†æ¯ä¸€ä¸ªå­—ç¬¦ï¼ŒæŒ‰ç…§æ¡ä»¶ç»™æŸä¸ªå˜é‡++ï¼Œç›´åˆ°è¿™å±€ç»“æŸï¼Œç»“æŸçš„æ¡ä»¶ï¼Œè¾¾åˆ°åˆ†åˆ¶ä¸”åˆ†å·®å¤§äº2ã€‚ å…¬äº¤æ¢ä¹˜ç®€å•çš„æ¨¡æ‹Ÿé¢˜ã€‚ é¢˜ç›®é“¾æ¥ è‡ªå·±çš„ä»£ç æ²¡å†™å‡ºæ¥ã€‚ã€‚ã€‚ yæ€»çš„ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 100010;struct Point{ int price, time; bool used;}q[N];int n, res;int main(){ scanf(\"%d\", &amp;n); int Type, Price, Time; int hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { scanf(\"%d%d%d\", &amp;Type, &amp;Price, &amp;Time); if(Type == 0) { res += Price; ++tt; q[tt].price = Price, q[tt].time = Time; } else { while(hh &lt;= tt &amp;&amp; Time - q[hh].time &gt; 45) hh++; bool success = false; for(int j = hh; j &lt;= tt; j++) { if(!q[j].used &amp;&amp; q[j].price &gt;= Price) { q[j].used = true; success = true; break; } } if(!success) res += Price; } } cout &lt;&lt; res &lt;&lt; endl; return 0;} æ€»ç»“åˆ æ‰æŸä¸ªç»“ç‚¹ä¸ä¸€å®šçœŸçš„è¦åˆ æ‰ï¼Œå¯ä»¥å¼€ä¸€ä¸ªboolæ•°ç»„åœ¨å¯¹åº”çš„ä½ç½®ä¸Šæ ‡è®°ã€‚æ¸…æ™°çš„æ€è·¯ï¼šè¦ç®—æ€»çš„èŠ±è´¹ï¼Œåªæœ‰ä¸¤ç§æƒ…å†µï¼Œè¦ä¹ˆååœ°é“ï¼Œè¦ä¹ˆåå…¬äº¤ã€‚åœ°é“ä¸€å®šä¼šèŠ±é’±ï¼Œå…¬äº¤çœ‹æœ‰æ²¡æœ‰ä¼˜æƒ åˆ¸ï¼Œèƒ½ä½¿ç”¨ä¼˜æƒ åˆ¸çš„æ¡ä»¶ï¼š1.æ—¶é—´é—´éš”å°äºç­‰äº45åˆ†é’Ÿï¼Œè¿™ä¸ªæ—¶å€™å°±åº”è¯¥æƒ³åˆ°æ»‘åŠ¨çª—å£ã€‚2.ä¼˜æƒ åˆ¸å¤§äºå…¬äº¤ç¥¨é’±ã€‚å¦‚æœ‰å¤šå¼ èƒ½ç”¨çš„ä¼˜æƒ åˆ¸ç”¨æ—©çš„ï¼Œæƒ³åˆ°é˜Ÿåˆ—ã€‚","link":"/2019/11/30/åˆ·é¢˜æ€»ç»“1/"},{"title":"å„ç§æ’åºç®—æ³•","text":"å„ç§æ’åºç®—æ³•çš„æ€»ç»“ è§„å®šä¸€ä¸ªç»Ÿä¸€çš„æ¥å£: 123456template &lt;typename T&gt;void xxxx_sort(T *arr, int l, int r){ /* * å‡½æ•°å…·ä½“å®ç° */} æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)å†’æ³¡æ’åº123456789101112template &lt;typename T&gt;void bubble_sort(T *arr, int l, int r){ for (int i = r - 1; i &gt;= l; i--){ bool Swap = false; for (int j = l; j &lt;= i; j++) if (arr[j] &gt; arr[j + 1]){ swap(arr[j], arr[j + 1]); Swap = true; } if (!Swap) break; }} æ’å…¥æ’åº1234template &lt;typename T&gt;void insert_sort(T *arr, int l, int r){} é€‰æ‹©æ’åº12 æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)å¿«é€Ÿæ’åº1234567891011121314151617181920template &lt;typename T&gt;void quick_sort(T *arr, int l, int r){ if (l &gt;= r) return; int x = arr[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while (i &lt; j){ while (arr[++i] &lt; x) ; while (arr[--j] &gt; x) ; if (i &lt; j) swap(arr[i], arr[j]); } quick_sort&lt;int&gt;(arr, l, j); quick_sort&lt;int&gt;(arr, j + 1, r);} å½’å¹¶æ’åº123456789101112131415161718192021222324252627282930template &lt;typename T&gt;void merge_sort(T *arr, int l, int r){ T *tmp = new T[r - l + 1]; m_sort&lt;int&gt;(arr, tmp, l, r); delete tmp;}template &lt;typename T&gt;void m_sort(T *arr, T *tmp, int l ,int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; m_sort&lt;T&gt;(arr, tmp, l, mid); m_sort&lt;T&gt;(arr, tmp, mid + 1, r); int k = l; int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r){ if (arr[i] &lt;= arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while (i &lt;= mid) tmp[k++] = arr[i++]; while (j &lt;= r) tmp[k++] = arr[j++]; for (int i = l; i &lt;= r; i++) arr[i] = tmp[i];}","link":"/2019/12/17/å„ç§æ’åºç®—æ³•/"},{"title":"åŒˆç‰™åˆ©ç®—æ³•","text":"åŒˆç‰™åˆ©ç®—æ³•æ˜¯ä¸€ç§åœ¨å¤šé¡¹å¼æ—¶é—´å†…æ±‚è§£ä»»åŠ¡åˆ†é…é—®é¢˜çš„ç»„åˆä¼˜åŒ–ç®—æ³•ï¼Œå¹¶æ¨åŠ¨äº†åæ¥çš„åŸå§‹å¯¹å¶æ–¹æ³•ã€‚ç¾å›½æ•°å­¦å®¶å“ˆç½—å¾·Â·åº“æ©äº1955å¹´æå‡ºè¯¥ç®—æ³•ã€‚æ­¤ç®—æ³•ä¹‹æ‰€ä»¥è¢«ç§°ä½œåŒˆç‰™åˆ©ç®—æ³•ï¼Œæ˜¯å› ä¸ºç®—æ³•å¾ˆå¤§ä¸€éƒ¨åˆ†æ˜¯åŸºäºä»¥å‰åŒˆç‰™åˆ©æ•°å­¦å®¶DÃ©nes KÅ‘nigå’ŒJenÅ‘ EgervÃ¡ryçš„å·¥ä½œä¹‹ä¸Šåˆ›å»ºèµ·æ¥çš„ã€‚ â€”â€”â€”â€”â€”ç™¾åº¦ç™¾ç§‘ æ€è·¯12 æ—¶é—´å¤æ‚å¤«å…·ä½“é¢˜ç›®1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, M = 100010;int n1, n2, m, res;int h[N], e[M], ne[M], idx;int match[N]; // é…å¯¹bool st[N];void add(int x, int y){ e[idx] = y; ne[idx] = h[x]; h[x] = idx++;}bool find(int x){ for(int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if(!st[j]) { st[j] = true; if(!match[j] || find(match[j])) { match[j] = x; return true; } } } return false;}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d%d\", &amp;n1, &amp;n2, &amp;m); while (m--) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); } for(int i = 1; i &lt;= n1; i++) { memset(st, false, sizeof(st)); if(find(i)) res++; } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2019/11/27/åŒˆç‰™åˆ©ç®—æ³•/"},{"title":"å½’å¹¶æ’åº","text":"é¢˜ç›®é“¾æ¥ 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N], tmp[N];int n;void merge_sort(int q[], int l, int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; } while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];}int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); merge_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0;}","link":"/2019/11/08/å½’å¹¶æ’åº/"},{"title":"å¾ªç¯é˜Ÿåˆ—çš„æ“ä½œ","text":"â€‹ ä¸ºå……åˆ†åˆ©ç”¨å‘é‡ç©ºé—´ï¼Œå…‹æœå‡æº¢å‡ºç°è±¡çš„æ–¹æ³•æ˜¯ï¼šå°†å‘é‡ç©ºé—´æƒ³è±¡ä¸ºä¸€ä¸ªé¦–å°¾ç›¸æ¥çš„åœ†ç¯ï¼Œå¹¶ç§°è¿™ç§å‘é‡ä¸ºå¾ªç¯å‘é‡ã€‚å­˜å‚¨åœ¨å…¶ä¸­çš„é˜Ÿåˆ—ç§°ä¸ºå¾ªç¯é˜Ÿåˆ—ï¼ˆCircular Queueï¼‰ã€‚å¾ªç¯é˜Ÿåˆ—æ˜¯æŠŠé¡ºåºé˜Ÿåˆ—é¦–å°¾ç›¸è¿ï¼ŒæŠŠå­˜å‚¨é˜Ÿåˆ—å…ƒç´ çš„è¡¨ä»é€»è¾‘ä¸Šçœ‹æˆä¸€ä¸ªç¯ï¼Œæˆä¸ºå¾ªç¯é˜Ÿåˆ—ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10#define ERROR 1#define OK 0typedef int Status;typedef int QueueElemType;typedef enum { false, true } bool;typedef struct{ QueueElemType *data; int front; int rear;}SqQueue;Status InitQueue(SqQueue **pQ);Status DestoryQueue(SqQueue *Q);Status ClearQueue(SqQueue *Q);bool QueueEmpty(SqQueue *Q);bool QueueFull(SqQueue *Q);Status GetHead(SqQueue *Q, QueueElemType *e);Status EnQueue(SqQueue *Q, QueueElemType e);Status DeQueue(SqQueue *Q, QueueElemType *e);void PrintALLQueue(SqQueue *Q);void PrintQueue(SqQueue *Q);int main() { int status = -1; SqQueue *Q = NULL; status = InitQueue(&amp;Q); if (status == ERROR) { printf(\"func InitQueue() error!\\n\"); } PrintALLQueue(Q); PrintQueue(Q); int choice = -1; int e = 0; while (1) { printf(\"1 æ·»åŠ  2 åˆ é™¤ 0 é€€å‡º\\n\"); scanf(\"%d\", &amp;choice); switch (choice) { case 1: printf(\"Please enter e:\"); scanf(\"%d\", &amp;e); status = EnQueue(Q, e); if (status == ERROR) { printf(\"FULL!\\n\"); } PrintALLQueue(Q); PrintQueue(Q); break; case 2: status = DeQueue(Q, &amp;e); if (status == ERROR) { printf(\"EMPTY!\\n\"); } else printf(\"The number is %d.\\n\", e); PrintALLQueue(Q); PrintQueue(Q); break; case 0:exit(0); } } DestoryQueue(Q); Q = NULL; return 0;}Status InitQueue(SqQueue **pQ){ SqQueue *Q; Q = (SqQueue*)malloc(sizeof(SqQueue)); if(Q == NULL) { printf(\"åˆ†é…å†…å­˜å¤±è´¥!\\n\"); return ERROR; } Q-&gt;data = (QueueElemType*)malloc(MAXSIZE * sizeof(QueueElemType)); if (Q-&gt;data == NULL) { printf(\"åˆ†é…å†…å­˜å¤±è´¥!\\n\"); return ERROR; } Q-&gt;front = 0; Q-&gt;rear = 0; *pQ = Q; return OK;} Status DestoryQueue(SqQueue *Q){ if (Q-&gt;data != NULL) { free(Q-&gt;data); Q-&gt;data = NULL; return OK; } else return ERROR;}Status ClearQueue(SqQueue *Q){ Q-&gt;front = 0; Q-&gt;rear = 0; return OK;}bool QueueEmpty(SqQueue *Q){ if (Q-&gt;front == Q-&gt;rear) return true; else return false;}bool QueueFull(SqQueue *Q){ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) return true; else return false;}Status GetHead(SqQueue *Q, QueueElemType *e){ if (QueueEmpty(Q) == true) { return ERROR; } else *e = Q-&gt;data[Q-&gt;front]; return OK;}Status EnQueue(SqQueue *Q, QueueElemType e){ if (QueueFull(Q) == true) return ERROR; Q-&gt;data[Q-&gt;rear] = e; Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; return OK;}Status DeQueue(SqQueue *Q, QueueElemType *e){ if (QueueEmpty(Q) == true) { return ERROR; } *e = Q-&gt;data[Q-&gt;front]; Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; return OK;}Status QueueLength(SqQueue *Q, int *length){ *length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE; return OK;}void PrintALLQueue(SqQueue *Q){ for (int i = 0; i &lt; MAXSIZE; i++) { printf(\"%d \", Q-&gt;data[i]); } putchar('\\n');}void PrintQueue(SqQueue *Q){ int status = -1; int length = 0; QueueLength(Q, &amp;length); for (int i = 0; i &lt; length; i++) { printf(\"%d \", (Q-&gt;data[(Q-&gt;front + i) % MAXSIZE])); } putchar('\\n');}","link":"/2019/09/06/å¾ªç¯é˜Ÿåˆ—çš„æ“ä½œ/"},{"title":"å¿«é€Ÿæ’åº","text":"é¢˜ç›®é“¾æ¥ å¿«é€Ÿæ’åºçš„æ¨¡æ¿ï¼š 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 1e5;int q[N];int n;void quick_sort(int q[], int l, int r){ if(l &gt;= r) return; int x = q[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while(i &lt; j) { while(q[++i] &lt; x) ; while(q[--j] &gt; x) ; if(i &lt; j) swap(q[i], q[j]); } quick_sort(q, l ,j); quick_sort(q, j + 1, r);}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); quick_sort(q, 0, n - 1); for(int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0;}","link":"/2019/10/28/å¿«é€Ÿæ’åº/"},{"title":"bugè®°å½•","text":"æœ¬æ–‡å°†è®°å½•ä»¥åé‡åˆ°çš„bugåŠè§£å†³çš„æ–¹æ³•ï¼ˆå› ä¸ºæˆ‘è§‰å¾—è¿™ä¸ªä¸œè¥¿å¾ˆæœ‰å¿…è¦å†™ï¼Œæœ‰çš„æ—¶å€™å°±ç®€å•çš„ä¸€ä¸ªåœ°æ–¹å°±è¦debugå¥½ä¹…ğŸ˜­ğŸ˜­ï¼‰ CRT detected that the application wrote to memory after end of heap bufferæˆ‘æœäº†çœ‹äº†è¿™ä¹ˆé•¿æ—¶é—´ç«Ÿç„¶æ˜¯æ•°ç»„è¶Šç•Œï¼Œæˆ‘ä»ä¸‹æ ‡1å¼€å§‹äº†ã€‚ğŸ˜‚ Stack overflowé€’å½’æ—¶æ²¡æœ‰å†™é€’å½’å‡ºå£ã€‚ result_pointer!=nullptrscanf &amp;&amp;&amp;&amp;&amp;&amp; if elseå†™äº†è¿™ä¹ˆå¤šçš„if elseæ²¡æƒ³åˆ°å±…ç„¶è¿˜ä¼šå†è¿™ç§åœ°æ–¹å‡ºç°é—®é¢˜ğŸ˜±ã€‚å†™æˆäº†ï¼š 1234if(true) if(true) func();else if(true) func1(); å‘†å‘†å‘†å‘† äºŒç»´å­—ç¬¦æ•°ç»„çš„åˆå§‹åŒ–å®šä¹‰äº†ä¸€ä¸ªå…¨å±€çš„äºŒç»´æ•°ç»„g[5][5]ã€‚ åœ¨å‡½æ•°ä¸­åˆå§‹åŒ–æ—¶å†™æˆäº†g[5][5] = .......","link":"/2019/10/06/æŠ¥é”™è®°å½•/"},{"title":"æ‹¯æ•‘007","text":"Saving James Bond - Easy Version This time let us consider the situation in the movie â€œLive and Let Dieâ€ in which James Bond, the worldâ€™s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape â€“ he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big headâ€¦ Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape. Input Specification:Each input file contains one test case. Each case starts with a line containing two positive integers N (â‰¤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position. Output Specification:For each test case, print in a line â€œYesâ€ if James can escape, or â€œNoâ€ if not. Sample Input 1:12345678910111213141514 2025 -15-25 288 4929 15-35 -25 2827 -29-8 -28-20 -35-25 -20-13 29-30 15-35 4012 12 Sample Output 1:1Yes Sample Input 2:123454 13-12 1212 12-12 -1212 -12 Sample Output 2:1No ACä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100;PII vertex[N];bool visited[N], flag;int n, D;bool isSafe(PII v){ if (v.first == 0 &amp;&amp; v.second == 0) return D &gt; 50 - 7.5; return D &gt;= 50 - abs(v.first) || D &gt;= 50 - abs(v.second);}double distance(PII a, PII b) { return sqrt((a.first-b.first)*(a.first - b.first)+(a.second-b.second)*(a.second - b.second));}bool canJump(PII a, PII b){ if (a.first == 0 &amp;&amp; a.second == 0) return D + 7.5 &gt;= distance(a, b); else return D &gt;= distance(a, b);}bool DFS(PII v){ if (isSafe(v)) return true; for (int i = 0; i &lt; n; i++) { if (!visited[i] &amp;&amp; canJump(v, vertex[i])) { visited[i] = true; // return DFS(vertex[i]); flag = DFS(vertex[i]); if (flag) return true; } } return false;}int main(){ cin &gt;&gt; n &gt;&gt; D; for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;vertex[i].first, &amp;vertex[i].second); if (DFS({ 0, 0 })) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; system(\"pause\"); return 0;}","link":"/2019/11/16/æ‹¯æ•‘007/"},{"title":"æ•°çš„èŒƒå›´","text":"é¢˜ç›®é“¾æ¥ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); while (m--) { int x; scanf(\"%d\", &amp;x); int l = 0, r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (q[mid] &gt;= x) r = mid; else l = mid + 1; } if (q[l] != x) cout &lt;&lt; \"-1 -1\" &lt;&lt; endl; else { cout &lt;&lt; l &lt;&lt; \" \"; l = 0, r = n - 1; while (l &lt; r) { int mid = l + r + 1&gt;&gt; 1; if (q[mid] &lt;= x) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; } } return 0;}","link":"/2019/11/08/æ•°çš„èŒƒå›´/"},{"title":"æ•°ç»„æŒ‡é’ˆç±»å‹ä¸å‡½æ•°æŒ‡é’ˆç±»å‹","text":"ç”±äºæ•°ç»„ç±»å‹ä¸å‡½æ•°ç±»å‹çš„å®šä¹‰æ–¹æ³•å¾ˆç±»ä¼¼ï¼Œå› æ­¤æ”¾åˆ°ä¸€èµ·ã€‚ æ•°ç»„æŒ‡é’ˆæ•°ç»„ç±»å‹çš„å®šä¹‰12345678910typedef int (myArrayType)[10];int main(){ int a[10]; myArrayType b;//ç­‰ä»·äºint b[10]; a[0] = 1; b[0] = 1; cout &lt;&lt; a[0] &lt;&lt; \" \" &lt;&lt; b[0] &lt;&lt; endl; return 0;} è¾“å‡ºç»“æœï¼š æ•°ç»„æŒ‡é’ˆç±»å‹çš„å®šä¹‰12345678910typedef int(*myPArrayType)[10];int main(){ int a[10]; a[0] = 1; myPArrayType p; p = &amp;a; cout &lt;&lt; (*p)[0] &lt;&lt; endl; return 0;} è¾“å‡ºç»“æœï¼š myPArrayTypeæ˜¯æ•°ç»„çš„åœ°å€ï¼Œè€Œaæ˜¯æ•°ç»„é¦–å…ƒç´ çš„åœ°å€ï¼Œå› æ­¤myPArrayTypeç›¸å½“äºä¸€ä¸ªäºŒçº§æŒ‡é’ˆã€‚ è¯´åˆ°æ•°ç»„æŒ‡é’ˆå°±ä¸å¾—ä¸æä¸€ä¸‹æŒ‡é’ˆæ•°ç»„ï¼Œåˆå­¦æŒ‡é’ˆä¸æ•°ç»„æ—¶å¾ˆå®¹æ˜“æ··æ·†è¿™ä¸¤ä¸ªæ¦‚å¿µï¼Œä½†å…¶å®ä¹Ÿå¾ˆå¥½ç†è§£ã€‚æ•°ç»„æŒ‡é’ˆå¯ä»¥å¿µæˆæ•°ç»„çš„æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯è¯´æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œåªæ˜¯è¯¥æŒ‡é’ˆæŒ‡å‘çš„æ˜¯ä¸€ä¸ªæ•°ç»„ç½¢äº†ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢è¿™ä¸ªä¾‹å­ã€‚è€ŒæŒ‡é’ˆæ•°ç»„åˆå¯ä»¥å¿µæˆæŒ‡é’ˆçš„æ•°ç»„ï¼Œé¡¾åæ€ä¹‰æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œåªä¸è¿‡æ•°ç»„çš„å…ƒç´ æ˜¯æŒ‡é’ˆã€‚ å¦å¤–å€¼å¾—æ³¨æ„çš„æ˜¯a+1ä¸&amp;a+1å®Œå…¨ä¸åŒï¼ŒæŒ‡é’ˆ+1çš„æ­¥é•¿å–å†³äºæŒ‡é’ˆæ‰€æŒ‡çš„æ•°æ®ç±»å‹ï¼ŒaæŒ‡çš„æ˜¯intç±»å‹å› æ­¤å‘åç§»åŠ¨å››ä¸ªå­—èŠ‚ï¼Œè€Œ&amp;aæŒ‡å‘çš„æ˜¯ä¸€ä¸ªæ•°ç»„å› æ­¤å‘åç§»åŠ¨å››åä¸ªå­—èŠ‚ã€‚ å‡½æ•°æŒ‡é’ˆé€šè¿‡å‡½æ•°ç±»å‹å®šä¹‰å‡½æ•°æŒ‡é’ˆ123456789typedef int (myFuncType)(int);int main(){ int a = 5; myFuncType *Func; Func = &amp;add; cout &lt;&lt; Func(a) &lt;&lt; endl; return 0;} è¾“å‡ºç»“æœï¼š ç›´æ¥å®šä¹‰å‡½æ•°æŒ‡é’ˆç±»å‹12345678910typedef int (*myPFuncType)(int);int main(){ int a = 5; myPFuncType Func; //Func = &amp;add; //åŠ ä¸åŠ å–åœ°å€å·éƒ½å¯ä»¥ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ Func = add; cout &lt;&lt; Func(a) &lt;&lt; endl; return 0;} è¾“å‡ºç»“æœï¼š","link":"/2019/10/02/æ•°ç»„æŒ‡é’ˆç±»å‹ä¸å‡½æ•°æŒ‡é’ˆç±»å‹/"},{"title":"æ•°ç»„æ¨¡æ¿ç±»(MyVector)","text":"å®ç°éå¸¸ç®€å•çš„æ•°ç»„æ¨¡æ¿ç±»ï¼ˆMyVectorï¼‰ä¸­ç”¨åˆ°äº†æ³›å‹ç¼–ç¨‹ï¼ˆæ¨¡æ¿ç±»ç¼–ç¨‹ï¼‰ã€è¿ç®—ç¬¦é‡è½½ã€å‹å…ƒå‡½æ•°ç­‰çŸ¥è¯†ï¼Œæœ€é‡è¦çš„æ˜¯åŠ æ·±äº†å¯¹å†…å­˜åˆ†é…çš„ç†è§£ã€‚ æ‰€æœ‰å®¹å™¨æä¾›çš„éƒ½æ˜¯å€¼ï¼ˆvalueï¼‰è¯­æ„ï¼Œè€Œéå¼•ç”¨ï¼ˆreferenceï¼‰è¯­æ„ã€‚å®¹å™¨æ‰§è¡Œæ’å…¥å…ƒç´ çš„æ“ä½œæ—¶ï¼Œå†…éƒ¨å®æ–½æ‹·è´åŠ¨ä½œã€‚æ‰€ä»¥STLå®¹å™¨å†…å­˜å‚¨çš„å…ƒç´ å¿…é¡»èƒ½å¤Ÿè¢«æ‹·è´ï¼ˆå¿…é¡»æä¾›æ‹·è´æ„é€ å‡½æ•°ï¼‰ã€‚ å¼€å§‹çš„æ—¶å€™ä¸ç†è§£è¿™å¥è¯ï¼Œç„¶åè‡ªå·±æ•²ä»£ç å°±ç†è§£äº†ã€‚æˆ‘ä»¬åœ¨å¾€å®¹å™¨é‡Œå­˜æ•°æ®çš„æ—¶å€™ï¼Œæ˜¯è¿›è¡Œæ‹·è´åŠ¨ä½œï¼Œä¹Ÿå°±æ˜¯è¯´å°†å¤–éƒ¨å˜é‡çš„å€¼æ‹·è´ç»™å®¹å™¨ä¸­çš„å€¼ã€‚è¦è¿›è¡Œæ‹·è´å°±å¿…é¡»åˆ†é…å†…å­˜ï¼Œæ²¡æœ‰åˆ†é…å†…å­˜çš„è¯å¾€å“ªæ‹·æ•°æ®å‘¢ï¼Ÿï¼Ÿï¼Ÿï¼Ÿè€ŒåŸºç¡€æ•°æ®ç±»å‹çš„å˜é‡æ˜¯ä¸ç”¨æ‹…å¿ƒè¿™äº›é—®é¢˜çš„ï¼Œå› ä¸ºå½“æˆ‘ä»¬å†™ä¸‹int aæ—¶ç¼–è¯‘å™¨å·²ç»ä¸ºaåˆ†é…äº†å†…å­˜ï¼Œä½†æ˜¯å¦‚æœæ˜¯æŒ‡é’ˆå˜é‡å°±å¿…é¡»è€ƒè™‘æ·±æ‹·è´ä¸æµ…æ‹·è´çš„é—®é¢˜ï¼ˆå…¶å®è¿™ä¸ªåœ°æ–¹ç¬¬ä¸€æ¬¡çš„æ—¶å€™æˆ‘æƒ³çš„æ˜¯ï¼ŒMyVectorä¸æ˜¯å·²ç»åˆ†é…äº†å†…å­˜äº†å—ï¼Œä¸ºä»€ä¹ˆè¿˜è¦åˆ†é…å‘¢ï¼Ÿå…¶å®åœ¨MyVectorä¸­æ˜¯ç»™ç±»åˆ†é…äº†å†…å­˜è¯´ç™½äº†å°±æ˜¯ç»™ç±»ä¸­çš„æˆå‘˜å˜é‡åˆ†é…äº†å†…å­˜ï¼Œè€Œæˆå‘˜å˜é‡è‹¥æœ‰æŒ‡é’ˆçš„è¯ï¼Œå®ƒåªæ˜¯ä¸ºæŒ‡é’ˆåˆ†é…äº†å†…å­˜ï¼Œè€Œæˆ‘ä»¬æ‰€éœ€è¦çš„æ˜¯åˆ†é…æŒ‡é’ˆæ‰€æŒ‡å‘çš„å†…å­˜ç©ºé—´åˆ†é…å†…å­˜ï¼‰ã€‚ MyVector.h12345678910111213141516171819#pragma once#include&lt;iostream&gt;using namespace std;template &lt;typename Type&gt;class MyVector{ friend ostream&amp; operator&lt;&lt; &lt;Type&gt; (ostream &amp;out, const MyVector &amp;obj); //åœ¨æ³›å‹ç¼–ç¨‹å½“ä¸­ï¼Œç±»æ¨¡æ¿ä¸­é¿å…ä½¿ç”¨å‹å…ƒå‡½æ•°ï¼Œé™¤äº†é‡è½½ \"&lt;&lt;\" \"&gt;&gt;\" å·¦ç§»å³ç§»è¿è¾“ç®—ç¬¦ï¼Œå…¶ä»–çš„å‡½æ•°éƒ½å†™æˆæˆ //å‘˜å‡½æ•°public: MyVector(int len); MyVector(const MyVector &amp;obj); ~MyVector();public: MyVector&amp; operator=(const MyVector &amp;obj); Type&amp; operator[](int index);private: Type *mSpace; int len;}; MyVector.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;#include\"MyVector.h\"template &lt;typename Type&gt;MyVector&lt;Type&gt;::MyVector(int len){ this-&gt;len = len; mSpace = new Type[len];}template &lt;typename Type&gt;MyVector&lt;Type&gt;::MyVector(const MyVector &amp;obj){ this-&gt;len = obj.len; mSpace = new Type[len]; for (int i = 0; i &lt; len; i++) { mSpace[i] = obj.mSpace[i]; }}template &lt;typename Type&gt;MyVector&lt;Type&gt;::~MyVector(){ if (mSpace != NULL) { delete[] mSpace; mSpace = NULL; len = 0; }}template &lt;typename Type&gt;MyVector&lt;Type&gt;&amp; MyVector&lt;Type&gt;::operator=(const MyVector&lt;Type&gt; &amp;obj){ if (mSpace != NULL) { delete[] mSpace; mSpace = NULL; len = 0; } this-&gt;len = obj.len; mSpace = new Type[len]; for (int i = 0; i &lt; len; i++) { mSpace[i] = obj.mSpace[i]; } return *this;}template &lt;typename Type&gt;Type&amp; MyVector&lt;Type&gt;::operator[](int index){ return mSpace[index];}template &lt;typename Type&gt;ostream&amp; operator&lt;&lt;(ostream &amp;out, const MyVector&lt;Type&gt; &amp;obj){ for (int i = 0; i &lt; obj.len; i++) { cout &lt;&lt; obj.mSpace[i]; } cout &lt;&lt; endl; return out;} main.cppæµ‹è¯•intå‹ 123456789101112int main(){ MyVector&lt;int&gt; arr1(10); for (int i = 0; i &lt; 10; i++) { arr1[i] = i + 1; } cout &lt;&lt; arr1 &lt;&lt; endl; MyVector&lt;int&gt; arr2 = arr1; cout &lt;&lt; arr2 &lt;&lt; endl; return 0;} æµ‹è¯•char å‹ 123456789101112int main02(){ MyVector&lt;char&gt; str1(10); for (int i = 0; i &lt; 10; i++) { str1[i] = 'a' + i; } cout &lt;&lt; str1 &lt;&lt; endl; MyVector&lt;char&gt; str2 = str1; cout &lt;&lt; str2 &lt;&lt; endl; return 0;} æµ‹è¯•Teacherç±» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//Teacherç±»ä¸­åå­—æ˜¯å­—ç¬¦æ•°ç»„ï¼Œå³åœ¨æ ˆä¸Šåˆ†é…å†…å­˜ã€‚class Teacher{ friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Teacher &amp;obj);public: Teacher() { age = 0; strcpy(name, \"\"); } Teacher(const char *name,int age) { strcpy(this-&gt;name, name); this-&gt;age = age; } void printT() { cout &lt;&lt; \"name:\" &lt;&lt; name &lt;&lt; \" age:\" &lt;&lt; age &lt;&lt; endl; } //æ ˆä¸Šåˆ†é…çš„å†…å­˜è¿˜ç”¨æˆ‘å»é‡Šæ”¾ï¼Ÿ æˆ‘å‚»äº† -_- //~Teacher() //{ // if (name != NULL) // { // delete name; // name = NULL; // age = 0; // } //}private: char name[16]; char *name; int age;};ostream&amp; operator&lt;&lt;(ostream&amp; out, Teacher &amp;obj){ out &lt;&lt; obj.name &lt;&lt; \" \" &lt;&lt; obj.age &lt;&lt; endl; return out;}//Teacherä¸­åå­—æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå³éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨åˆ†é…å†…å­˜å¦åˆ™ä¼šå‡ºç°ç¨‹åºå®•æ‰çš„æƒ…å†µã€‚class Teacher{ friend ostream&amp; operator&lt;&lt;(ostream &amp;out, Teacher &amp;obj) { out &lt;&lt; \"name:\" &lt;&lt; obj.name &lt;&lt; \" age:\" &lt;&lt; obj.age &lt;&lt; endl; return out; }public: //è¿™æ ·çš„è¯å¯ä»¥ä¸å†™æ— å‚æ„é€ å‡½æ•°å— ç»æµ‹è¯•å¯ä»¥ é‚£è¿˜è¦æ— å‚æ„é€ å‡½æ•°å¹²å˜›å‘¢ï¼Ÿï¼Ÿï¼Ÿ Teacher(const char *name = \"\", int age = 0) { //è¿™ä¸ªåœ°æ–¹è¦å—ï¼Ÿ this-&gt;age = age; this-&gt;name = new char[strlen(name) + 1];//è¿˜æœ‰\\0 strcpy(this-&gt;name, name); } Teacher(const Teacher &amp;obj) { this-&gt;age = obj.age; name = new char[strlen(obj.name) + 1]; strcpy(name, obj.name); } ~Teacher() { if (name != NULL) { delete[] name; name = NULL; age = 0; } }public: Teacher&amp; operator=(const Teacher &amp;obj) { this-&gt;age = obj.age; this-&gt;name = new char[strlen(obj.name) + 1]; strcpy(name, obj.name); return *this; } void printT() { cout &lt;&lt; \"name:\" &lt;&lt; name &lt;&lt; \" age:\" &lt;&lt; age &lt;&lt; endl; }private: char *name; int age;};int main(){ MyVector&lt;Teacher&gt; tArray(3); Teacher t1(\"123\", 30); Teacher t2(\"456\", 31); Teacher t3(\"789\", 32); tArray[0] = t1; tArray[1] = t2; tArray[2] = t3; Teacher t4; for (int i = 0; i &lt; 3; i++) { Teacher tmp = tArray[i]; tmp.printT(); } cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; tArray &lt;&lt; endl; return 0;}","link":"/2019/10/05/æ•°ç»„æ¨¡æ¿ç±»-MyVector/"},{"title":"æœ€å°ç”Ÿæˆæ ‘æ¨¡æ¿","text":"æœ€å°ç”Ÿæˆæ ‘ä¹Ÿæ˜¯å›¾è®ºä¸­çš„ä¸€ç±»é—®é¢˜ã€‚æœ€å°ç”Ÿæˆæ ‘é—®é¢˜æœ€ç»ˆè¦æ±‚å‡ºä½¿æ‰€æœ‰ç‚¹è¿é€šçš„æœ€çŸ­è·ç¦»ï¼Œå…¸å‹é—®é¢˜ä¸ºä¿®å…¬è·¯é—®é¢˜ã€‚ Primç®—æ³•é€‚åˆç¨ å¯†å›¾ æ€è·¯12345Primç®—æ³•ä¸Dijkstraç®—æ³•æœ‰å¾ˆå¤šç›¸ä¼¼ä¹‹å¤„ã€‚1. åˆå§‹åŒ–è·ç¦»ï¼Œä¸Dijkstraç®—æ³•ä¸åŒçš„æ˜¯Primç®—æ³•è¦å°†æ‰€æœ‰ç‚¹çš„è·ç¦»åˆå§‹åŒ–æ­£æ— ç©·ã€‚2. å¾ªç¯næ¬¡ æ¯ä¸€æ¬¡æ‰¾åˆ°ä¸åœ¨ç”Ÿæˆæ ‘ä¸­è·ç¦»æœ€å°çš„ç‚¹ï¼ˆè¿™é‡Œçš„è·ç¦»æŒ‡çš„æ˜¯è·ç¦»é›†åˆçš„è·ç¦»è€ŒDijkstraæŒ‡çš„æ˜¯åˆ°ä¸€å·ç‚¹çš„è·ç¦»ï¼‰ å†ç”¨è¿™ä¸ªç‚¹æ›´æ–°ä¸´ç•Œç‚¹çš„è·ç¦»ã€‚ æ—¶é—´å¤æ‚åº¦å…·ä½“é¢˜ç›®123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int g[N][N], dist[N];bool st[N];int n, m, res;int prim(){ memset(dist, 0x3f, sizeof(dist)); // å¾ªç¯næ¬¡ for(int i = 0; i &lt; n; i++) { // å¯»æ‰¾é›†åˆä»¥å¤–è·ç¦»æœ€å°çš„ç‚¹ int t = -1; for(int j = 1; j &lt;= n; j++) { if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; } st[t] = true; // å¦‚æœè¿™ä¸ªç‚¹ä¸æ˜¯ç¬¬ä¸€ä¸ªç‚¹å¹¶ä¸”è·ç¦»æœ€çŸ­çš„ç‚¹ä¸ºæ­£æ— ç©· åˆ™ä¸è¿é€š ç›´æ¥è¿”å›false if (i &amp;&amp; dist[t] == INF) return INF; // å¦‚æœè¿™ä¸ªç‚¹ä¸æ˜¯ç¬¬ä¸€ä¸ªç‚¹åˆ™åŠ åˆ°æœ€ç»ˆçš„ç­”æ¡ˆä¸­ if (i) res += dist[t]; for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]); } return res;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if (i == j) g[i][j] = 0; else g[i][j] = INF; while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); g[x][y] = g[y][x] = min(g[x][y], c); } int ret = prim(); if(ret == INF) puts(\"impossible\"); else cout &lt;&lt; ret; return 0;} Kruskalç®—æ³•æ€è·¯12341. æ’åº å°†æ‰€æœ‰çš„è¾¹æŒ‰ç…§æƒé‡æ’åº2. éå†æ‰€æœ‰çš„è¾¹ a-&gt;b æƒé‡ä¸º w å¦‚æœ a b ä¸åœ¨åŒä¸€ä¸ªé›†åˆ åˆ™åˆå¹¶ è€ƒå¯Ÿå¹¶æŸ¥é›†çš„çŸ¥è¯† æ—¶é—´å¤æ‚åº¦ä¸»è¦åœ¨æ’åºçš„è¿‡ç¨‹ï¼šO(mlogm) å…·ä½“é¢˜ç›®12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100010, M = 200010;// å› ä¸ºåªéœ€éå†æ‰€æœ‰çš„è¾¹æ‰€ä»¥å¯ä»¥ç”¨ä¸€ä¸ªç®€å•çš„ç»“æ„ä½“æ•°ç»„ï¼Œæ¥å­˜å‚¨è¾¹struct Edge{ int x, y, c; // è¿ç®—ç¬¦é‡è½½ æ®æˆ‘çš„æˆ‘çŒœæµ‹sortå†…éƒ¨å®ç°çš„æ—¶å€™ç”¨çš„æ˜¯ &lt; ç„¶åç»“æ„ä½“ä¸æ˜¯åŸºæœ¬æ•°æ®ç±»å‹ æ‰€ä»¥è¦é‡è½½ // c++ä¸­ classä¸struct å®šä¹‰ç±»å¯ä»¥äº’æ¢ åªæ˜¯ åœ¨é»˜è®¤æƒ…å†µä¸‹ structä¸ºpublic classä¸ºprivate // è¿™ä¸ªä¸œè¥¿ä¼°è®¡è¦çœ‹ä¾¯æ·çš„ã€ŠSTLæºç å‰–æã€‹å§ã€‚ bool operator&lt; (const Edge &amp;obj) const { return c &lt; obj.c; }}edges[M];int p[N];int n, m, cnt, res;int find(int x){ // è·¯å¾„å‹ç¼© if(x != p[x]) p[x] = find(p[x]); return p[x];}bool kruskal(){ sort(edges, edges + m); // åˆå§‹åŒ–å¹¶æŸ¥é›† for(int i = 1; i &lt;= n; i++) p[i] = i; for(int i = 0; i &lt; m; i++) { int x = edges[i].x, y = edges[i].y, c = edges[i].c; int a = find(x), b = find(y); if(a != b) { p[a] = b; res += c; cnt++; } } if(cnt &lt; n - 1) return false; return true;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); //edges[i] = {x, y, c}; c11 edges[i].x = x; edges[i].y = y; edges[i].c = c; } if(kruskal()) cout &lt;&lt; res &lt;&lt; endl; else puts(\"impossible\"); return 0;}","link":"/2019/11/26/æœ€å°ç”Ÿæˆæ ‘æ¨¡æ¿/"},{"title":"æŸ“è‰²æ³•åˆ¤å®šäºŒåˆ†å›¾","text":"äºŒåˆ†å›¾ï¼š ä¸€ä¸ªæ— å‘å›¾ï¼Œä½¿å¾—é¡¶ç‚¹é›†Vå¯ä»¥åˆ†å‰²ä¸ºä¸¤ä¸ªäº’ä¸ç›¸äº¤çš„å­é›†A,Bï¼Œä½¿å¾—æ‰€æœ‰è¾¹ä¸¤ç«¯åˆ†åˆ«å±äºä¸¤ä¸ªå­é›†A,Bã€‚ æ€è·¯1éå†æ¯ä¸€ä¸ªç‚¹ï¼Œä»æ¯ä¸€ä¸ªç‚¹å¼€å§‹è¿›è¡Œæ·±æœï¼Œæ·±æœçš„è¿‡ç¨‹ä¸­è¿›è¡ŒæŸ“è‰²ã€‚ æ—¶é—´å¤æ‚åº¦å…·ä½“é¢˜ç›®1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 100010, M = 200010;int h[N], e[M], ne[M], idx;int color[N]; // 0ä»£è¡¨è¿˜æ²¡æŸ“è‰² æŸ“æˆ 1å’Œ2int n, m;void add(int x, int y){ e[idx] = y; ne[idx] = h[x]; h[x] = idx++;}bool dfs(int u, int c){ color[u] = c; // æŸ“è‰² for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if(!color[j]) { if(!dfs(j, 3 - c)) return false; } else if(color[j] == c) return false; } return true;}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y), add(y, x); } bool success = true; for(int i = 0; i &lt; n; i++) { if(!color[i]) if(!dfs(i, 1)) // å¦‚æœä»iå¼€å§‹æŸ“è‰²çš„è¿‡ç¨‹ä¸­å‡ºç°äº†çŸ›ç›¾ é‚£ä¹ˆå¤±è´¥ { success = false; break; } } if(success) puts(\"Yes\"); else puts(\"No\"); return 0;}","link":"/2019/11/27/æŸ“è‰²æ³•åˆ¤å®šäºŒåˆ†å›¾/"},{"title":"æ ‘çš„åŒæ„","text":"æ¯æ¬¡åšè¯¾åå¸ƒç½®çš„é¢˜å°±è¦åšå¥½ä¹…ï¼Œè¿™ä¸ªé¢˜è€å¸ˆè®²çš„æ—¶å€™ç”¨çš„æ˜¯Cè¯­è¨€ï¼Œæˆ‘æƒ³ç”¨C++ä¸­çš„vectoråšå‘ç°åšçš„è¿‡ç¨‹ä¸­é‡åˆ°äº†è®¸å¤šçš„é—®é¢˜ï¼Œè€æ˜¯å‡ºç°ç¨‹åºå®•æ‰çš„é—®é¢˜ï¼Œä½†è®©æˆ‘ååˆ†å¼€å¿ƒçš„æ˜¯ï¼Œæ”¹å®Œä»¥åå±…ç„¶ä¸€æ¬¡å°±ACäº†åˆ«ææœ‰å¤šæ¿€åŠ¨äº†ï¼Œä¸è¿‡è¿™ä»£ç åªæ˜¯å®Œæˆäº†åŠŸèƒ½ï¼Œå¯è¯»æ€§åšçš„å¾ˆå·®ï¼Œå°¤å…¶æ˜¯åˆ¤æ–­åŒæ„çš„å‡½æ•°ï¼Œä½†æ˜¯ä»¥åå›è¿‡å¤´æ¥çœ‹è¿˜æ˜¯å¾ˆæœ‰æ„æ€çš„å§ğŸ˜‚ğŸ˜‚ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define Null -1typedef char ElemType;struct TreeNode{ ElemType Data; int lchild; int rchild;};int TreeCreate(vector&lt;TreeNode&gt; &amp;t, int n);bool isomorphic(vector&lt;TreeNode&gt; &amp;t1, int t1Root, vector&lt;TreeNode&gt; &amp;t2, int t2Root);int t1Root;int t2Root;int main(){ int n; cin &gt;&gt; n; vector&lt;TreeNode&gt; t1(n); t1Root = TreeCreate(t1, n); cin &gt;&gt; n; vector&lt;TreeNode&gt; t2(n); t2Root = TreeCreate(t2, n); if (isomorphic(t1, t1Root, t2, t2Root)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;}int TreeCreate(vector&lt;TreeNode&gt; &amp;t, int n){ int root = -1; vector&lt;int&gt; arr(n, 1); for (int i = 0; i &lt; n; i++) { char cl, cr; cin &gt;&gt; t[i].Data &gt;&gt; cl &gt;&gt; cr; if (cl == '-') t[i].lchild = Null; else { t[i].lchild = cl - '0'; arr[t[i].lchild] = 0; } if (cr == '-') t[i].rchild = Null; else { t[i].rchild = cr - '0'; arr[t[i].rchild] = 0; } } for (int i = 0; i &lt; n; i++) { if (arr[i] != 0) { root = i; break; } } return root;}//è¦æ˜ç¡®çš„ä¸€ç‚¹æ˜¯NullæŒ‡çš„æ˜¯æ ‘çš„å­˜å‚¨ç»“æ„ä¸ºæ•°ç»„çš„ä¸‹æ ‡ ä¸‹æ ‡æ˜¯ä»é›¶å¼€å§‹ æ‰€ä»¥å·¦å„¿å­æˆ–è€…å³å„¿å­ ä¸ºNull å³æ²¡æœ‰bool isomorphic(vector&lt;TreeNode&gt; &amp;t1, int t1Root, vector&lt;TreeNode&gt; &amp;t2, int t2Root){ if (t1Root == Null &amp;&amp; t2Root == Null) return true; else if ((t1Root != Null &amp;&amp; t2Root == Null) || (t1Root == Null &amp;&amp; t2Root != Null)) return false; else if (t1[t1Root].Data != t2[t2Root].Data) return false; else if (t1[t1Root].lchild == Null &amp;&amp; t2[t2Root].lchild == Null) return isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].rchild); else if ((t1[t1Root].lchild != Null &amp;&amp; t2[t2Root].lchild != Null) &amp;&amp; (t1[t1[t1Root].lchild].Data == t2[t2[t2Root].lchild].Data)) return isomorphic(t1, t1[t1Root].lchild, t2, t2[t2Root].lchild) &amp;&amp; isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].rchild); else return isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].lchild)&amp;&amp; isomorphic(t1, t1[t1Root].lchild, t2, t2[t2Root].rchild);}","link":"/2019/10/23/æ ‘çš„åŒæ„/"},{"title":"æ£‹ç›˜é—®é¢˜","text":"åœ¨ä¸€ä¸ªç»™å®šå½¢çŠ¶çš„æ£‹ç›˜ï¼ˆå½¢çŠ¶å¯èƒ½æ˜¯ä¸è§„åˆ™çš„ï¼‰ä¸Šé¢æ‘†æ”¾æ£‹å­ï¼Œæ£‹å­æ²¡æœ‰åŒºåˆ«ã€‚è¦æ±‚æ‘†æ”¾æ—¶ä»»æ„çš„ä¸¤ä¸ªæ£‹å­ä¸èƒ½æ”¾åœ¨æ£‹ç›˜ä¸­çš„åŒä¸€è¡Œæˆ–è€…åŒä¸€åˆ—ï¼Œè¯·ç¼–ç¨‹æ±‚è§£å¯¹äºç»™å®šå½¢çŠ¶å’Œå¤§å°çš„æ£‹ç›˜ï¼Œæ‘†æ”¾kä¸ªæ£‹å­çš„æ‰€æœ‰å¯è¡Œçš„æ‘†æ”¾æ–¹æ¡ˆCã€‚ Inputè¾“å…¥å«æœ‰å¤šç»„æµ‹è¯•æ•°æ®ã€‚æ¯ç»„æ•°æ®çš„ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ­£æ•´æ•°ï¼Œn kï¼Œç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œè¡¨ç¤ºäº†å°†åœ¨ä¸€ä¸ªn*nçš„çŸ©é˜µå†…æè¿°æ£‹ç›˜ï¼Œä»¥åŠæ‘†æ”¾æ£‹å­çš„æ•°ç›®ã€‚ n &lt;= 8 , k &lt;= nå½“ä¸º-1 -1æ—¶è¡¨ç¤ºè¾“å…¥ç»“æŸã€‚éšåçš„nè¡Œæè¿°äº†æ£‹ç›˜çš„å½¢çŠ¶ï¼šæ¯è¡Œæœ‰nä¸ªå­—ç¬¦ï¼Œå…¶ä¸­ # è¡¨ç¤ºæ£‹ç›˜åŒºåŸŸï¼Œ . è¡¨ç¤ºç©ºç™½åŒºåŸŸï¼ˆæ•°æ®ä¿è¯ä¸å‡ºç°å¤šä½™çš„ç©ºç™½è¡Œæˆ–è€…ç©ºç™½åˆ—ï¼‰ã€‚ Outputå¯¹äºæ¯ä¸€ç»„æ•°æ®ï¼Œç»™å‡ºä¸€è¡Œè¾“å‡ºï¼Œè¾“å‡ºæ‘†æ”¾çš„æ–¹æ¡ˆæ•°ç›®C ï¼ˆæ•°æ®ä¿è¯C&lt;2^31ï¼‰ã€‚ Sample Input1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output1221 ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10;char g[N][N];bool rows[N], cols[N];int n, k, ans;void dfs(int x, int y, int s){ if (y == n) y = 0, x++; if (x == n) { if (s == k) ans++; return; } // ä¸é€‰ dfs(x, y + 1, s); // é€‰ if (!rows[x] &amp;&amp; !cols[y] &amp;&amp; g[x][y] == '#') { rows[x] = cols[y] = true; dfs(x, y + 1, s + 1); rows[x] = cols[y] = false; }}int main(){ while (scanf(\"%d%d\", &amp;n, &amp;k), n != -1 &amp;&amp;k != -1) { for (int i = 0; i &lt; n; i++) scanf(\"%s\", g[i]); dfs(0, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; memset(g, 0, sizeof(g)); ans = 0; } return 0;}","link":"/2019/12/07/æ£‹ç›˜é—®é¢˜/"},{"title":"æ»šåŠ¨æ•°ç»„","text":"ä¸€ç»´æ•°ç»„è€ç”Ÿå¸¸è°ˆçš„æ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚ 1 1 2 3 5 8 13 21 â€¦.ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥nï¼Œè¿”å›ç¬¬nä¸ªæ•°(n &lt;= 50)ã€‚(å®æµ‹å½“ n = 47 çˆ†int) 12345678910111213// ä¸ä½¿ç”¨æ»šåŠ¨æ•°ç»„LL fib(int n){ LL fibnacci[55]; fibnacci[0] = fibnacci[1] = 1; if (n == 0 || n == 1) return 1; for (int i = 2; i &lt;= n; i++) fibnacci[i] = fibnacci[i - 1] + fibnacci[i - 2]; return fibnacci[n];} 12345678910111213141516171819// ä½¿ç”¨æ»šåŠ¨æ•°ç»„// åœ¨æ±‚ç¬¬nä¸ªæ•°æ—¶ï¼Œåªç”¨åˆ°äº†å‰é¢ä¸¤ä¸ªå€¼ï¼Œæ‰€ä»¥åªéœ€å¼€ä¸€ä¸ªé•¿åº¦ä¸ºä¸‰çš„æ•°ç»„ã€‚LL fib(int n){ LL fibnacci[3]; fibnacci[0] = fibnacci[1] = 1; if (n == 0 || n == 1) return 1; while (n - 1) { n--; fibnacci[2] = fibnacci[0] + fibnacci[1]; fibnacci[0] = fibnacci[1]; fibnacci[1] = fibnacci[2]; } return fibnacci[2];} äºŒç»´æ•°ç»„é€’æ¨å…³ç³»f[i][j] = f[i - 1][j] + f[i - 1][j - x] (å…¶ä¸­ x &gt; 0) ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥aï¼Œbï¼Œè¾“å‡ºf[a][b]ã€‚(i, j &lt;= 50) 123456789101112131415161718// ä¸ä½¿ç”¨æ»šåŠ¨æ•°ç»„// ç¬¬0è¡Œä¸ç¬¬0åˆ—ä¸ºé€’æ¨çš„å‡ºå£int f[50][50], x = 2;void init(){ for (int i = 0; i &lt; 50; i++) f[0][i] = 1;}int func(int a, int b){ init(); for (int i = 1; i &lt;= a; i++) for (int j = 1; j &lt;= b; j++) if (j &gt;= x) f[i][j] = f[i - 1][j] + f[i - 1][j - x]; return f[a][b];} 123456789101112131415161718192021// ä½¿ç”¨æ»šåŠ¨æ•°ç»„// åœ¨æ±‚f[i][j]æ—¶åªç”¨åˆ°äº†å‰é¢ä¸€è¡Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„int f[2][50];void init(){ for(int i = 0; i &lt; 50; i++) f[0][i] = 1;}int func(int a, int b){ init(); for (int i = 1; i &lt;= a; i++) { for (int j = 0; j &lt; 50; j++) f[i % 2][j] = 0; // è¿™ä¸ªåœ°æ–¹å¾ˆé‡è¦ ä¸€å¼€å§‹æˆ‘æ²¡æœ‰æƒ³åˆ° æ‰“å°æ—¶æ‰å‘ç°é—®é¢˜ for (int j = 1; j &lt;= b; j++) if (j &gt;= x) f[i % 2][j] = f[1 - i % 2][j] + f[1 - i % 2][j - x]; // ç¬¬1è¡Œä½¿ç”¨ç¬¬0è¡Œï¼Œç¬¬0è¡Œä½¿ç”¨ç¬¬1è¡Œ } return f[a % 2][b];}","link":"/2019/12/15/æ»šåŠ¨æ•°ç»„/"},{"title":"ç”µè¯èŠå¤©ç‹‚äºº","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/*#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 400009, null = -1;LL h[N];int sum[N];int n, ans, cnt;LL ansNum[N];void insert(LL x){ int a = x % N; while (h[a] != null &amp;&amp; h[a] != x) { a++; if (a == N) a = 0; } sum[a]++; if (sum[a] == ans) ansNum[cnt++] = x; else if (sum[a] &gt; ans) { ans = sum[a]; if (ans == 0) ansNum[cnt++] = x; else { memset(ansNum, 0, sizeof(ansNum)); cnt = 0; ansNum[cnt++] = x; } } h[a] = x;}int main(){ memset(h, -1, sizeof(h)); cin &gt;&gt; n; while (n--) { LL from, to; scanf(\"%lld%lld\", &amp;from, &amp;to); insert(from), insert(to); } if (cnt == 1) printf(\"%lld %d\\n\", ansNum[0], ans); else { LL min = 1e12; for (int i = 0; i &lt; cnt; i++) if (ansNum[i] &lt; min) min = ansNum[i]; printf(\"%lld %d %d\", min, ans, cnt); } return 0;}*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; typedef struct ListNode *Position;typedef struct ListNode{ char PhoneNum[12]; int cnt; Position Next;} *List; typedef struct HashTbl{ int TableSize; List *TheLists;//å»ºç«‹ä¸€ä¸ªListNodeçš„æŒ‡é’ˆæ•°ç»„} *HashTable; int NextPrime(int x);HashTable InitializeTable(int TableSize);void DestroyTable(HashTable H);Position Find(char Key[], HashTable H);void Insert(char Key[], HashTable H);int Hash(int Key, int TableSize);void FindMax(HashTable H); int main(int argc, char const *argv[]){ // freopen(\"test.txt\", \"r\", stdin); int N; scanf(\"%d\", &amp;N); HashTable H = InitializeTable(2 * N); char send[12], rec[12]; for (int i = 0; i &lt; N; i++){ scanf(\"%s %s\\n\", send, rec); Insert(send, H), Insert(rec, H); } FindMax(H); DestroyTable(H); return 0;} int NextPrime(int x){ int i; for (int Next = x; ; Next++){ for (i = 2; i * i &lt;= Next; i++) if (Next % i == 0) break; if (i * i &gt; Next) return Next; }} HashTable InitializeTable(int TableSize){ HashTable H; H = (HashTable)malloc(sizeof(struct HashTbl)); H-&gt;TableSize = NextPrime(TableSize); H-&gt;TheLists = (List*)malloc(sizeof(List)*H-&gt;TableSize); for (int i = 0; i != H-&gt;TableSize; i++){ H-&gt;TheLists[i] = (List)malloc(sizeof(struct ListNode)); H-&gt;TheLists[i]-&gt;Next = NULL; } return H;} void DestroyTable(HashTable H){ for (int i = 0; i &lt; H-&gt;TableSize; i++) free(H-&gt;TheLists[i]); free(H-&gt;TheLists); free(H);} Position Find(char Key[], HashTable H){ Position P; List L; L = H-&gt;TheLists[Hash(atoi(Key + 6), H-&gt;TableSize)]; P = L-&gt;Next; while (P != NULL &amp;&amp; strcmp(P-&gt;PhoneNum, Key)) P = P-&gt;Next; return P;} void Insert(char Key[], HashTable H){ Position Pos, Tmp; List L = H-&gt;TheLists[Hash(atoi(Key + 6), H-&gt;TableSize)]; Pos = Find(Key, H); if (Pos == NULL){ Tmp = (List)malloc(sizeof(struct ListNode)); strcpy(Tmp-&gt;PhoneNum, Key); Tmp-&gt;cnt = 1; Tmp-&gt;Next = L-&gt;Next; L-&gt;Next = Tmp; } else { (Pos-&gt;cnt)++; }} int Hash(int Key, int TableSize){ return (Key % TableSize);} void FindMax(HashTable H){ Position P; int maxcnt = 0, maxSame = 1; char MinPhone[12]; for (int i = 0; i &lt; H-&gt;TableSize; i++){ P = H-&gt;TheLists[i]-&gt;Next; while (P != NULL){ if (P-&gt;cnt &gt; maxcnt){ strcpy(MinPhone, P-&gt;PhoneNum); maxcnt = P-&gt;cnt; maxSame = 1; } else if (P-&gt;cnt == maxcnt){ if (strcmp(MinPhone, P-&gt;PhoneNum) &gt; 0) strcpy(MinPhone, P-&gt;PhoneNum); maxSame++; } P = P-&gt;Next; } } printf(\"%s %d\", MinPhone, maxcnt); if (maxSame &gt; 1) printf(\" %d\", maxSame);}","link":"/2019/12/16/ç”µè¯èŠå¤©ç‹‚äºº/"},{"title":"ç”µå½±","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define N 200010using namespace std;map&lt;int,int&gt;s;int a[N];int b[N];struct zz{ int a; int b;}p[N];int main(){ int n,m,i,j,k; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); //sç”¨æ¥ç»Ÿè®¡a[i]çš„ä¸ªæ•° s[a[i]]++; } scanf(\"%d\",&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d\",&amp;p[i].a); for(i=1;i&lt;=m;i++) scanf(\"%d\",&amp;p[i].b); int mm=0;k=1; for(i=1;i&lt;=m;i++) { //ç»Ÿè®¡å‡ºç°æ¬¡æ•°æœ€å¤šçš„è¯­è¨€çš„ä¸ªæ•°,å¹¶è®°å½•å…¶åœ¨è¯­éŸ³åˆ—è¡¨ä¸­---ç¬¬ä¸€æ¬¡å‡ºç°-----çš„ä½ç½® if(mm&lt;s[p[i].a]) { mm=s[p[i].a]; k=i; } } //ç»Ÿè®¡ int kk=0; for(i=1;i&lt;=m;i++) { //åœ¨mmç›¸ç­‰çš„æƒ…å†µä¸‹ï¼Œæ¯”è¾ƒs[p[i].b]ã€‚è®°å½•s[p[i].b]æœ€å¤§çš„ä½ç½® if(s[p[i].a]==mm) { if(kk&lt;s[p[i].b]) { kk=s[p[i].b]; k=i; } } } printf(\"%d\\n\",k); return 0;}","link":"/2020/02/07/ç”µå½±/"},{"title":"ç¬¬Kä¸ªæ•°","text":"é¢˜ç›®é“¾æ¥ 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n, k;int quick_sort(int q[], int l, int r, int k){ if(l == r) return q[l]; int x = q[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while(i &lt; j) { while(q[++i] &lt; x) ; while(q[--j] &gt; x) ; if(i &lt; j) swap(q[i], q[j]); } int sl = j - l + 1; if(sl &gt;= k) return quick_sort(q, l, j, k); else return quick_sort(q, j + 1, r, k - sl);}int main(){ cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); cout &lt;&lt; quick_sort(q, 0, n-1, k); //quick_sortç›´æ¥è¿”å›ç¬¬Kä¸ªæ•° return 0;} asssdfdfsdfs sdfsfejdfdsdgsdg dg ff ffffff dgd dgdfgdf","link":"/2019/11/07/ç¬¬Kä¸ªæ•°/"},{"title":"ç­‰å·®æ•°åˆ—","text":"é¢˜ç›®é¢˜ç›®æè¿°æ•°å­¦è€å¸ˆç»™å°æ˜å‡ºäº†ä¸€é“ç­‰å·®æ•°åˆ—æ±‚å’Œçš„é¢˜ç›®ã€‚ ä½†æ˜¯ç²—å¿ƒçš„å°æ˜å¿˜è®°äº†ä¸€éƒ¨åˆ†çš„æ•°åˆ—ï¼Œåªè®°å¾—å…¶ä¸­$N$ä¸ªæ•´æ•°ã€‚ ç°åœ¨ç»™å‡ºè¿™$N$ä¸ªæ•´æ•°ï¼Œå°æ˜æƒ³çŸ¥é“åŒ…å«è¿™$N$ä¸ªæ•´æ•°çš„æœ€çŸ­çš„ç­‰å·®æ•°åˆ—æœ‰å‡ é¡¹ï¼Ÿ è¾“å…¥æ ¼å¼è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°$N$ã€‚ ç¬¬äºŒè¡ŒåŒ…å«$N$ä¸ªæ•´æ•°$A_1$,$A_2$,â‹…â‹…â‹…,$A_N$ã€‚(æ³¨æ„$A_1$âˆ¼$A_N$å¹¶ä¸ä¸€å®šæ˜¯æŒ‰ç­‰å·®æ•°åˆ—ä¸­çš„é¡ºåºç»™å‡º) è¾“å‡ºæ ¼å¼è¾“å‡ºä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚ æ•°æ®èŒƒå›´2\\le$N$\\le100000,0\\le$A_i$\\le10^9 è¾“å…¥æ ·ä¾‹ï¼š 52 6 4 10 20 è¾“å‡ºæ ·ä¾‹ï¼š 10 æ ·ä¾‹è§£é‡Š:åŒ…å« 2ã€6ã€4ã€10ã€20 çš„æœ€çŸ­çš„ç­‰å·®æ•°åˆ—æ˜¯ 2ã€4ã€6ã€8ã€10ã€12ã€14ã€16ã€18ã€20ã€‚ é¢˜ç›®é“¾æ¥ åˆ†æç­‰å·®æ•°åˆ—çš„ä»»æ„ä¸¤é¡¹ä¹‹å·®ä¸ºå…¬å·®çš„å€æ•°ã€‚($a_n-a_1=(n-1)d, n\\ge2$) æ‹¿æ ·ä¾‹æ¥è¯´ï¼Œ2, 6, 4, 10, 20ï¼Œæ’åºä¹‹åä¸º2, 4, 6, 10, 20ï¼Œä¸é¦–é¡¹çš„å·®ä¸º2, 4, 8, 18ã€‚ è¦ä½¿å¾—ç­‰å·®æ•°åˆ—æœ€çŸ­å°±è¦ä½¿å…¬å·®å°½å¯èƒ½çš„å¤§ï¼Œå°±æ˜¯è¦æ±‚å·®çš„æœ€å¤§å…¬çº¦æ•°ã€‚ nä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ä¸ºæ±‚å‰ä¸¤ä¸ªçš„gcdï¼Œå†ç”¨æ±‚å‡ºgcdä¸åé¢çš„æ•°ä¾æ¬¡æ±‚ã€‚è¯æ˜ï¼Ÿä¸ä¼šğŸ˜ ç­‰å·®æ•°åˆ—éœ€è¦æ³¨æ„å…¬å·®ä¸º0çš„æƒ…å†µ ç”¨åˆ°çš„çŸ¥è¯†1.ç­‰å·®æ•°åˆ—çš„é€šé¡¹å…¬å¼ï¼Œæ³¨æ„å…¬å·®ä¸º0çš„æƒ…å†µã€‚ 2.æ¬§å‡ é‡Œå¾—ç®—æ³•åˆç§°è¾—è½¬ç›¸é™¤æ³•ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int a[N];int ans;int gcd(int a, int b){ return b ? gcd(b, a % b) : a;}int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); sort(a, a + n); for (int i = 1; i &lt; n; i++) ans = gcd(ans, a[i] - a[0]); if (ans == 0) cout &lt;&lt; n &lt;&lt; endl; else cout &lt;&lt; (a[n - 1] - a[0]) / ans + 1&lt;&lt; endl; return 0;}","link":"/2020/02/10/ç­‰å·®æ•°åˆ—/"},{"title":"èƒŒåŒ…é—®é¢˜","text":"01èƒŒåŒ…é—®é¢˜ç»™å®šç‰©å“çš„æ•°é‡nï¼ˆæ¯ä¸€ç§ç‰©å“åªæœ‰ä¸€ä»¶ï¼‰ä»¥åŠæ¯ä»¶ç‰©å“çš„ä»·å€¼ï¼Œä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…ï¼Œé—®æ€æ ·è£…ç‰©å“ä½¿æ€»ä»·å€¼æœ€å¤§ã€‚ æœ´ç´ ç®—æ³•1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N]; // v ä»£è¡¨ä½“ç§¯ w ä»£è¡¨æƒé‡ yæ€»å†™çš„å’Œå…¶ä»–äººæ­£å¥½åç€ã€‚ å…¶ä»–äºº w ä»£è¡¨weight v ä»£è¡¨ value int f[N][N];int n, m;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;v[i], &amp;w[i]); for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (v[i] &lt;= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} ä¼˜åŒ–ä¼˜åŒ–ä¹‹å‰å…ˆçœ‹ä¸€ä¸‹æ»šåŠ¨æ•°ç»„ã€‚ä½¿ç”¨æ»šåŠ¨æ•°ç»„å¯ä»¥å¤§å¤§å‡å°‘ç©ºé—´å¤æ‚åº¦ã€‚ äºŒç»´å˜ä¸€ç»´ï¼Œæœ€ç»ˆä¼˜åŒ–ç»“æœï¼š 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m, f[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = m; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} å®Œå…¨èƒŒåŒ…é—®é¢˜ç»™å®šnç§ç‰©å“ï¼ˆæ¯ä¸€ç§ç‰©å“æœ‰æ— é™ä¸ªï¼‰ä»¥åŠæ¯ä¸€ç§ç‰©å“çš„ä»·å€¼ï¼Œä¸€ä¸ªå®¹é‡ä¸ºvçš„èƒŒåŒ…ï¼Œé—®æ€æ ·è£…ç‰©å“ä½¿ä»·å€¼æœ€å¤§ã€‚ æœ´ç´ ç®—æ³•1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) for (int k = 0; k * v[i] &lt;= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} ä¼˜åŒ–123456/* * f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, ....,f[i - 1][j - x * v] + x * w) * f[i][j - v] = max( f[i - 1][j - v] , f[i - 1][j - 2v] + w, .....,f[i - 1][j - x * v] + (x - 1) * w) * * f[i][j] = max(f[i - 1][j], f[i][j - v] + w); */ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} ä¼˜åŒ–æˆä¸€ç»´12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = v[i]; j &lt;= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} å¤šé‡èƒŒåŒ…é—®é¢˜æœ´ç´ ç®—æ³•","link":"/2019/12/06/èƒŒåŒ…é—®é¢˜/"},{"title":"ç³–æœä¼ é€’","text":"åˆ†æè¿‡ç¨‹123456789101112131415161718192021221-&gt;2-&gt;3-&gt;4-&gt;...-&gt;n-&gt;1 æ„æˆä¸€ä¸ªç¯x1 x2 x3 x4 .... xn xiè¡¨ç¤ºxiç»™xi+1ç³–æœçš„ä¸ªæ•°ï¼Œxiå¯æ­£å¯è´Ÿå¯ä¸ºé›¶ã€‚æœ¬é¢˜è¦æ±‚|x1|+|x2|+|x3|+.....+|xn|çš„æœ€å°å€¼ã€‚ é™åˆ¶æ¡ä»¶ï¼šæœ€åæ¯ä¸ªäººè·å¾—å‡ç­‰ç³–æœã€‚avè¡¨ç¤ºå¹³å‡å€¼ï¼Œaæ•°ç»„è¡¨ç¤ºæ¯ä¸ªäººåˆå§‹ç³–æœçš„æ•°é‡ã€‚a[1] - x1 + xn = av; a[1] - x1 + xn = av;a[2] - x2 + x1 = av; a[2] - x2 + x1 = av;a[3] - x3 + x2 = av; a[2] + a[3] - x3 + x1 = 2 * av;a[4] - x4 + x3 = av; . . ==========&gt; . ç­‰ä»·æˆcnã€‚ cn = cn-1 + an - av; (n &gt;= 2) . . ^ c1 = 0; . . | . . é€šé¡¹å…¬å¼ ----------------------a[n-1] - xn-1 + xn-2 = av; a[2] + ... + a[n - 1] - xn-1 + x1 = (n - 2) * av; | n |a[n] - xn + xn-1 = av; a[2] + ... + a[n] - xn + x1 = (n - 1) * av; =========&gt; xn = x1 +| âˆ‘ an - (n - 1) * av; | (n &gt;= 2) |n=2 | ----------------------ç»è¿‡ä¸Šé¢çš„ç­‰ä»·æ¨å¯¼ï¼Œæ‰€ä»¥ï¼š |x1|+|x2|+|x3|+.....+|xn| ==&gt; |x1 + c1|+|x1 + c2|+|x1 + c3|+.....+|xn + cn| åˆ°è¿™é‡Œå°±è½¬æ¢æˆAcWing 104.è´§ä»“é€‰å€è¿™é“é¢˜äº†ã€‚(é“¾æ¥åœ¨ä¸‹æ–¹) AcWing 104.è´§ä»“é€‰å€ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1000010;int n;LL a[N], c[N];LL sum, ans;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); sum += a[i]; } LL avg = sum / n; // å› ä¸ºé¢˜ç›®ä¿è¯æœ‰è§£ï¼Œå› æ­¤å¹³å‡æ•°å¿…ä¸ºæ•´æ•°ã€‚ c[1] = 0; for (int i = 2; i &lt;= n; i++) c[i] = c[i - 1] + a[i] - avg; sort(c + 1, c + 1 + n); int mid = c[(1 + n) / 2]; for (int i = 1; i &lt;= n; i++) ans += (LL)abs(mid - c[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2020/02/03/ç³–æœä¼ é€’/"},{"title":"è¿·å®«é—®é¢˜","text":"å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼š int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,}; å®ƒè¡¨ç¤ºä¸€ä¸ªè¿·å®«ï¼Œå…¶ä¸­çš„1è¡¨ç¤ºå¢™å£ï¼Œ0è¡¨ç¤ºå¯ä»¥èµ°çš„è·¯ï¼Œåªèƒ½æ¨ªç€èµ°æˆ–ç«–ç€èµ°ï¼Œä¸èƒ½æ–œç€èµ°ï¼Œè¦æ±‚ç¼–ç¨‹åºæ‰¾å‡ºä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„æœ€çŸ­è·¯çº¿ã€‚ Inputä¸€ä¸ª5 Ã— 5çš„äºŒç»´æ•°ç»„ï¼Œè¡¨ç¤ºä¸€ä¸ªè¿·å®«ã€‚æ•°æ®ä¿è¯æœ‰å”¯ä¸€è§£ã€‚ Outputå·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„æœ€çŸ­è·¯å¾„ï¼Œæ ¼å¼å¦‚æ ·ä¾‹æ‰€ç¤ºã€‚ Sample Input123450 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 Sample Output123456789(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4) ä»£ç c99ä¸­ä¸èƒ½{ x, y }è¦make_pair(x, y) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 10;int g[N][N];bool vis[N][N];PII pre[N][N];void bfs(){ queue&lt;PII&gt; q; q.push({ 0, 0 }); vis[0][0] = true; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; while (q.size()) { PII k = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int x = k.first + dx[i], y = k.second + dy[i]; if(x &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 5 &amp;&amp; g[x][y] == 0 &amp;&amp; !vis[x][y]) { vis[x][y] = true; pre[x][y] = k; q.push({ x, y }); } } }}int main(){ for (int i = 0; i &lt; 5; i++) for (int j = 0; j &lt; 5; j++) scanf(\"%d\", &amp;g[i][j]); bfs(); pre[0][0] = { -1, -1 }; stack&lt;PII&gt; s; s.push({ 4, 4 }); PII Pre = pre[4][4]; while (Pre.first != -1 &amp;&amp; Pre.second != -1) { s.push(Pre); Pre = pre[Pre.first][Pre.second]; } while (!s.empty()) { printf(\"(%d, %d)\\n\", s.top().first, s.top().second); s.pop(); } return 0;}","link":"/2019/12/09/è¿·å®«é—®é¢˜/"},{"title":"é€†åºå¯¹çš„æ•°é‡","text":"é¢˜ç›®é“¾æ¥ æš´åŠ› æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); int cnt = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { if (q[j] &gt; q[i]) cnt++; } } cout &lt;&lt; cnt; return 0;} å½’å¹¶ æ—¶é—´å¤æ‚åº¦ä¸ºO(nlogn)ï¼Œåˆå°è¯äº†é™ˆè¶Šå§¥å§¥çš„é‚£å¥è¯äº†ã€‚å½’å¹¶çš„æ€æƒ³ä¹Ÿæ˜¯åˆ†è€Œæ²»ä¹‹ã€‚é€’å½’ä¸èƒ½å¿˜äº†å†™é€’å½’å‡ºå£å•Šã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N], tmp[N];int n;long long res;void merge_sort(int q[], int l, int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else { res += mid - i + 1; tmp[k++] = q[j++]; } } while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); merge_sort(q, 0, n - 1); cout &lt;&lt; res; system(\"pause\"); return 0;}","link":"/2019/11/08/é€†åºå¯¹çš„æ•°é‡/"},{"title":"äºŒçº§æŒ‡é’ˆåšè¾“å…¥è¾“å‡º","text":"æœ¬æ–‡å°†ä»‹ç»äºŒçº§æŒ‡é’ˆåšå‡½æ•°è¾“å‡ºä»¥åŠåšå‡½æ•°è¾“å…¥çš„ä¸‰ç§å†…å­˜æ¨¡å‹ä»å†…å­˜å››åŒºçš„è§’åº¦å¯¹ç¨‹åºæ‰§è¡Œçš„è¿‡ç¨‹è¿›è¡Œå‰–æï¼Œé€šè¿‡è¿™ä¸­æ–¹å¼æ¥åŠ æ·±å¯¹æŒ‡é’ˆçš„ç†è§£ã€‚ äºŒçº§æŒ‡é’ˆåšè¾“å‡ºï¼ˆåœ¨è¢«è°ƒå‡½æ•°ä¸­åˆ†é…å†…å­˜ï¼‰æ¨¡å‹ï¼šä¸»å‡½æ•°ï¼š123456789int main(){ char *p = NULL; int len = 0; getMem(&amp;p, &amp;len); printf(\"p=%s\\n\", p); FreeMem(&amp;p); return 0;} getMemå‡½æ•°ï¼š12345678910111213int getMem(char **myp,int *mylen){ char *temp = NULL; temp = (char*)malloc(100); if (temp == NULL) { return -1; } strcpy(temp, \"abcdefg\"); *mylen = strlen(temp); *myp = temp; return 0;} çŠ¯çš„é”™è¯¯ï¼š*myp = temp; æœ€åˆå†™æˆäº†*myp = *temp; è€Œè¯¥è¡¨è¾¾å¼èµ‹å€¼ä¸¤ç«¯æ ¹æœ¬ä¸æ˜¯ä¸€ç§æ•°æ®ç±»å‹ã€‚ *myp = temp1; è¿™å¥è¯ä¸*mylen = æŸä¸€æ•°å€¼ æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯*åŠ ä¸ŠæŒ‡é’ˆå˜é‡æ¥æ”¹å˜ä¸»è°ƒç”¨å‡½æ•°ä¸­çš„å†…å®¹åªä¸è¿‡ï¼Œmypä¸ºäºŒçº§æŒ‡é’ˆå› æ­¤èµ‹å€¼çš„å³ç«¯åº”ä¸ºä¸€çº§æŒ‡é’ˆã€‚ è¡¥å……ï¼š &quot;abcdefg&quot;åœ¨å¸¸é‡åŒºä¸­ï¼Œstrcpy(temp, &quot;abcdefg&quot;); è¿™ä¸€å¥ä½¿å¾—tempæŒ‡å‘&quot;abcdefg&quot;ï¼Œå…¶å€¼ä¸ºå­—ç¬¦'a'çš„åœ°å€ã€‚ æ€»ç»“ï¼šæƒ³è¦åœ¨è¢«è°ƒç”¨å‡½æ•°ä¸­ä¿®æ”¹ä¸»è°ƒç”¨å‡½æ•°ä¸­çš„å€¼ï¼Œå¿…é¡»ä½¿ç”¨æŒ‡é’ˆï¼Œä¾‹å¦‚åœ¨getMemå‡½æ•°ä¸­ï¼Œä¿®æ”¹å˜é‡çš„å€¼ä½¿ç”¨ä¸€çº§æŒ‡é’ˆï¼Œä¿®æ”¹ä¸€çº§æŒ‡é’ˆéœ€è¦ç”¨åˆ°äºŒçº§æŒ‡é’ˆã€‚ FreeMemå‡½æ•°ï¼š1234567891011void FreeMem(char **myp){ if (myp == NULL) { return; } char *tmp = NULL; tmp = *myp; free(tmp); tmp = NULL;} 12345678void FreeMem(char *myp){ if(myp = NULL) { return ; } free(myp);} è¿™ä¸¤ç§FreeMemå‡½æ•°éƒ½å¯ä»¥é‡Šæ”¾pæŒ‡å‘çš„å†…å­˜ï¼Œä½†ç¬¬ä¸€ä¸ªå‡½æ•°çš„å¥½å¤„åœ¨äºä½¿ç”¨äº†äºŒçº§æŒ‡é’ˆï¼Œå¯åœ¨FreeMemå‡½æ•°ä¸­å°†ä¸»è°ƒç”¨å‡½æ•°ä¸­çš„pçš„å€¼æ”¹ä¸ºNULLé¿å… é‡æŒ‡é’ˆçš„å‡ºç°ï¼Œè€Œç¬¬äºŒä¸ªå‡½æ•°åˆ™è¦åœ¨FreeMemååŠ ä¸Šä¸€å¥p=NULLã€‚ è°ƒè¯•ç»“æœï¼š äºŒçº§æŒ‡é’ˆåšè¾“å…¥ï¼ˆåœ¨ä¸»è°ƒç”¨å‡½æ•°ä¸­åˆ†é…å†…å­˜ï¼‰æ¨¡å‹ä¸€ï¼šæŒ‡é’ˆæ•°ç»„ï¼š1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char *myArray[] = { \"xcccc\",\"ybbbb\",\"zaaaa\" }; int len = sizeof(myArray) / sizeof(myArray[0]); int i = 0; for (i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); //printf(\"%s\\n\", *(myArray+i)); æ•ˆæœç›¸åŒ } int j, k; j = k = 0; char *temp = NULL; for (j = 0; j &lt; len - 1; j++) { for (k = 0; k &lt; len - j - 1; k++) { if (strcmp(myArray[k], myArray[k + 1]) &gt; 0) { temp = myArray[k]; myArray[k] = myArray[k + 1]; myArray[k + 1] = temp; } } } for (i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); //printf(\"%s\\n\", *(myArray+i)); æ•ˆæœç›¸åŒ } return 0;} æ€»ç»“ï¼š1.åœ¨32ä½æ“ä½œç³»ç»Ÿä¸‹æŒ‡é’ˆå˜é‡çš„é•¿åº¦ä¸º4ï¼Œåœ¨64ä½ä¸‹ä¸º8ã€‚ 2.æŒ‡é’ˆæ•°ç»„ä¸ºå…ƒç´ ä¸ºæŒ‡é’ˆçš„æ•°ç»„ï¼ŒmyArrayæ•°ç»„ä¸­æœ‰ä¸‰ä¸ªå…ƒç´ ï¼Œsizeof(myArray) / sizeof(myArray[0])å¯ä»¥æ±‚å‡ºæ•°ç»„é•¿åº¦ã€‚ 3.æ’åºä½¿ç”¨çš„ä¸ºæœ€ç®€å•çš„å†’æ³¡æ’åºã€‚æ’åºè¿‡ç¨‹ä¸­äº¤æ¢çš„æ˜¯æŒ‡é’ˆè€Œä¸æ˜¯å†…å­˜å—ã€‚ äºŒçº§æŒ‡é’ˆåšè¾“å…¥æ¨¡å‹ä¸€å°è£…å‡½æ•°ï¼šä¸»å‡½æ•°ï¼š123456789101112int main(){ char *myArray[] = { \"zzz\",\"yyyyyyy\",\"xxxxxxxxx\" }; int len = sizeof(myArray) / sizeof(myArray[0]); printArray(myArray, len); SortArray(myArray, len); printArray(myArray, len); return 0;} æ‰“å°å‡½æ•°ï¼š1234567void printArray(char **myArray, int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} æ’åºå‡½æ•°ï¼š12345678910111213141516void SortArray(char **myArray, int len){ char *temp = NULL; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { temp = myArray[j]; myArray[j] = myArray[j + 1]; myArray[j + 1] = temp; } } }} æ€»ç»“ï¼šæ•°ç»„åœ¨åšå‡½æ•°å‚æ•°æ˜¯é€€åŒ–ä¸ºæŒ‡é’ˆï¼Œæ•°ç»„åæŒ‡å‘æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå³æ•°ç»„åä¸­å­˜æ”¾çš„æ˜¯æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€ã€‚æŒ‡é’ˆæ•°ç»„ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œchar *myArray[];ä¸­å®šä¹‰äº†ä¸€ä¸ªåä¸ºmyArrayçš„æŒ‡é’ˆæ•°ç»„ï¼Œæ ¹æ®ä¸Šé¢çš„è¯´æ˜ï¼ŒmyArrayä¸ºç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€ï¼Œè€Œæ•°ç»„å…ƒç´ ä¸ºæŒ‡å‘charç±»å‹çš„æŒ‡é’ˆï¼Œå³ä¸ºchar *ç±»å‹ï¼Œå› æ­¤myArrayä¸ºchar **ç±»å‹ï¼Œæ‰€ä»¥åœ¨å‡½æ•°ä¸­ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå‡ä¸ºchar **myArrayã€‚ äºŒçº§æŒ‡é’ˆåšè¾“å…¥ï¼ˆåœ¨ä¸»è°ƒç”¨å‡½æ•°ä¸­åˆ†é…å†…å­˜ï¼‰æ¨¡å‹äºŒï¼šäºŒç»´æ•°ç»„ï¼š123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char myArray[10][30] = { \"ddddd\",\"ccccc\",\"bbbbb\",\"aaaaa\" }; int num = 4; for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", myArray[i]); } char temp[30]; for (int i = 0; i &lt; num - 1; i++) { for (int j = 0; j &lt; num - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { strcpy(temp, myArray[j]); strcpy(myArray[j], myArray[j + 1]); strcpy(myArray[j + 1], temp); } } } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", myArray[i]); } return 0;} äºŒçº§æŒ‡é’ˆåšè¾“å…¥æ¨¡å‹äºŒå°è£…å‡½æ•°ï¼šä¸»å‡½æ•°ï¼š123456789int main(){ char myArray[10][30] = { \"ddddd\",\"ccccc\",\"bbbbb\",\"aaaaa\" }; int num = 4; printArray(myArray, num); SortArray(myArray, num); printArray(myArray, num); return 0;} æ‰“å°å‡½æ•°ï¼š1234567void printArray(char (*myArray)[30], int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} æ’åºå‡½æ•°ï¼š12345678910111213141516void SortArray(char (*myArray)[30], int len){ char temp[30]; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { strcpy(temp, myArray[j]); strcpy(myArray[j], myArray[j + 1]); strcpy(myArray[j + 1], temp); } } }} æ€»ç»“ï¼šäºŒç»´æ•°ç»„åœ¨åšå‡½æ•°å‚æ•°çš„æ—¶å€™ä¼šé€€åŒ–æˆä¸ºä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ã€‚ äºŒç»´æ•°ç»„ä¸­é‡è¦çš„ä¸¤ä¸ªç‚¹ï¼š 1.äºŒç»´æ•°ç»„åä¸ºç¬¬ä¸€ç»´é¦–å…ƒç´ çš„åœ°å€ã€‚ 2.ä¸€ç»´æ•°ç»„åä¸ºé¦–å…ƒç´ çš„åœ°å€ã€‚ æœ‰äº†è¿™ä¸¤ç‚¹ä¸‹é¢å°†æ¼”ç¤ºå¦‚ä½•ç”¨æ•°ç»„åæ‰“å°æŸä¸€ä¸ªå…ƒç´ ï¼š 1234567 ==&gt; è¡¨ç¤ºç­‰ä»·myArray ==&gt; &amp;myArray[0] //ä¸Šé¢çš„ç¬¬ä¸€ç‚¹ myArray + 2 ==&gt; &amp;myArray[2]*(myArray + 2) ==&gt; myArray[2] ==&gt; &amp;myArray[2][0] //ä¸Šé¢çš„ç¬¬äºŒç‚¹*(myArray + 2) + 1 ==&gt; &amp;myArray[2][1]*(myArray + 2) + 4 ==&gt; &amp;myArray[2][4]*(*(myArray + 2) + 4) ==&gt; myArray[2][4] äºŒçº§æŒ‡é’ˆåšè¾“å…¥ï¼ˆåœ¨ä¸»è°ƒç”¨å‡½æ•°ä¸­åˆ†é…å†…å­˜ï¼‰æ¨¡å‹ä¸‰ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char **p = NULL; int num = 4; p = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { p[i] = (char*)malloc(sizeof(char) * 100); sprintf(p[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", p[i]); } char *temp = NULL; for (int i = 0; i &lt; num - 1; i++) { for (int j = 0; j &lt; num - i - 1; j++) { if (strcmp(p[j], p[j + 1]) &gt; 0) { temp = p[j]; p[j] = p[j + 1]; p[j + 1] = temp; } } } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", p[i]); } for (int i = 0; i &lt; num; i++) { if (p[i] != NULL) { free(p[i]); p[i] = NULL; } } if (p != NULL) { free(p); p = NULL; } return 0;} äºŒçº§æŒ‡é’ˆåšè¾“å…¥æ¨¡å‹ä¸‰å°è£…å‡½æ•°ï¼šä¸»å‡½æ•°ï¼š123456789101112int main(){ int num = 4; char **p = NULL; //p = getMem(num); getMem_1(&amp;p, num); //ä¸¤ç§æ–¹å¼ printArray(p, num); SortArray(p, num); printArray(p, num); myArrayFree(p, num); return 0;} getMemå‡½æ•°:123456789101112131415161718192021222324252627char **getMem(int num){ char **p = NULL; p = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { p[i] = (char*)malloc(sizeof(char) * 100); sprintf(p[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } return p;}int getMem_1(char ***p, int num){ if (p == NULL) { return -1; } char **temp = NULL; temp = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { temp[i] = (char*)malloc(sizeof(char) * 100); sprintf(temp[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } *p = temp; return 0;} æ‰“å°å‡½æ•°ï¼š1234567void printArray(char **myArray, int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} æ’åºå‡½æ•°ï¼š12345678910111213141516void SortArray(char **myArray, int len){ char *temp = NULL; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { temp = myArray[j]; myArray[j] = myArray[j + 1]; myArray[j + 1] = temp; } } }} Freeå‡½æ•°ï¼š12345678910111213141516void myArrayFree(char **p,int len){ for (int i = 0; i &lt; len; i++) { if (p[i] != NULL) { free(p[i]); p[i] = NULL; } } if (p != NULL) { free(p); p = NULL; }}","link":"/2019/09/13/äºŒçº§æŒ‡é’ˆåšå‡½æ•°å‚æ•°/"},{"title":"æœ€çŸ­è·¯æ¨¡æ¿","text":"æœ€çŸ­è·¯é—®é¢˜ä¸­æœ‰å¾ˆå¤šçš„ç®—æ³•ï¼Œdijkstra bellman_ford spfa floydåˆå­¦çœŸçš„å¥½éš¾è®°ï¼ˆæ›´ä¸ç”¨è¯´å»çœ‹ç®—æ³•å¯¼è®ºçš„è¯¦ç»†è¯æ˜äº†ï¼‰ã€‚yæ€»ä¹Ÿæ€»ç»“äº†å¾ˆå¤šæ¨¡æ¿é“¾æ¥ï¼Œè‡ªå·±å†æ¥æ€»ç»“ä¸€ä¸‹åŠ æ·±è®°å¿†ã€‚å¦å¤–å®‰åˆ©yæ€»ç®—æ³•è¯¾ï¼Œè®²çš„çœŸçš„å¾ˆå¥½ï¼Œæˆ‘è§‰å¾—æ”¶è·å¾ˆå¤§ï¼Œè€Œä¸”ä»·æ ¼ä¹Ÿå¾ˆè‰¯å¿ƒğŸ˜‚ğŸ˜‚ã€‚ Dijkstraç®—æ³•æœ´ç´ ç‰ˆdijkstraé€‚åˆç¨ å¯†å›¾æ€è·¯1234é›†åˆSä¸ºå·²ç»ç¡®å®šæœ€çŸ­è·¯å¾„çš„ç‚¹é›†ã€‚1. åˆå§‹åŒ–è·ç¦»ä¸€å·ç»“ç‚¹çš„è·ç¦»ä¸ºé›¶ï¼Œå…¶ä»–ç»“ç‚¹çš„è·ç¦»è®¾ä¸ºæ— ç©·å¤§ï¼ˆçœ‹å…·ä½“çš„é¢˜ï¼‰ã€‚2. å¾ªç¯næ¬¡ï¼Œæ¯ä¸€æ¬¡å°†é›†åˆSä¹‹å¤–è·ç¦»æœ€çŸ­Xçš„ç‚¹åŠ å…¥åˆ°Sä¸­å»ï¼ˆè¿™é‡Œçš„è·ç¦»æœ€çŸ­æŒ‡çš„æ˜¯è·ç¦»1å·ç‚¹æœ€è¿‘ã€‚ç‚¹Xçš„è·¯å¾„ä¸€å®šæœ€çŸ­ï¼ŒåŸºäºè´ªå¿ƒï¼Œä¸¥æ ¼è¯æ˜å¾…çœ‹ï¼‰ã€‚ç„¶åç”¨ç‚¹Xæ›´æ–°Xé‚»æ¥ç‚¹çš„è·ç¦»ã€‚ æ—¶é—´å¤æ‚åº¦åˆ†æå¯»æ‰¾è·¯å¾„æœ€çŸ­çš„ç‚¹ï¼šO(n^2) åŠ å…¥é›†åˆSï¼šO(n) æ›´æ–°è·ç¦»ï¼šO(m) æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2) å…·ä½“é¢˜ç›®ç¨ å¯†å›¾ç”¨é‚»æ¥çŸ©é˜µå­˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 510, M = 10010;int g[N][N], dist[N];bool visited[N];int n, m;int dijkstra(){ memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 1; i &lt;= n; i++) { int t = -1; for(int j = 1; j &lt;= n; j++) { if(!visited[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } visited[t] = true; for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); memset(g, 0x3f, sizeof(g)); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); g[x][y] = min(g[x][y], c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;} å †ä¼˜åŒ–ç‰ˆdijkstraé€‚åˆç¨€ç–å›¾æ€è·¯123456å †ä¼˜åŒ–ç‰ˆçš„dijkstraæ˜¯å¯¹æœ´ç´ ç‰ˆdijkstraè¿›è¡Œäº†ä¼˜åŒ–ï¼Œåœ¨æœ´ç´ ç‰ˆdijkstraä¸­æ—¶é—´å¤æ‚åº¦æœ€é«˜çš„å¯»æ‰¾è·ç¦»æœ€çŸ­çš„ç‚¹O(n^2)å¯ä»¥ä½¿ç”¨æœ€å°å †ä¼˜åŒ–ã€‚1. ä¸€å·ç‚¹çš„è·ç¦»åˆå§‹åŒ–ä¸ºé›¶ï¼Œå…¶ä»–ç‚¹åˆå§‹åŒ–æˆæ— ç©·å¤§ã€‚2. å°†ä¸€å·ç‚¹æ”¾å…¥å †ä¸­ã€‚3. ä¸æ–­å¾ªç¯ï¼Œç›´åˆ°å †ç©ºã€‚æ¯ä¸€æ¬¡å¾ªç¯ä¸­æ‰§è¡Œçš„æ“ä½œä¸ºï¼š å¼¹å‡ºå †é¡¶ï¼ˆä¸æœ´ç´ ç‰ˆdiijkstraæ‰¾åˆ°Så¤–è·ç¦»æœ€çŸ­çš„ç‚¹ç›¸åŒï¼Œå¹¶æ ‡è®°è¯¥ç‚¹çš„æœ€çŸ­è·¯å¾„å·²ç»ç¡®å®šï¼‰ã€‚ ç”¨è¯¥ç‚¹æ›´æ–°ä¸´ç•Œç‚¹çš„è·ç¦»ï¼Œè‹¥æ›´æ–°æˆåŠŸå°±åŠ å…¥åˆ°å †ä¸­ã€‚ æ—¶é—´å¤æ‚åº¦åˆ†æå¯»æ‰¾è·¯å¾„æœ€çŸ­çš„ç‚¹ï¼šO(n) åŠ å…¥é›†åˆSï¼šO(n) æ›´æ–°è·ç¦»ï¼šO(mlogn) å…·ä½“é¢˜ç›®12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100010;// ç¨€ç–å›¾ç”¨é‚»æ¥è¡¨æ¥å­˜int h[N], e[N], ne[N], idx;int w[N]; // ç”¨æ¥å­˜æƒé‡int dist[N];bool st[N]; // å¦‚æœä¸ºtrueè¯´æ˜è¿™ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„å·²ç»ç¡®å®šint n, m;void add(int x, int y, int c){ w[idx] = c; // æœ‰é‡è¾¹ä¹Ÿä¸è¦ç´§ï¼Œå‡è®¾1-&gt;2æœ‰æƒé‡ä¸º2å’Œ3çš„è¾¹ï¼Œå†éå†åˆ°ç‚¹1çš„æ—¶å€™2å·ç‚¹çš„è·ç¦»ä¼šæ›´æ–°ä¸¤æ¬¡æ”¾å…¥å †ä¸­ e[idx] = y; // è¿™æ ·å †ä¸­ä¼šæœ‰å¾ˆå¤šå†—ä½™çš„ç‚¹ï¼Œä½†æ˜¯åœ¨å¼¹å‡ºçš„æ—¶å€™è¿˜æ˜¯ä¼šå¼¹å‡ºæœ€å°å€¼2+xï¼ˆxä¸ºä¹‹å‰ç¡®å®šçš„æœ€çŸ­è·¯å¾„ï¼‰ï¼Œå¹¶ ne[idx] = h[x]; // æ ‡è®°stä¸ºtrueï¼Œæ‰€ä»¥ä¸‹ä¸€æ¬¡å¼¹å‡º3+xä¼šcontinueä¸ä¼šå‘ä¸‹æ‰§è¡Œã€‚ h[x] = idx++;}int dijkstra(){ memset(dist, 0x3f, sizeof(dist)); dist[0] = 1; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // å®šä¹‰ä¸€ä¸ªå°æ ¹å † // è¿™é‡Œheapä¸­ä¸ºä»€ä¹ˆè¦å­˜pairå‘¢ï¼Œé¦–å…ˆå°æ ¹å †æ˜¯æ ¹æ®è·ç¦»æ¥æ’çš„ï¼Œæ‰€ä»¥æœ‰ä¸€ä¸ªå˜é‡è¦æ˜¯è·ç¦»ï¼Œå…¶æ¬¡åœ¨ä»å †ä¸­æ‹¿å‡ºæ¥çš„æ—¶ // å€™è¦çŸ¥é“çŸ¥é“è¿™ä¸ªç‚¹æ˜¯å“ªä¸ªç‚¹ï¼Œä¸ç„¶æ€ä¹ˆæ›´æ–°é‚»æ¥ç‚¹å‘¢ï¼Ÿæ‰€ä»¥ç¬¬äºŒä¸ªå˜é‡è¦å­˜ç‚¹ã€‚ heap.push({ 0, 1 }); // è¿™ä¸ªé¡ºåºä¸èƒ½å€’ï¼Œpairæ’åºæ—¶æ˜¯å…ˆæ ¹æ®firstï¼Œå†æ ¹æ®secondï¼Œè¿™é‡Œæ˜¾ç„¶è¦æ ¹æ®è·ç¦»æ’åº while(heap.size()) { PII k = heap.top(); // å–ä¸åœ¨é›†åˆSä¸­è·ç¦»æœ€çŸ­çš„ç‚¹ heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // iåªæ˜¯ä¸ªä¸‹æ ‡ï¼Œeä¸­åœ¨å­˜çš„æ˜¯iè¿™ä¸ªä¸‹æ ‡å¯¹åº”çš„ç‚¹ã€‚ if(dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n];}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;} Bellman_fordç®—æ³•Bellman_fordå¯ä»¥è§£å†³æœ‰è´Ÿæƒçš„å›¾ æ€è·¯12å¾ªç¯næ¬¡ï¼Œåœ¨æ¯ä¸€æ¬¡çš„å¾ªç¯å½“ä¸­ï¼Œéå†æ‰€æœ‰çš„è¾¹ a-&gt;b æƒé‡ä¸º w ï¼Œdist[b] = min(dist[b], dist[a] + w)ã€‚ä¸¥æ ¼è¯æ˜å¾…çœ‹å¾ªç¯çš„æ¬¡æ•°æ˜¯æœ‰å®é™…çš„æ„ä¹‰çš„ï¼Œå‡å¦‚å¾ªç¯kæ¬¡åˆ™ dist[x] ä»£è¡¨ç€ä»ä¸€å·ç‚¹ä¸è¶…è¿‡kæ¡è¾¹ï¼ˆ&lt;=kï¼‰çš„æœ€çŸ­è·ç¦»ã€‚ æ—¶é—´å¤æ‚åº¦åˆ†æå¾ªç¯næ¬¡ï¼Œæ¯ä¸€æ¬¡éå†mæ¡è¾¹ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸ºï¼šO(nm) å…·ä½“é¢˜ç›® å› ä¸ºè¿™é“é¢˜åœ¨æ¯ä¸€æ¬¡è¿­ä»£çš„è¿‡ç¨‹ä¸­éœ€è¦éå†æ‰€æœ‰çš„è¾¹ï¼Œæ‰€ä»¥yæ€»ç›´æ¥ç”¨çš„ç»“æ„ä½“æ•°ç»„å­˜çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 510, M = 10010;struct Edge{ int x, y, c;}edges[M];int dist[N], backup[N];int n, m, k;int bellman_ford(){ memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 0; i &lt; k; i++) { memcpy(backup, dist, sizeof(dist)); for(int j = 1; j &lt;= m; j++) { int x = edges[j].x, y = edges[j].y, c = edges[j].c; if(dist[y] &gt; backup[x] + c) dist[y] = backup[x] + c; } } if(dist[n] &gt; 0x3f3f3f3f / 2) return -1; // æç«¯æƒ…å†µ dist[n] = 10000*498; else return dist[n];}int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= m; i++) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); //edges[i] = {x, y, c}; c++11 edges[i].x = x; edges[i].y = y; edges[i].c = c; } int ret = bellman_ford(); if(ret == -1) puts(\"impossible\"); else cout &lt;&lt; ret &lt;&lt; endl; return 0;} spfaç®—æ³•æ€è·¯12345678spfaç®—æ³•å®é™…ä¸Šæ˜¯å¯¹bellman_fordç®—æ³•çš„ä¼˜åŒ–ã€‚åœ¨bellman_fordå½“ä¸­ä¼šå°†æ‰€æœ‰çš„è¾¹è¿›è¡Œæ¾å¼›æ“ä½œï¼Œä½†å…¶å®æ²¡æœ‰å¿…è¦ï¼Œå…¶å®åªéœ€ç”¨å·²ç»æ›´æ–°è¿‡è·ç¦»çš„ç‚¹å»æ›´æ–°å…¶ä»–çš„ç‚¹å°±å¥½äº†ã€‚1. åˆå§‹åŒ–è·ç¦»ä¸€å·ç‚¹è·ç¦»ä¸ºé›¶ï¼Œå…¶ä»–ç‚¹è®¾ä¸ºæ— ç©·å¤§2. å¾ªç¯å°†ä¸€å·ç‚¹åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­;while(é˜Ÿåˆ—ä¸ç©º) å–ç‚¹;å¼¹å‡º;æ›´æ–°; æ—¶é—´å¤æ‚åº¦æœ€å¥½ï¼šO(m) æœ€åï¼šO(nm) å…·ä½“é¢˜ç›®123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 100010, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], idx;int w[N];int dist[N];bool st[N];int n, m;void add(int x, int y, int c){ e[idx] = y; w[idx] = c; ne[idx] = h[x]; h[x] = idx++;}int spfa(){ queue&lt;int&gt; q; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push(1); st[1] = true; while(q.size()) { int k = q.front(); q.pop(); st[k] = false; for(int i = h[k]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] &gt; dist[k] + w[i]) { dist[j] = dist[k] + w[i]; if(!st[j]) { st[j] = true; q.push(j); } } } } return dist[n];}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } int t = spfa(); if(t == INF) puts(\"impossible\"); else cout &lt;&lt; t; return 0;} spfaåˆ¤æ–­è´Ÿç¯æ€è·¯12","link":"/2019/11/24/æœ€çŸ­è·¯æ¨¡æ¿/"}],"tags":[{"name":"POJ","slug":"POJ","link":"/tags/POJ/"},{"name":"æœç´¢","slug":"æœç´¢","link":"/tags/æœç´¢/"},{"name":"æ•°è®º","slug":"æ•°è®º","link":"/tags/æ•°è®º/"},{"name":"è“æ¡¥æ¯","slug":"è“æ¡¥æ¯","link":"/tags/è“æ¡¥æ¯/"},{"name":"æ€»ç»“","slug":"æ€»ç»“","link":"/tags/æ€»ç»“/"},{"name":"æ’åº","slug":"æ’åº","link":"/tags/æ’åº/"},{"name":"AcWingç®—æ³•æ¨¡æ¿","slug":"AcWingç®—æ³•æ¨¡æ¿","link":"/tags/AcWingç®—æ³•æ¨¡æ¿/"},{"name":"å“ˆå¸Œ","slug":"å“ˆå¸Œ","link":"/tags/å“ˆå¸Œ/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"AcWingç®—æ³•é¢˜","slug":"AcWingç®—æ³•é¢˜","link":"/tags/AcWingç®—æ³•é¢˜/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","link":"/tags/è´ªå¿ƒ/"}],"categories":[{"name":"æµ™å¤§æ•°æ®ç»“æ„","slug":"æµ™å¤§æ•°æ®ç»“æ„","link":"/categories/æµ™å¤§æ•°æ®ç»“æ„/"},{"name":"ä¼ æ™ºæ’­å®¢æ‰«åœ°åƒ§c/c++å­¦ä¹ ç¬”è®°","slug":"ä¼ æ™ºæ’­å®¢æ‰«åœ°åƒ§c-c-å­¦ä¹ ç¬”è®°","link":"/categories/ä¼ æ™ºæ’­å®¢æ‰«åœ°åƒ§c-c-å­¦ä¹ ç¬”è®°/"},{"name":"PTA","slug":"PTA","link":"/categories/PTA/"},{"name":"POJ","slug":"POJ","link":"/categories/POJ/"},{"name":"AcWingè“æ¡¥æ¯","slug":"AcWingè“æ¡¥æ¯","link":"/categories/AcWingè“æ¡¥æ¯/"},{"name":"æ€»ç»“","slug":"æ€»ç»“","link":"/categories/æ€»ç»“/"},{"name":"AcWingåŸºç¡€è¯¾","slug":"AcWingåŸºç¡€è¯¾","link":"/categories/AcWingåŸºç¡€è¯¾/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","link":"/categories/æ•°æ®ç»“æ„/"},{"name":"bugè®°å½•","slug":"bugè®°å½•","link":"/categories/bugè®°å½•/"},{"name":"æ•°è®º","slug":"AcWingè“æ¡¥æ¯/æ•°è®º","link":"/categories/AcWingè“æ¡¥æ¯/æ•°è®º/"}]}