{"pages":[{"title":"about","text":"自动化专业大三学生，算法初学者，希望以后能进入互联网行业……","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"03-树2 List Leaves","text":"这道题花费了我四个小时，但是很开心一次AC，记录一下。花这么长时间的主要原因是，在第一次想的时候在构造树的结点的时候，没有加入结点的下标，导致后面越做越麻烦，好在及时修改，只花了4个小时😁😁。 题目描述Given a tree, you are supposed to list all the leaves in the order of top down, and left to right. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space. Output Specification:For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input:12345678981 -- -0 -2 7- -- -5 -4 6 Sample Output:14 1 5 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define Null -1#define MAXSIZE 10typedef struct BiTNode{ int lchild; int rchild; int index;}BiTNode;typedef BiTNode QElemType;typedef struct SqQueue{ QElemType Data[MAXSIZE]; int front; int rear;}SqQueue;int CreateBiTree(vector&lt;BiTNode&gt; &amp;v, int n, int &amp;leaves);void InitQueue(SqQueue &amp;Q);void AddQueue(SqQueue &amp;Q, BiTNode e);void DeleteQueue(SqQueue &amp;Q);bool QueueEmpty(SqQueue Q);bool QueueFull(SqQueue Q);int main(){ int n; cin &gt;&gt; n; int root; vector&lt;BiTNode&gt; v; int leaves = 0; root = CreateBiTree(v, n, leaves); SqQueue Q; InitQueue(Q); AddQueue(Q, v[root]); int cnt = 0; while (!QueueEmpty(Q)) { if (Q.Data[Q.front].lchild == Null &amp;&amp; Q.Data[Q.front].rchild == Null) { cnt++; if (cnt == leaves) cout &lt;&lt; Q.Data[Q.front].index; else cout &lt;&lt; Q.Data[Q.front].index &lt;&lt; \" \"; } int t = Q.Data[Q.front].index; DeleteQueue(Q); if (v[t].lchild != Null) AddQueue(Q, v[v[t].lchild]); if (v[t].rchild != Null) AddQueue(Q, v[v[t].rchild]); } return 0;}int CreateBiTree(vector&lt;BiTNode&gt; &amp;v, int n, int &amp;leaves){ char l, r; BiTNode tmp; vector&lt;int&gt; arr(n, 1); for (int i = 0; i &lt; n; i++) { tmp.index = i; cin &gt;&gt; l &gt;&gt; r; if (l == '-') tmp.lchild = Null; else { tmp.lchild = l - '0'; arr[tmp.lchild] = 0; } if (r == '-') tmp.rchild = Null; else { tmp.rchild = r - '0'; arr[tmp.rchild] = 0; } if (tmp.lchild == Null &amp;&amp; tmp.rchild == Null) leaves++; v.push_back(tmp); } int i = 0; for (; i &lt; n; i++) { if (arr[i] != 0) break; } return i;}void InitQueue(SqQueue &amp;Q){ Q.front = 0; Q.rear = 0;}void AddQueue(SqQueue &amp;Q, BiTNode e){ if (!QueueFull(Q)) { Q.Data[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXSIZE; }}void DeleteQueue(SqQueue &amp;Q){ if (!QueueEmpty(Q)) { Q.front = (Q.front + 1) % MAXSIZE; }}bool QueueEmpty(SqQueue Q){ if (Q.front == Q.rear) return true; return false;}bool QueueFull(SqQueue Q){ if ((Q.front + MAXSIZE - Q.rear) % MAXSIZE == 1) return true; return false;}","link":"/posts/20191002a1.html"},{"title":"Cpp中数组类的实现以及操作符的重载","text":"Cpp中数组类的实现以及操作符的重载。。 Array.h12345678910111213141516171819202122#pragma onceclass Array{public: int mLength; int* mSpace;public: Array(int length); Array(const Array&amp; obj); int&amp; operator[](int i); Array&amp; operator=(Array &amp;obj); bool operator==(Array &amp;obj); bool operator!=(Array &amp;obj); int length(); void setData(int index, int value); int getData(int index); ~Array();}; main.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int main(){ //定义一个Array类型的啊对象并调用Array类的有参构造函数 Array a1(10); //对数组的元素进行初始化 for (int i = 0; i &lt; a1.length(); i++) { //a1.setData(i, i); //初步 a1[i] = i; //提升 []重载 } //对数组的元素进行输出 for (int i = 0; i &lt; a1.length(); i++) { //printf(\"array %d: %d\\n\", i, a1.getData(i)); //初步 cout &lt;&lt; a1[i]; } cout &lt;&lt; a1; // &lt;&lt;重载 //用a1对象初始化a2对象，调用a2对象的拷贝构造函数 //总结1 Array a2 = a1; for (int i = 0; i &lt; a2.length(); i++) { //printf(\"array %d: %d\\n\", i, a2.getData(i)); cout &lt;&lt; a1[i]; } Array a3(5); a3 = a1; //c++编译器提供的等号操作符为浅拷贝需重载 = //总结2 cout &lt;&lt; \"a3:\" &lt;&lt; a3; if (a1 == a3) { cout &lt;&lt; \"相等\" &lt;&lt; endl; } else { cout &lt;&lt; \"不相等\" &lt;&lt; endl; } if (a1 != a3) { cout &lt;&lt; \"不相等\" &lt;&lt; endl; } else { cout &lt;&lt; \"相等\" &lt;&lt; endl; } return 0;} 重载&lt;&lt;函数123456789ostream&amp; operator&lt;&lt;(ostream &amp;out, Array &amp;obj){ for (int i = 0; i &lt; obj.length(); i++) { //out &lt;&lt; obj.mSpace[i] &lt;&lt; \" \"; out &lt;&lt; obj[i] &lt;&lt; \" \"; } return out;} 成员函数实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Array::Array(int length){ mLength = length; mSpace = new int[mLength];}Array::Array(const Array&amp; obj){ mLength = obj.mLength; mSpace = new int [mLength]; for (int i = 0; i &lt; mLength; i++) { mSpace[i] = obj.mSpace[i]; }}int Array::length(){ return mLength;}void Array::setData(int index, int value){ mSpace[index] = value;}int Array::getData(int index){ return mSpace[index];}Array::~Array(){ delete[] mSpace; mSpace = NULL; mLength = 0; }int&amp; Array::operator[](int i){ return this-&gt;mSpace[i];}Array&amp; Array::operator=(Array &amp;obj){ delete[] this-&gt;mSpace; this-&gt;mLength = 0; this-&gt;mLength = obj.mLength; this-&gt;mSpace = new int[mLength]; for (int i = 0; i &lt; mLength; i++) { mSpace[i] = obj[i]; } return *this;}bool Array::operator==(Array &amp;obj){ if (this-&gt;mLength != obj.mLength) { return false; } for (int i = 0; i &lt; mLength; i++) { if (mSpace[i] != obj[i]) { return false; } } return true;}bool Array::operator!=(Array &amp;obj){ return !(*this == obj);} 总结：拷贝构造函数的四种调用方法：1.Array a1(a2); 2.Array a1 = a2; 3.函数调用过程中，例如：main函数中调用f函数f(a1);，其中a1为Array类型的一个对象，f函数的声明为void f(Array a);这时函数的调用过程中会调用a对象的拷贝构造函数。 4.被调用函数的返回值是一个对象的时候，这时c++编译器会创建一个匿名对象，然后调用匿名对象的拷贝构造函数。而这个匿名对象的生命周期取决于主调用函数的接法，如果是类的初始化那么匿名对象转正，直到程序运行完成时才会调用析构函数，若是类的赋值，则在赋值完以后立马调用匿名对象的析构函数。 重载&lt;&lt;C++Primer第六页中说，&lt;&lt;运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象（也就是说cout是一个ostream类型的对象），右侧的运算对象是要打印的值。 使用过程中我们的输出语句可以使用多次&lt;&lt;运算符，因此&lt;&lt;运算符返回其左侧的运算对象（即ostream类型），这样才能保证第一次的运算结果能作为第二次&lt;&lt;运算符的左侧运算对象。有了这个前提之后我们在写&lt;&lt;运算符重载函数的时候，函数应返回本身（即返回一个引用），因此函数的声明应为ostream&amp; operator&lt;&lt;(ostream &amp;out, Array &amp;obj)。 运算符重载函数可以为全局函数也可以为成员函数，大部分情况下二者可以相互转换，以二元运算符为例，全局函数需要两个参数，左操作数与右操作数，而成员函数可通过this指针“隐藏”一个参数。但也有例外，在重载&lt;&lt;时必须使用成员函数，因为我们不能进入到ostream类中写成员函数。","link":"/posts/20190924a1.html"},{"title":"Cpp类的基础练习：商店货物","text":"某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;using namespace std;class Goods{private: int weight; static int total_weight;public: Goods *pNext; Goods(int weight) { this-&gt;weight = weight; total_weight += weight; } //使用delete释放内存时会调用析构函数 ~Goods() { total_weight -= weight; } int GetWeight() { return weight; } static int GetTotalWeight() { return total_weight; }};int Goods::total_weight = 0;void menu(){ cout &lt;&lt; \"============================\" &lt;&lt; endl; cout &lt;&lt; \" 商店货物系统\" &lt;&lt; endl; cout &lt;&lt; \" 输入1购进\" &lt;&lt; endl; cout &lt;&lt; \" 输入2卖出\" &lt;&lt; endl; cout &lt;&lt; \" 输入0退出\" &lt;&lt; endl; cout &lt;&lt; \"============================\" &lt;&lt; endl;}//某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，//商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。void Purchase(Goods * &amp;Head, Goods * &amp;Tail,int weight){ Goods *pNew = new Goods(weight);//这个时候会调用pNew这个指针变量指向的对象的构造函数啊 pNew-&gt;pNext = NULL; if (Head == NULL &amp;&amp; Tail == NULL) { Head = Tail = pNew; } else { Tail-&gt;pNext = pNew; Tail = pNew; }}void Sale(Goods * &amp;Head){ if (Head == NULL) { cout &lt;&lt; \"没有货物!\" &lt;&lt; endl; return; } Goods *Temp = Head-&gt;pNext; delete Head; Head = Temp;}int main(){ Goods *Head = NULL; Goods *Tail = NULL; int choice = -1; int weight = 0; do { menu(); cin &gt;&gt; choice; //scanf(\"%d\", &amp;choice); ? ? ? switch (choice) { case 1: { cout &lt;&lt; \"请输入重量:\"; cin &gt;&gt; weight; Purchase(Head, Tail, weight); break; } case 2: { Sale(Head); break; } case 0:exit(0); break; default:cout &lt;&lt; \"输入错误,请重新输入!\" &lt;&lt; endl; break; } cout &lt;&lt; \"总重量为:\" &lt;&lt; Goods::GetTotalWeight() &lt;&lt; endl &lt;&lt; endl; } while (1); return 0;}","link":"/posts/20190920a1.html"},{"title":"Dungeon Master","text":"You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an escape possible? If yes, how long will it take? InputThe input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C. OutputEach maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the line Trapped! Sample Input123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample Output12Escaped in 11 minute(s).Trapped! 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 110, inf = 1044266559;int L, R, C;char map[N][N][N];int dist[N][N][N];typedef struct point{ int z, x, y;}points;points st, ed;int main(){ memset(dist, -0x3f, sizeof dist); int dx[6] = {0, 0, -1, 0, 1, 0}; int dy[6] = {0, 0, 0, 1, 0, -1}; int dz[6] = {-1, 1, 0, 0, 0, 0}; while (scanf(\"%d%d%d\", &amp;L, &amp;R, &amp;C), L || R || C) { getchar(); for (int i = 1; i &lt;= L; i++) for (int j = 1; j &lt;= R; j++) scanf(\"%s\", map[i][j]); for (int i = 1; i &lt;= L; i++) for (int j = 1; j &lt;= R; j++) for (int k = 0; k &lt; C; k++) { if (map[i][j][k] == 'S') st.z = i, st.x = j, st.y = k; if (map[i][j][k] == 'E') ed.z = i, ed.x = j, ed.y = k; } dist[st.z][st.x][st.y] = 0; bool success = false; int ans = 0; queue&lt;points&gt; q; q.push(st); while (q.size()) { points t = q.front(); q.pop(); for (int i = 0; i &lt; 6; i++) { int a = t.z + dz[i], b = t.x + dx[i], c = t.y + dy[i]; if (a &gt;= 1 &amp;&amp; a &lt;= L &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= R &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; C &amp;&amp; map[a][b][c] != '#' &amp;&amp; dist[a][b][c] == -inf) { q.push({a, b, c}); dist[a][b][c] = dist[t.z][t.x][t.y] + 1; if (map[a][b][c] == 'E') { success = true; ans = dist[a][b][c]; break; } } } } if (success) printf(\"Escaped in %d minute(s).\\n\", ans); else printf(\"Trapped!\\n\"); memset(dist, -0x3f, sizeof dist); } return 0;}","link":"/posts/20191209a2.html"},{"title":"LeetCode 1360.日期之间隔几天","text":"自己写只能说写的太繁琐了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: bool leap_year(int year){ if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) return true; return false; } int month[2][13] = { {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} }; void get_date(string date, int &amp;year, int &amp;month, int &amp;day){ sscanf(date.c_str(), \"%d-%d-%d\", &amp;year, &amp;month, &amp;day); } int get_num(int y, int m, int d){ return y * 10000 + m * 100 + d; } int daysBetweenDates(string date1, string date2) { int y1, m1, d1, y2, m2, d2; get_date(date1, y1, m1, d1); get_date(date2, y2, m2, d2); if (get_num(y1, m1, d1) &gt; get_num(y2, m2, d2)){ swap(y1, y2); swap(m1, m2); swap(d1, d2); } int ans = 0; for (int i = y1 + 1; i &lt; y2; i++) if (leap_year(i)) ans += 366; else ans += 365; if (y1 == y2){ bool leap = leap_year(y1); if (m1 == m2) ans += d2 - d1; else{ ans += month[leap][m1] - d1; for (int i = m1 + 1; i &lt; m2; i++) ans += month[leap][i]; ans += d2; } }else{ bool leap = leap_year(y1); for (int i = 12; i &gt;= m1; i--) if (i &gt; m1) ans += month[leap][i]; else ans += month[leap][i] - d1; leap = leap_year(y2); for (int i = 1; i &lt;= m2; i++){ if (i &lt; m2) ans += month[leap][i]; else ans += d2; } } return ans; }}; y总12345678910111213141516171819202122232425262728class Solution {public: int daysBetweenDates(string date1, string date2) { return abs(get_sum(date1) - get_sum(date2)); } int month[2][13] = { {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} }; bool leap_year(int year){ return year % 4 == 0 &amp;&amp; year % 100 || year % 400 == 0; } int get_sum(string date){ int y, m, d; sscanf(date.c_str(), \"%d-%d-%d\", &amp;y, &amp;m, &amp;d); int res = 0; for (int i = 1971; i &lt; y; i++){ if (leap_year(i)) res += 366; else res += 365; } bool leap = leap_year(y); for (int i = 1; i &lt; m; i++){ res += month[leap][i]; } res += d; return res; }}; 参考y总代码链接还有视频讲解哦！","link":"/posts/20200306a1.html"},{"title":"LeetCode 1361.验证二叉树","text":"分析 若是二叉树应该满足下面3个条件：1.有且仅有一个根节点(入度为0)。2.其他的节点的入度均为1。3.所有的节点均在一棵树上(其实这个就相当于条件1了)。 c++代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution {public: bool validateBinaryTreeNodes(int n, vector&lt;int&gt;&amp; leftChild, vector&lt;int&gt;&amp; rightChild) { vector&lt;int&gt; indegree(n, 0); for (int i = 0; i &lt; n; i++){ if (leftChild[i] != -1) indegree[leftChild[i]]++; if (rightChild[i] != -1) indegree[rightChild[i]]++; } int root = -1; // 要明确的是跳出这个循环有两种可能性：1.找到root 2.遍历完所有的点 for (int i = 0; i &lt; n; i++){ if (indegree[i] == 0){ root = i; break; } } if (root == -1) return false; //cout &lt;&lt; \"root:\" &lt;&lt; root &lt;&lt; endl; vector&lt;bool&gt; vis(n, false); queue&lt;int&gt; q; q.push(root); vis[root] = true; while (q.size()){ int t = q.front(); q.pop(); if (leftChild[t] != -1){ if (vis[leftChild[t]]) return false; else{ q.push(leftChild[t]); vis[leftChild[t]] = true; } } if (rightChild[t] != -1){ if (vis[rightChild[t]]) return false; else{ q.push(rightChild[t]); vis[rightChild[t]] = true; } } } //cout &lt;&lt; \"here\" &lt;&lt; endl; for (int i = 0; i &lt; n; i++){ if (!vis[i]) { //cout &lt;&lt; i &lt;&lt; endl; return false; } } return true; }};","link":"/posts/20200306a2.html"},{"title":"PTA数据结构与算法题目集(中文)6-5","text":"本题为无头结点的链表操作集","link":"/posts/20191001a1.html"},{"title":"LeetCode 5.最长回文子串","text":"算法一：动态规划时间复杂度：O($n^2$)状态个数：$\\frac{(n+1)n}{2}$状态转移：4 分析闫氏Dp分析法: f[i][j]表示所有i~j的回文串的集合的最大值。 集合划分： 1.包含i，j两个点。包含i，j两点首先要满足s[i] == s[j]并且i+1~j-1也要是个回文串（否则会出现这种情况abca显然不是回文串）。所以f[i][j] = f[i + 1][j - 1] + 2。2.包含i，不包含j。首先要明确f[i][j - 1]与这种情况不完全相等，包含i，不包含j的集合是f[i][j - 1]的子集，但由于要求最大值，所以在集合划分的时候可以有交集。3.不包含i，包含j。同2f[i + 1][j]。4.i，j两点均不包含。f[i + 1][j - 1]。 C++代码123456789101112131415161718192021222324class Solution {public: string longestPalindrome(string s) { int n = s.size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(n)); int maxLength = 1, begin = 0; for (int len = 1; len &lt;= n; len++) for (int l = 0; l + len - 1 &lt; n; l++){ int r = l + len - 1; if (len == 1) f[l][r] = 1; else{ if (s[l] == s[r] &amp;&amp; f[l + 1][r - 1] == (r - l - 1)) f[l][r] = f[l + 1][r - 1] + 2; f[l][r] = max(f[l][r], f[l + 1][r - 1]); f[l][r] = max(f[l][r], f[l][r - 1]); f[l][r] = max(f[l][r], f[l + 1][r]); if (f[l][r] &gt; maxLength){ maxLength = f[l][r]; begin = l; } } } return s.substr(begin, maxLength); }};","link":"/posts/20200320a1.html"},{"title":"X的因子链","text":"题目题目链接 题目描述输入正整数$X$，求$X$的大于$1$的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，以及满足最大长度的序列的个数。 输入格式输入包含多组数据，每组数据占一行，包含一个正整数表示$X$。 输出格式对于每组数据，输出序列的最大长度以及满足最大长度的序列的个数。 每个结果占一行。 数据范围$1 \\le X \\le 2^{20}$ 输入样例： 23410100 输出样例： 1 11 12 12 24 6 分析算数基本定理：任何一个大于$1$的自然数$N$,如果$N$不为质数，那么$N$可以唯一分解成有限个质数的乘积$N=P_1^{a_1}P_2^{a_2}P_3^{a_3}……P_n^{a_n}$，这里$P1&lt;P2&lt;P3……&lt;Pn$均为质数，其中指数$a_i$是正整数。 后一项能整除前一项，即后一项为前一项乘任意一个质因子$P_i$。最大长度由分解质因数可得，即$maxLength=\\sum\\limits_{n=1}^na_n$。 本题还问到了满足最长序列的个数，即求所有质因子的全排列，但由于其中有重复的元素，所以转换成多冲击组合数问题。（多重集组合数：一共有$k$种物品，每一种有$n_i$个，$1\\le i\\le k$，总共有$n$个物品，则$n$个物品的全排列为$\\frac{n!}{n_1!n_2!n_3!…n_k!}$） 用到的知识1.算数基本定理以及质因数分解 2.多重集组合数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = (1 &lt;&lt; 20) + 10;int x;int fact[30], sum[30];LL f(int n){ LL res = 1; for (int i = 1; i &lt;= n; i++) res *= i; return res;}int main(){ while (scanf(\"%d\", &amp;x) != EOF) { int k = 0; for (int i = 2; i &lt;= x / i; i++) { if (x % i == 0) fact[++k] = i; while (x % i == 0) { sum[k]++; x /= i; } } if (x != 1) fact[++k] = x, sum[k]++; int tot = 0; for (int i = 1; i &lt;= k; i++) tot += sum[i]; LL res = f(tot); for (int i = 1; i &lt;= k; i++) res /= f(sum[i]); cout &lt;&lt; tot &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl; memset(sum, 0, sizeof(sum)); } return 0;}","link":"/posts/20200210a1.html"},{"title":"stringstream sscanf sprintf","text":"stringstream123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;sstream&gt;using namespace std;// 从一行输入中扣数字int main(){ int a[10]; string line; getline(cin, line); // 12 32 4 44 56 88888 4 stringstream ssin(line); int cnt = 0; while (ssin &gt;&gt; a[cnt++]) ; for (int i = 0; i &lt; cnt - 1; i++) printf(\"%d \", a[i]); return 0;} sscanf12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;// 从特定的序列中扣数// 例如 23:16:36int main(){ string line; getline(cin, line); int h, m, s; sscanf(line.c_str(), \"%d:%d:%d\", &amp;h, &amp;m, &amp;s); printf(\"%d %d %d\", h, m, s); return 0;} sprintf1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;// 按照固定格式转化为字符串int main(){ //string str; 不知道为啥 str.c_str() 不能用 char str[128]; int h = 23, m = 1, s = 26; sprintf(str, \"%02d:%02d:%02d\", h, m, s); cout &lt;&lt; str &lt;&lt; endl; return 0;}","link":"/posts/20200222a2.html"},{"title":"六度空间","text":"“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图所示。 “六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。 假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。 输入格式:输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤103，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。 输出格式:对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。 输入样例:1234567891010 91 22 33 44 55 66 77 88 99 10 输出样例：123456789101: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00% AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1010;int G[N][N], n, m;bool visited[N];int SDS(int i){ int cnt = 0; int level = 0, last = i, tail = -1; queue&lt;int&gt; q; visited[i] = true; q.push(i); cnt++; while (!q.empty()) { int k = q.front(); q.pop(); for (int j = 1; j &lt;= n; j++) { if (j == k) continue; if (!visited[j] &amp;&amp; G[k][j]) { q.push(j); tail = j; visited[j] = true; cnt++; } } if (k == last) { level++; last = tail; } if (level == 6) break; } return cnt;}int main(){ cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); G[a][b] = 1; G[b][a] = 1; } for (int i = 1; i &lt;= n; i++) { int ret = SDS(i); printf(\"%d: %.2f\", i, (double)ret / n * 100); puts(\"%\"); memset(visited, false, sizeof(visited)); } return 0;}","link":"/posts/20191116a2.html"},{"title":"匈牙利算法","text":"匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。美国数学家哈罗德·库恩于1955年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家Dénes Kőnig和Jenő Egerváry的工作之上创建起来的。 —————百度百科 思路12 时间复杂夫具体题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, M = 100010;int n1, n2, m, res;int h[N], e[M], ne[M], idx;int match[N]; // 配对bool st[N];void add(int x, int y){ e[idx] = y; ne[idx] = h[x]; h[x] = idx++;}bool find(int x){ for(int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if(!st[j]) { st[j] = true; if(!match[j] || find(match[j])) { match[j] = x; return true; } } } return false;}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d%d\", &amp;n1, &amp;n2, &amp;m); while (m--) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); } for(int i = 1; i &lt;= n1; i++) { memset(st, false, sizeof(st)); if(find(i)) res++; } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/posts/20191127a1.html"},{"title":"刷题总结1","text":"刷题总结第一篇。 乒乓球题目链接 很简单的一道题，但是从细节中也能看出很大的差距。 自己的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main(){ string s; string str; s += 'e'; bool flag = true; while(flag) { cin &gt;&gt; str; for(int i = 0; i &lt; str.size(); i++) { s += str[i]; if(str[i] == 'E') { flag = false; break; } } } int win = 0, lose = 0; for(int i = 1; i &lt; s.size() + 1; i++) { if(s[i] == 'W') win++; else if(s[i] == 'L') lose++; else ; int a = max(lose, win); int b = min(lose, win); if((a == 11 &amp;&amp; b &lt;= 9) || (b &gt;= 10 &amp;&amp; a &gt;= b + 2) || s[i] == 'E') { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } puts(\"\"); win = 0, lose = 0; for(int i = 1; i &lt; s.size() + 1; i++) { if(s[i] == 'W') win++; else if(s[i] == 'L') lose++; else ; int a = max(lose, win); int b = min(lose, win); if((a == 21 &amp;&amp; b &lt;= 19) || (b &gt;= 20 &amp;&amp; a &gt;= b + 2) || s[i] == 'E') { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } return 0;} y总的代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;void solve(string s, int score){ int win = 0, lose = 0; for(int i = 0; i &lt; s.size(); i++) { if(s[i] == 'W') win++; else lose++; if (max(win, lose) &gt;= score &amp;&amp; abs(win - lose) &gt;= 2) { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } printf(\"%d:%d\\n\", win, lose);}int main(){ string s; char c; while(cin &gt;&gt; c, c != 'E') s += c; solve(s, 11); puts(\"\"); solve(s, 21); return 0;} 总结while(cin &gt;&gt; c, c != 'E') s += c;这句话挺好的，以后可用。清晰的思路：遍历每一个字符，按照条件给某个变量++，直到这局结束，结束的条件，达到分制且分差大于2。 公交换乘简单的模拟题。 题目链接 自己的代码没写出来。。。 y总的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 100010;struct Point{ int price, time; bool used;}q[N];int n, res;int main(){ scanf(\"%d\", &amp;n); int Type, Price, Time; int hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { scanf(\"%d%d%d\", &amp;Type, &amp;Price, &amp;Time); if(Type == 0) { res += Price; ++tt; q[tt].price = Price, q[tt].time = Time; } else { while(hh &lt;= tt &amp;&amp; Time - q[hh].time &gt; 45) hh++; bool success = false; for(int j = hh; j &lt;= tt; j++) { if(!q[j].used &amp;&amp; q[j].price &gt;= Price) { q[j].used = true; success = true; break; } } if(!success) res += Price; } } cout &lt;&lt; res &lt;&lt; endl; return 0;} 总结删掉某个结点不一定真的要删掉，可以开一个bool数组在对应的位置上标记。清晰的思路：要算总的花费，只有两种情况，要么坐地铁，要么坐公交。地铁一定会花钱，公交看有没有优惠券，能使用优惠券的条件：1.时间间隔小于等于45分钟，这个时候就应该想到滑动窗口。2.优惠券大于公交票钱。如有多张能用的优惠券用早的，想到队列。","link":"/posts/20191130a1.html"},{"title":"单例模式","text":"单例模式所谓类的单例设计模式，就是采取一定的方法保证在整个的系统软件中，对某个类只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法。如果我们要让一个类在一个虚拟机中只能产生一个对象，我们首先必须将累的构造器的访问权限设置为private，这样就不能通过new操作符在类的外部产生类的对象了，但在类的内部仍然可以产生该类的对象。因为在诶的外部开始还无法得到类的对象，只能通过调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问静态成员变量，所以指向类内部产生的该类对象的变量也必须定义成静态的。 Java实现饿汉式123456789class Singleton { private Singleton() { } private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; }} 懒汉式123456789101112class Singleton { private Singleton() { } private static Singleton instance = null; public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 对比饿汉式： 缺点：对象加载时间过长。优点：饿汉式是线程安全的。 懒汉式： 优点：延迟对象的创建缺点：该写法线程不安全，以后在改进。 单例模式的应用场景1.网站的计数器，一般也是单例模式实现，否则难以同步。 2.应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 3.数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 4.项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。 5.Application 也是单例的典型应用 6.Windows的Task Manager (任务管理器)就是很典型的单例模式 7.Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例 参考宋红康Java核心基础","link":"/posts/20200318a1.html"},{"title":"四平方和","text":"题目题目链接","link":"/posts/20200221a1.html"},{"title":"各种排序算法","text":"各种排序算法的总结 规定一个统一的接口: 123456template &lt;typename T&gt;void xxxx_sort(T *arr, int l, int r){ /* * 函数具体实现 */} 时间复杂度：O(n^2)冒泡排序123456789101112template &lt;typename T&gt;void bubble_sort(T *arr, int l, int r){ for (int i = r - 1; i &gt;= l; i--){ bool Swap = false; for (int j = l; j &lt;= i; j++) if (arr[j] &gt; arr[j + 1]){ swap(arr[j], arr[j + 1]); Swap = true; } if (!Swap) break; }} 插入排序1234template &lt;typename T&gt;void insert_sort(T *arr, int l, int r){ } 选择排序12 时间复杂度：O(nlogn)快速排序1234567891011121314151617181920template &lt;typename T&gt;void quick_sort(T *arr, int l, int r){ if (l &gt;= r) return; int x = arr[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while (i &lt; j){ while (arr[++i] &lt; x) ; while (arr[--j] &gt; x) ; if (i &lt; j) swap(arr[i], arr[j]); } quick_sort&lt;int&gt;(arr, l, j); quick_sort&lt;int&gt;(arr, j + 1, r);} 归并排序123456789101112131415161718192021222324252627282930template &lt;typename T&gt;void merge_sort(T *arr, int l, int r){ T *tmp = new T[r - l + 1]; m_sort&lt;int&gt;(arr, tmp, l, r); delete tmp;}template &lt;typename T&gt;void m_sort(T *arr, T *tmp, int l ,int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; m_sort&lt;T&gt;(arr, tmp, l, mid); m_sort&lt;T&gt;(arr, tmp, mid + 1, r); int k = l; int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r){ if (arr[i] &lt;= arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while (i &lt;= mid) tmp[k++] = arr[i++]; while (j &lt;= r) tmp[k++] = arr[j++]; for (int i = l; i &lt;= r; i++) arr[i] = tmp[i];}","link":"/posts/20191217a1.html"},{"title":"合唱队型","text":"题目题目链接 在最长上升子序列问题中，朴素做法（这道题数据范围较小朴素算法也能过）中记录的是f[i]中的i是最大值的位置，这道题可以记录拐点的位置，左右分别为LIS问题，一个从左往右，一个从右往左。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n;int a[N];int f[N], g[N];int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { f[i] = 1; for (int j = 1; j &lt; i; j++) if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1); } for (int i = n; i &gt;= 1; i--) { g[i] = 1; for (int j = n; j &gt; i; j--) if (a[j] &lt; a[i]) g[i] = max(g[i], g[j] + 1); } int ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, f[i] + g[i] - 1); cout &lt;&lt; n - ans &lt;&lt; endl; return 0;}","link":"/posts/20200219a1.html"},{"title":"外卖店优先级","text":"题目题目链接 分析拿到题目之后，首先想想暴力的做法，暴力的做法按照时间枚举，在某个时间点上枚举所有的外卖店若是有订单优先级就加上cnt(订单的数量) * 2，否则就减去1，再按照优先级的数值判断是否在优先缓存中。枚举完所有时间以后，再看T时刻的优先缓存中的外卖店的数量。这种暴力的时间复杂度我写的代码是$O(N * T + M * T)$，显然是会超时的。 然后再想怎么优化，再按照时间枚举的过程中，其实对于某个店铺来说在很多时间上是没有订单的，比如说t1到t2时刻中i店铺没有订单，则t2时刻的优先级应该为：max(0, score[i] - (t2 - t1 - 1)) + 2，这样就避免了枚举中间没有订单的时间点。 C++代码暴力枚举 $O(N * T + M * T)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define x first#define y secondtypedef pair&lt;int, int&gt; PII;const int N = 100010;int n, m, T;PII orders[N];int score[N];bool st[N];bool f[N];int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;T); for (int i = 0; i &lt; m; i++) scanf(\"%d%d\", &amp;orders[i].x, &amp;orders[i].y); for (int i = 1; i &lt;= T; i++) { for (int j = 0; j &lt; m; j++) { int id = orders[j].y, t = orders[j].x; if (t == i) { f[id] = true; score[id] += 2; if (score[id] &gt; 5) st[id] = true; } } for (int j = 1; j &lt;= n; j++) if (!f[j]) { score[j]--; score[j] = max(score[j], 0); if (score[j] &lt;= 3) st[j] = false; } memset(f, false, sizeof(f)); } int res = 0; for (int i = 1; i &lt;= n; i++) if (st[i]) res++; printf(\"%d\", res); return 0;} 优化 $O(M)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define x first#define y secondtypedef pair&lt;int, int&gt; PII;const int N = 100010;int n, m, T;int score[N], last[N];bool st[N];PII orders[N];int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;T); for (int i = 0; i &lt; m; i++) scanf(\"%d%d\", &amp;orders[i].x, &amp;orders[i].y); sort(orders, orders + m); for (int i = 0; i &lt; m; ) { int j = i; while (j &lt; m &amp;&amp; orders[j] == orders[i]) j++; int id = orders[i].y, t = orders[i].x, cnt = j - i; i = j; score[id] -= t - last[id] - 1; score[id] = max(0, score[id]); if (score[id] &lt;= 3) st[id] = false; score[id] += 2 * cnt; if (score[id] &gt; 5) st[id] = true; last[id] = t; } for (int i = 1; i &lt;= n; i++) { if (last[i] &lt; T) { score[i] -= T - last[i]; if (score[i] &lt;= 3) st[i] = false; } } int res = 0; for (int i = 1; i &lt;= n; i++) if (st[i]) res++; printf(\"%d\", res); return 0;} 参考AcWing","link":"/posts/20200311a1.html"},{"title":"多线程","text":"","link":"/posts/20200324a1.html"},{"title":"归并排序","text":"题目链接 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N], tmp[N];int n;void merge_sort(int q[], int l, int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; } while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];}int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); merge_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0;}","link":"/posts/20191108a3.html"},{"title":"循环队列的操作","text":"​ 为充分利用向量空间，克服假溢出现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10#define ERROR 1#define OK 0typedef int Status;typedef int QueueElemType;typedef enum { false, true } bool;typedef struct{ QueueElemType *data; int front; int rear;}SqQueue;Status InitQueue(SqQueue **pQ);Status DestoryQueue(SqQueue *Q);Status ClearQueue(SqQueue *Q);bool QueueEmpty(SqQueue *Q);bool QueueFull(SqQueue *Q);Status GetHead(SqQueue *Q, QueueElemType *e);Status EnQueue(SqQueue *Q, QueueElemType e);Status DeQueue(SqQueue *Q, QueueElemType *e);void PrintALLQueue(SqQueue *Q);void PrintQueue(SqQueue *Q);int main() { int status = -1; SqQueue *Q = NULL; status = InitQueue(&amp;Q); if (status == ERROR) { printf(\"func InitQueue() error!\\n\"); } PrintALLQueue(Q); PrintQueue(Q); int choice = -1; int e = 0; while (1) { printf(\"1 添加 2 删除 0 退出\\n\"); scanf(\"%d\", &amp;choice); switch (choice) { case 1: printf(\"Please enter e:\"); scanf(\"%d\", &amp;e); status = EnQueue(Q, e); if (status == ERROR) { printf(\"FULL!\\n\"); } PrintALLQueue(Q); PrintQueue(Q); break; case 2: status = DeQueue(Q, &amp;e); if (status == ERROR) { printf(\"EMPTY!\\n\"); } else printf(\"The number is %d.\\n\", e); PrintALLQueue(Q); PrintQueue(Q); break; case 0:exit(0); } } DestoryQueue(Q); Q = NULL; return 0;}Status InitQueue(SqQueue **pQ){ SqQueue *Q; Q = (SqQueue*)malloc(sizeof(SqQueue)); if(Q == NULL) { printf(\"分配内存失败!\\n\"); return ERROR; } Q-&gt;data = (QueueElemType*)malloc(MAXSIZE * sizeof(QueueElemType)); if (Q-&gt;data == NULL) { printf(\"分配内存失败!\\n\"); return ERROR; } Q-&gt;front = 0; Q-&gt;rear = 0; *pQ = Q; return OK;} Status DestoryQueue(SqQueue *Q){ if (Q-&gt;data != NULL) { free(Q-&gt;data); Q-&gt;data = NULL; return OK; } else return ERROR;}Status ClearQueue(SqQueue *Q){ Q-&gt;front = 0; Q-&gt;rear = 0; return OK;}bool QueueEmpty(SqQueue *Q){ if (Q-&gt;front == Q-&gt;rear) return true; else return false;}bool QueueFull(SqQueue *Q){ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) return true; else return false;}Status GetHead(SqQueue *Q, QueueElemType *e){ if (QueueEmpty(Q) == true) { return ERROR; } else *e = Q-&gt;data[Q-&gt;front]; return OK;}Status EnQueue(SqQueue *Q, QueueElemType e){ if (QueueFull(Q) == true) return ERROR; Q-&gt;data[Q-&gt;rear] = e; Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; return OK;}Status DeQueue(SqQueue *Q, QueueElemType *e){ if (QueueEmpty(Q) == true) { return ERROR; } *e = Q-&gt;data[Q-&gt;front]; Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; return OK;}Status QueueLength(SqQueue *Q, int *length){ *length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE; return OK;}void PrintALLQueue(SqQueue *Q){ for (int i = 0; i &lt; MAXSIZE; i++) { printf(\"%d \", Q-&gt;data[i]); } putchar('\\n');}void PrintQueue(SqQueue *Q){ int status = -1; int length = 0; QueueLength(Q, &amp;length); for (int i = 0; i &lt; length; i++) { printf(\"%d \", (Q-&gt;data[(Q-&gt;front + i) % MAXSIZE])); } putchar('\\n');}","link":"/posts/20190922a1.html"},{"title":"快速排序","text":"题目链接 快速排序的模板： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 1e5;int q[N];int n;void quick_sort(int q[], int l, int r){ if(l &gt;= r) return; int x = q[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while(i &lt; j) { while(q[++i] &lt; x) ; while(q[--j] &gt; x) ; if(i &lt; j) swap(q[i], q[j]); } quick_sort(q, l ,j); quick_sort(q, j + 1, r);}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); quick_sort(q, 0, n - 1); for(int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0;}","link":"/posts/20191028a1.html"},{"title":"bug记录","text":"本文将记录以后遇到的bug及解决的方法（因为我觉得这个东西很有必要写，有的时候就简单的一个地方就要debug好久😭😭） CRT detected that the application wrote to memory after end of heap buffer我服了看了这么长时间竟然是数组越界，我从下标1开始了。😂 Stack overflow递归时没有写递归出口。 result_pointer!=nullptrscanf &amp;&amp;&amp;&amp;&amp;&amp; if else写了这么多的if else没想到居然还会再这种地方出现问题😱。写成了： 1234if(true) if(true) func();else if(true) func1(); 呆呆呆呆 二维字符数组的初始化定义了一个全局的二维数组g[5][5]。 在函数中初始化时写成了g[5][5] = .......","link":"/posts/20191006a1.html"},{"title":"拯救007","text":"Saving James Bond - Easy Version This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape. Input Specification:Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position. Output Specification:For each test case, print in a line “Yes” if James can escape, or “No” if not. Sample Input 1:12345678910111213141514 2025 -15-25 288 4929 15-35 -25 2827 -29-8 -28-20 -35-25 -20-13 29-30 15-35 4012 12 Sample Output 1:1Yes Sample Input 2:123454 13-12 1212 12-12 -1212 -12 Sample Output 2:1No AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100;PII vertex[N];bool visited[N], flag;int n, D;bool isSafe(PII v){ if (v.first == 0 &amp;&amp; v.second == 0) return D &gt; 50 - 7.5; return D &gt;= 50 - abs(v.first) || D &gt;= 50 - abs(v.second);}double distance(PII a, PII b) { return sqrt((a.first-b.first)*(a.first - b.first)+(a.second-b.second)*(a.second - b.second));}bool canJump(PII a, PII b){ if (a.first == 0 &amp;&amp; a.second == 0) return D + 7.5 &gt;= distance(a, b); else return D &gt;= distance(a, b);}bool DFS(PII v){ if (isSafe(v)) return true; for (int i = 0; i &lt; n; i++) { if (!visited[i] &amp;&amp; canJump(v, vertex[i])) { visited[i] = true; // return DFS(vertex[i]); flag = DFS(vertex[i]); if (flag) return true; } } return false;}int main(){ cin &gt;&gt; n &gt;&gt; D; for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;vertex[i].first, &amp;vertex[i].second); if (DFS({ 0, 0 })) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; system(\"pause\"); return 0;}","link":"/posts/20191116a1.html"},{"title":"数的范围","text":"题目链接 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); while (m--) { int x; scanf(\"%d\", &amp;x); int l = 0, r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (q[mid] &gt;= x) r = mid; else l = mid + 1; } if (q[l] != x) cout &lt;&lt; \"-1 -1\" &lt;&lt; endl; else { cout &lt;&lt; l &lt;&lt; \" \"; l = 0, r = n - 1; while (l &lt; r) { int mid = l + r + 1&gt;&gt; 1; if (q[mid] &lt;= x) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; } } return 0;}","link":"/posts/20191108a1.html"},{"title":"数组指针类型与函数指针类型","text":"由于数组类型与函数类型的定义方法很类似，因此放到一起。 数组指针数组类型的定义12345678910typedef int (myArrayType)[10];int main(){ int a[10]; myArrayType b;//等价于int b[10]; a[0] = 1; b[0] = 1; cout &lt;&lt; a[0] &lt;&lt; \" \" &lt;&lt; b[0] &lt;&lt; endl; return 0;} 输出结果： 数组指针类型的定义12345678910typedef int(*myPArrayType)[10];int main(){ int a[10]; a[0] = 1; myPArrayType p; p = &amp;a; cout &lt;&lt; (*p)[0] &lt;&lt; endl; return 0;} 输出结果： myPArrayType是数组的地址，而a是数组首元素的地址，因此myPArrayType相当于一个二级指针。 说到数组指针就不得不提一下指针数组，初学指针与数组时很容易混淆这两个概念，但其实也很好理解。数组指针可以念成数组的指针，也就是说本质上是一个指针，只是该指针指向的是一个数组罢了，也就是上面这个例子。而指针数组又可以念成指针的数组，顾名思义本质上是一个数组，只不过数组的元素是指针。 另外值得注意的是a+1与&amp;a+1完全不同，指针+1的步长取决于指针所指的数据类型，a指的是int类型因此向后移动四个字节，而&amp;a指向的是一个数组因此向后移动四十个字节。 函数指针通过函数类型定义函数指针123456789typedef int (myFuncType)(int);int main(){ int a = 5; myFuncType *Func; Func = &amp;add; cout &lt;&lt; Func(a) &lt;&lt; endl; return 0;} 输出结果： 直接定义函数指针类型12345678910typedef int (*myPFuncType)(int);int main(){ int a = 5; myPFuncType Func; //Func = &amp;add; //加不加取地址号都可以 为什么呢？？？？？？ Func = add; cout &lt;&lt; Func(a) &lt;&lt; endl; return 0;} 输出结果：","link":"/posts/20191002a1.html"},{"title":"数论模板","text":"欧几里得算法（辗转相除法）证明欧几里得算法的核心为，将(a, b)（代表a与b的最大公约数）转化成(b, a % b)。 已知：若d能整除a且d能整除b，则d能整除a+b、a-b，也能整除ax+by。 证明(a, b) &lt;==&gt; (b, a % b)，需证明前面任意的公约数为后面的公约数，后面任意的公约数为前面的公约数。 a % b &lt;==&gt; a - a / b * b &lt;==&gt; a - c * b （c为常数） 所以(a, b) &lt;==&gt; (b, a - c * b)，由前面的条件，显然正确。 c++代码1234int gcd(int a, int b);{ return b ? gcd(b, a % b) : a;}","link":"/posts/20200222a1.html"},{"title":"数组模板类(MyVector)","text":"实现非常简单的数组模板类（MyVector）中用到了泛型编程（模板类编程）、运算符重载、友元函数等知识，最重要的是加深了对内存分配的理解。 所有容器提供的都是值（value）语意，而非引用（reference）语意。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（必须提供拷贝构造函数）。 开始的时候不理解这句话，然后自己敲代码就理解了。我们在往容器里存数据的时候，是进行拷贝动作，也就是说将外部变量的值拷贝给容器中的值。要进行拷贝就必须分配内存，没有分配内存的话往哪拷数据呢？？？？而基础数据类型的变量是不用担心这些问题的，因为当我们写下int a时编译器已经为a分配了内存，但是如果是指针变量就必须考虑深拷贝与浅拷贝的问题（其实这个地方第一次的时候我想的是，MyVector不是已经分配了内存了吗，为什么还要分配呢？其实在MyVector中是给类分配了内存说白了就是给类中的成员变量分配了内存，而成员变量若有指针的话，它只是为指针分配了内存，而我们所需要的是分配指针所指向的内存空间分配内存）。 MyVector.h12345678910111213141516171819#pragma once#include&lt;iostream&gt;using namespace std;template &lt;typename Type&gt;class MyVector{ friend ostream&amp; operator&lt;&lt; &lt;Type&gt; (ostream &amp;out, const MyVector &amp;obj); //在泛型编程当中，类模板中避免使用友元函数，除了重载 \"&lt;&lt;\" \"&gt;&gt;\" 左移右移运输算符，其他的函数都写成成 //员函数public: MyVector(int len); MyVector(const MyVector &amp;obj); ~MyVector();public: MyVector&amp; operator=(const MyVector &amp;obj); Type&amp; operator[](int index);private: Type *mSpace; int len;}; MyVector.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;#include\"MyVector.h\"template &lt;typename Type&gt;MyVector&lt;Type&gt;::MyVector(int len){ this-&gt;len = len; mSpace = new Type[len];}template &lt;typename Type&gt;MyVector&lt;Type&gt;::MyVector(const MyVector &amp;obj){ this-&gt;len = obj.len; mSpace = new Type[len]; for (int i = 0; i &lt; len; i++) { mSpace[i] = obj.mSpace[i]; }}template &lt;typename Type&gt;MyVector&lt;Type&gt;::~MyVector(){ if (mSpace != NULL) { delete[] mSpace; mSpace = NULL; len = 0; }}template &lt;typename Type&gt;MyVector&lt;Type&gt;&amp; MyVector&lt;Type&gt;::operator=(const MyVector&lt;Type&gt; &amp;obj){ if (mSpace != NULL) { delete[] mSpace; mSpace = NULL; len = 0; } this-&gt;len = obj.len; mSpace = new Type[len]; for (int i = 0; i &lt; len; i++) { mSpace[i] = obj.mSpace[i]; } return *this;}template &lt;typename Type&gt;Type&amp; MyVector&lt;Type&gt;::operator[](int index){ return mSpace[index];}template &lt;typename Type&gt;ostream&amp; operator&lt;&lt;(ostream &amp;out, const MyVector&lt;Type&gt; &amp;obj){ for (int i = 0; i &lt; obj.len; i++) { cout &lt;&lt; obj.mSpace[i]; } cout &lt;&lt; endl; return out;} main.cpp测试int型 123456789101112int main(){ MyVector&lt;int&gt; arr1(10); for (int i = 0; i &lt; 10; i++) { arr1[i] = i + 1; } cout &lt;&lt; arr1 &lt;&lt; endl; MyVector&lt;int&gt; arr2 = arr1; cout &lt;&lt; arr2 &lt;&lt; endl; return 0;} 测试char 型 123456789101112int main02(){ MyVector&lt;char&gt; str1(10); for (int i = 0; i &lt; 10; i++) { str1[i] = 'a' + i; } cout &lt;&lt; str1 &lt;&lt; endl; MyVector&lt;char&gt; str2 = str1; cout &lt;&lt; str2 &lt;&lt; endl; return 0;} 测试Teacher类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//Teacher类中名字是字符数组，即在栈上分配内存。class Teacher{ friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Teacher &amp;obj);public: Teacher() { age = 0; strcpy(name, \"\"); } Teacher(const char *name,int age) { strcpy(this-&gt;name, name); this-&gt;age = age; } void printT() { cout &lt;&lt; \"name:\" &lt;&lt; name &lt;&lt; \" age:\" &lt;&lt; age &lt;&lt; endl; } //栈上分配的内存还用我去释放？ 我傻了 -_- //~Teacher() //{ // if (name != NULL) // { // delete name; // name = NULL; // age = 0; // } //}private: char name[16]; char *name; int age;};ostream&amp; operator&lt;&lt;(ostream&amp; out, Teacher &amp;obj){ out &lt;&lt; obj.name &lt;&lt; \" \" &lt;&lt; obj.age &lt;&lt; endl; return out;}//Teacher中名字是一个指针，即需要我们手动分配内存否则会出现程序宕掉的情况。class Teacher{ friend ostream&amp; operator&lt;&lt;(ostream &amp;out, Teacher &amp;obj) { out &lt;&lt; \"name:\" &lt;&lt; obj.name &lt;&lt; \" age:\" &lt;&lt; obj.age &lt;&lt; endl; return out; }public: //这样的话可以不写无参构造函数吗 经测试可以 那还要无参构造函数干嘛呢？？？ Teacher(const char *name = \"\", int age = 0) { //这个地方要吗？ this-&gt;age = age; this-&gt;name = new char[strlen(name) + 1];//还有\\0 strcpy(this-&gt;name, name); } Teacher(const Teacher &amp;obj) { this-&gt;age = obj.age; name = new char[strlen(obj.name) + 1]; strcpy(name, obj.name); } ~Teacher() { if (name != NULL) { delete[] name; name = NULL; age = 0; } }public: Teacher&amp; operator=(const Teacher &amp;obj) { this-&gt;age = obj.age; this-&gt;name = new char[strlen(obj.name) + 1]; strcpy(name, obj.name); return *this; } void printT() { cout &lt;&lt; \"name:\" &lt;&lt; name &lt;&lt; \" age:\" &lt;&lt; age &lt;&lt; endl; }private: char *name; int age;};int main(){ MyVector&lt;Teacher&gt; tArray(3); Teacher t1(\"123\", 30); Teacher t2(\"456\", 31); Teacher t3(\"789\", 32); tArray[0] = t1; tArray[1] = t2; tArray[2] = t3; Teacher t4; for (int i = 0; i &lt; 3; i++) { Teacher tmp = tArray[i]; tmp.printT(); } cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; tArray &lt;&lt; endl; return 0;}","link":"/posts/20191005a1.html"},{"title":"最小生成树模板","text":"最小生成树也是图论中的一类问题。最小生成树问题最终要求出使所有点连通的最短距离，典型问题为修公路问题。 Prim算法适合稠密图 思路12345Prim算法与Dijkstra算法有很多相似之处。1. 初始化距离，与Dijkstra算法不同的是Prim算法要将所有点的距离初始化正无穷。2. 循环n次 每一次找到不在生成树中距离最小的点（这里的距离指的是距离集合的距离而Dijkstra指的是到一号点的距离） 再用这个点更新临界点的距离。 时间复杂度具体题目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int g[N][N], dist[N];bool st[N];int n, m, res;int prim(){ memset(dist, 0x3f, sizeof(dist)); // 循环n次 for(int i = 0; i &lt; n; i++) { // 寻找集合以外距离最小的点 int t = -1; for(int j = 1; j &lt;= n; j++) { if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; } st[t] = true; // 如果这个点不是第一个点并且距离最短的点为正无穷 则不连通 直接返回false if (i &amp;&amp; dist[t] == INF) return INF; // 如果这个点不是第一个点则加到最终的答案中 if (i) res += dist[t]; for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]); } return res;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if (i == j) g[i][j] = 0; else g[i][j] = INF; while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); g[x][y] = g[y][x] = min(g[x][y], c); } int ret = prim(); if(ret == INF) puts(\"impossible\"); else cout &lt;&lt; ret; return 0;} Kruskal算法思路12341. 排序 将所有的边按照权重排序2. 遍历所有的边 a-&gt;b 权重为 w 如果 a b 不在同一个集合 则合并 考察并查集的知识 时间复杂度主要在排序的过程：O(mlogm) 具体题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100010, M = 200010;// 因为只需遍历所有的边所以可以用一个简单的结构体数组，来存储边struct Edge{ int x, y, c; // 运算符重载 据我的我猜测sort内部实现的时候用的是 &lt; 然后结构体不是基本数据类型 所以要重载 // c++中 class与struct 定义类可以互换 只是 在默认情况下 struct为public class为private // 这个东西估计要看侯捷的《STL源码剖析》吧。 bool operator&lt; (const Edge &amp;obj) const { return c &lt; obj.c; }}edges[M];int p[N];int n, m, cnt, res;int find(int x){ // 路径压缩 if(x != p[x]) p[x] = find(p[x]); return p[x];}bool kruskal(){ sort(edges, edges + m); // 初始化并查集 for(int i = 1; i &lt;= n; i++) p[i] = i; for(int i = 0; i &lt; m; i++) { int x = edges[i].x, y = edges[i].y, c = edges[i].c; int a = find(x), b = find(y); if(a != b) { p[a] = b; res += c; cnt++; } } if(cnt &lt; n - 1) return false; return true;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); //edges[i] = {x, y, c}; c11 edges[i].x = x; edges[i].y = y; edges[i].c = c; } if(kruskal()) cout &lt;&lt; res &lt;&lt; endl; else puts(\"impossible\"); return 0;}","link":"/posts/20191126a1.html"},{"title":"最长上升子序列模型（LIS）","text":"题目链接，$O(N^2)$能过。题目链接，$O(N\\log N)$能过。 $O(N^2)$做法DP：f[i]表示，以第i个数结尾的最长子序列的集合的最大值。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n;int a[N], f[N];int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { f[i] = 1; // 初始化，最小也有它一个数，所以初始化成1 for (int j = 1; j &lt; i; j++) if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1); } int ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, f[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;} $O(N\\log N)$做法再开一个数组，记录长度为x的子序列中最后一个数最小的数。 例如 1 3 8 与 1 2 3 均为长度为三的序列，则新开的数组q[3] = 3。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int a[N], q[N];int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); int len = 0; // 用来记录找的过程中子序列的最大值 //int q[0] = -2e9; for (int i = 1; i &lt;= n; i++) { // 二分寻找q数组中小于a[i]的最大值 // 二分的套路：确定边界, 求mid, 设计check函数 int l = 0, r = len; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (q[mid] &lt; a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); // 更新长度 q[r + 1] = a[i]; // 把a[i]放进去 } cout &lt;&lt; len &lt;&lt; endl; return 0;}","link":"/posts/20200218a1.html"},{"title":"染色法判定二分图","text":"二分图： 一个无向图，使得顶点集V可以分割为两个互不相交的子集A,B，使得所有边两端分别属于两个子集A,B。 思路1遍历每一个点，从每一个点开始进行深搜，深搜的过程中进行染色。 时间复杂度具体题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 100010, M = 200010;int h[N], e[M], ne[M], idx;int color[N]; // 0代表还没染色 染成 1和2int n, m;void add(int x, int y){ e[idx] = y; ne[idx] = h[x]; h[x] = idx++;}bool dfs(int u, int c){ color[u] = c; // 染色 for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if(!color[j]) { if(!dfs(j, 3 - c)) return false; } else if(color[j] == c) return false; } return true;}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y), add(y, x); } bool success = true; for(int i = 0; i &lt; n; i++) { if(!color[i]) if(!dfs(i, 1)) // 如果从i开始染色的过程中出现了矛盾 那么失败 { success = false; break; } } if(success) puts(\"Yes\"); else puts(\"No\"); return 0;}","link":"/posts/20191127a2.html"},{"title":"树状数组与线段树","text":"树状数组与线段树的关系是完全包含关系，就是说只要是树状数组能求解的问题用线段树也能求解，但是树状数组有他的好处：① 代码短 ② 常数很小，即运行效率高。 树状数组lowbit操作看树状数组前，先看一下lowbit操作。 假如x的末尾有k个零，则lowbit(x)返回的是$2^k$。举个例子：若x = 10010000则lowbit(x)返回的是$2^4$就是10000。 那么如何写lowbit操作呢？ lowbit(x) = x &amp; -x，下面来简单的验证一下： 先假设int占四个字节： 分析树状数组的作用：快速的求前缀和。有专门的求前缀和的算法，但是那个算法不支持修改操作，也就是说只能算静态的序列，而树状数组可以维护动态的序列。 树状数组支持的操作：① 给某个位置的数加上常数c ② 求前缀和 画一下线段树的前十六个点以便于理解： 两个核心操作的代码： ① 给某个位置的数加上常数c： 12345void add(int x, int c){ for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;} ② 求前缀和： 1234567int query(int x){ int res = 0; for (int i = x; i &gt;= 1; i -= lowbit(i)) res += tr[i]; return res;} 时间复杂度修改操作：修改下标x时对该点以及父节点进行修改，因为树最多只有$\\log N$层，所以时间复杂度为$O(\\log N)$。查询操作：减去lowbit(x)时最少要减去一位，时间复杂度也为$O(\\log N)$。 所以总的时间复杂度为：$O(\\log N)$* 模板题 C++代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int a[N], tr[N];int lowbit(int x){ return x &amp; -x;}void add(int x, int c){ for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;}int query(int x){ int res = 0; for (int i = x; i &gt;= 1; i -= lowbit(i)) res += tr[i]; return res;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; i++) add(i, a[i]); int k, x, y; while (m--) { scanf(\"%d%d%d\", &amp;k, &amp;x, &amp;y); if (!k) printf(\"%d\\n\", query(y) - query(x - 1)); else add(x, y); } return 0;} Java代码12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class Main{ static int N = 100010; static int n, m; static int[] a = new int[N]; static int[] tr = new int[N]; public static void main(String[] args){ Scanner scan = new Scanner(System.in); n = scan.nextInt(); m = scan.nextInt(); for (int i = 1; i &lt;= n; i++) a[i] = scan.nextInt(); for (int i = 1; i &lt;= n; i++) add(i, a[i]); int k, x, y; for (int i = 0; i &lt; m; i++){ k = scan.nextInt(); x = scan.nextInt(); y = scan.nextInt(); if (k == 0) System.out.println(query(y) - query(x - 1)); else add(x, y); } } public static int lowbit(int x){ return x &amp; -x; } public static void add(int x, int c){ for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; } public static int query(int x){ int res = 0; for (int i = x; i &gt;= 1; i -= lowbit(i)){ res += tr[i]; } return res; }}","link":"/posts/20200307a1.html"},{"title":"树的同构","text":"每次做课后布置的题就要做好久，这个题老师讲的时候用的是C语言，我想用C++中的vector做发现做的过程中遇到了许多的问题，老是出现程序宕掉的问题，但让我十分开心的是，改完以后居然一次就AC了别提有多激动了，不过这代码只是完成了功能，可读性做的很差，尤其是判断同构的函数，但是以后回过头来看还是很有意思的吧😂😂。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define Null -1typedef char ElemType;struct TreeNode{ ElemType Data; int lchild; int rchild;};int TreeCreate(vector&lt;TreeNode&gt; &amp;t, int n);bool isomorphic(vector&lt;TreeNode&gt; &amp;t1, int t1Root, vector&lt;TreeNode&gt; &amp;t2, int t2Root);int t1Root;int t2Root;int main(){ int n; cin &gt;&gt; n; vector&lt;TreeNode&gt; t1(n); t1Root = TreeCreate(t1, n); cin &gt;&gt; n; vector&lt;TreeNode&gt; t2(n); t2Root = TreeCreate(t2, n); if (isomorphic(t1, t1Root, t2, t2Root)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;}int TreeCreate(vector&lt;TreeNode&gt; &amp;t, int n){ int root = -1; vector&lt;int&gt; arr(n, 1); for (int i = 0; i &lt; n; i++) { char cl, cr; cin &gt;&gt; t[i].Data &gt;&gt; cl &gt;&gt; cr; if (cl == '-') t[i].lchild = Null; else { t[i].lchild = cl - '0'; arr[t[i].lchild] = 0; } if (cr == '-') t[i].rchild = Null; else { t[i].rchild = cr - '0'; arr[t[i].rchild] = 0; } } for (int i = 0; i &lt; n; i++) { if (arr[i] != 0) { root = i; break; } } return root;}//要明确的一点是Null指的是树的存储结构为数组的下标 下标是从零开始 所以左儿子或者右儿子 为Null 即没有bool isomorphic(vector&lt;TreeNode&gt; &amp;t1, int t1Root, vector&lt;TreeNode&gt; &amp;t2, int t2Root){ if (t1Root == Null &amp;&amp; t2Root == Null) return true; else if ((t1Root != Null &amp;&amp; t2Root == Null) || (t1Root == Null &amp;&amp; t2Root != Null)) return false; else if (t1[t1Root].Data != t2[t2Root].Data) return false; else if (t1[t1Root].lchild == Null &amp;&amp; t2[t2Root].lchild == Null) return isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].rchild); else if ((t1[t1Root].lchild != Null &amp;&amp; t2[t2Root].lchild != Null) &amp;&amp; (t1[t1[t1Root].lchild].Data == t2[t2[t2Root].lchild].Data)) return isomorphic(t1, t1[t1Root].lchild, t2, t2[t2Root].lchild) &amp;&amp; isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].rchild); else return isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].lchild)&amp;&amp; isomorphic(t1, t1[t1Root].lchild, t2, t2[t2Root].rchild);}","link":"/posts/20191003a1.html"},{"title":"棋盘问题","text":"在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output1221 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10;char g[N][N];bool rows[N], cols[N];int n, k, ans;void dfs(int x, int y, int s){ if (y == n) y = 0, x++; if (x == n) { if (s == k) ans++; return; } // 不选 dfs(x, y + 1, s); // 选 if (!rows[x] &amp;&amp; !cols[y] &amp;&amp; g[x][y] == '#') { rows[x] = cols[y] = true; dfs(x, y + 1, s + 1); rows[x] = cols[y] = false; }}int main(){ while (scanf(\"%d%d\", &amp;n, &amp;k), n != -1 &amp;&amp;k != -1) { for (int i = 0; i &lt; n; i++) scanf(\"%s\", g[i]); dfs(0, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; memset(g, 0, sizeof(g)); ans = 0; } return 0;}","link":"/posts/20191207a1.html"},{"title":"滚动数组","text":"一维数组老生常谈的斐波那契数列。 1 1 2 3 5 8 13 21 ….编写一个函数，输入n，返回第n个数(n &lt;= 50)。(实测当 n = 47 爆int) 12345678910111213// 不使用滚动数组LL fib(int n){ LL fibnacci[55]; fibnacci[0] = fibnacci[1] = 1; if (n == 0 || n == 1) return 1; for (int i = 2; i &lt;= n; i++) fibnacci[i] = fibnacci[i - 1] + fibnacci[i - 2]; return fibnacci[n];} 12345678910111213141516171819// 使用滚动数组// 在求第n个数时，只用到了前面两个值，所以只需开一个长度为三的数组。LL fib(int n){ LL fibnacci[3]; fibnacci[0] = fibnacci[1] = 1; if (n == 0 || n == 1) return 1; while (n - 1) { n--; fibnacci[2] = fibnacci[0] + fibnacci[1]; fibnacci[0] = fibnacci[1]; fibnacci[1] = fibnacci[2]; } return fibnacci[2];} 二维数组递推关系f[i][j] = f[i - 1][j] + f[i - 1][j - x] (其中 x &gt; 0) 编写一个函数，输入a，b，输出f[a][b]。(i, j &lt;= 50) 123456789101112131415161718// 不使用滚动数组// 第0行与第0列为递推的出口int f[50][50], x = 2;void init(){ for (int i = 0; i &lt; 50; i++) f[0][i] = 1;}int func(int a, int b){ init(); for (int i = 1; i &lt;= a; i++) for (int j = 1; j &lt;= b; j++) if (j &gt;= x) f[i][j] = f[i - 1][j] + f[i - 1][j - x]; return f[a][b];} 123456789101112131415161718192021// 使用滚动数组// 在求f[i][j]时只用到了前面一行所以可以使用滚动数组int f[2][50];void init(){ for(int i = 0; i &lt; 50; i++) f[0][i] = 1;}int func(int a, int b){ init(); for (int i = 1; i &lt;= a; i++) { for (int j = 0; j &lt; 50; j++) f[i % 2][j] = 0; // 这个地方很重要 一开始我没有想到 打印时才发现问题 for (int j = 1; j &lt;= b; j++) if (j &gt;= x) f[i % 2][j] = f[1 - i % 2][j] + f[1 - i % 2][j - x]; // 第1行使用第0行，第0行使用第1行 } return f[a % 2][b];}","link":"/posts/20191215a1.html"},{"title":"电影","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define N 200010using namespace std;map&lt;int,int&gt;s;int a[N];int b[N];struct zz{ int a; int b;}p[N];int main(){ int n,m,i,j,k; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); //s用来统计a[i]的个数 s[a[i]]++; } scanf(\"%d\",&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d\",&amp;p[i].a); for(i=1;i&lt;=m;i++) scanf(\"%d\",&amp;p[i].b); int mm=0;k=1; for(i=1;i&lt;=m;i++) { //统计出现次数最多的语言的个数,并记录其在语音列表中---第一次出现-----的位置 if(mm&lt;s[p[i].a]) { mm=s[p[i].a]; k=i; } } //统计 int kk=0; for(i=1;i&lt;=m;i++) { //在mm相等的情况下，比较s[p[i].b]。记录s[p[i].b]最大的位置 if(s[p[i].a]==mm) { if(kk&lt;s[p[i].b]) { kk=s[p[i].b]; k=i; } } } printf(\"%d\\n\",k); return 0;}","link":"/posts/20200207a1.html"},{"title":"电话聊天狂人","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/*#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 400009, null = -1;LL h[N];int sum[N];int n, ans, cnt;LL ansNum[N];void insert(LL x){ int a = x % N; while (h[a] != null &amp;&amp; h[a] != x) { a++; if (a == N) a = 0; } sum[a]++; if (sum[a] == ans) ansNum[cnt++] = x; else if (sum[a] &gt; ans) { ans = sum[a]; if (ans == 0) ansNum[cnt++] = x; else { memset(ansNum, 0, sizeof(ansNum)); cnt = 0; ansNum[cnt++] = x; } } h[a] = x;}int main(){ memset(h, -1, sizeof(h)); cin &gt;&gt; n; while (n--) { LL from, to; scanf(\"%lld%lld\", &amp;from, &amp;to); insert(from), insert(to); } if (cnt == 1) printf(\"%lld %d\\n\", ansNum[0], ans); else { LL min = 1e12; for (int i = 0; i &lt; cnt; i++) if (ansNum[i] &lt; min) min = ansNum[i]; printf(\"%lld %d %d\", min, ans, cnt); } return 0;}*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; typedef struct ListNode *Position;typedef struct ListNode{ char PhoneNum[12]; int cnt; Position Next;} *List; typedef struct HashTbl{ int TableSize; List *TheLists;//建立一个ListNode的指针数组} *HashTable; int NextPrime(int x);HashTable InitializeTable(int TableSize);void DestroyTable(HashTable H);Position Find(char Key[], HashTable H);void Insert(char Key[], HashTable H);int Hash(int Key, int TableSize);void FindMax(HashTable H); int main(int argc, char const *argv[]){ // freopen(\"test.txt\", \"r\", stdin); int N; scanf(\"%d\", &amp;N); HashTable H = InitializeTable(2 * N); char send[12], rec[12]; for (int i = 0; i &lt; N; i++){ scanf(\"%s %s\\n\", send, rec); Insert(send, H), Insert(rec, H); } FindMax(H); DestroyTable(H); return 0;} int NextPrime(int x){ int i; for (int Next = x; ; Next++){ for (i = 2; i * i &lt;= Next; i++) if (Next % i == 0) break; if (i * i &gt; Next) return Next; }} HashTable InitializeTable(int TableSize){ HashTable H; H = (HashTable)malloc(sizeof(struct HashTbl)); H-&gt;TableSize = NextPrime(TableSize); H-&gt;TheLists = (List*)malloc(sizeof(List)*H-&gt;TableSize); for (int i = 0; i != H-&gt;TableSize; i++){ H-&gt;TheLists[i] = (List)malloc(sizeof(struct ListNode)); H-&gt;TheLists[i]-&gt;Next = NULL; } return H;} void DestroyTable(HashTable H){ for (int i = 0; i &lt; H-&gt;TableSize; i++) free(H-&gt;TheLists[i]); free(H-&gt;TheLists); free(H);} Position Find(char Key[], HashTable H){ Position P; List L; L = H-&gt;TheLists[Hash(atoi(Key + 6), H-&gt;TableSize)]; P = L-&gt;Next; while (P != NULL &amp;&amp; strcmp(P-&gt;PhoneNum, Key)) P = P-&gt;Next; return P;} void Insert(char Key[], HashTable H){ Position Pos, Tmp; List L = H-&gt;TheLists[Hash(atoi(Key + 6), H-&gt;TableSize)]; Pos = Find(Key, H); if (Pos == NULL){ Tmp = (List)malloc(sizeof(struct ListNode)); strcpy(Tmp-&gt;PhoneNum, Key); Tmp-&gt;cnt = 1; Tmp-&gt;Next = L-&gt;Next; L-&gt;Next = Tmp; } else { (Pos-&gt;cnt)++; }} int Hash(int Key, int TableSize){ return (Key % TableSize);} void FindMax(HashTable H){ Position P; int maxcnt = 0, maxSame = 1; char MinPhone[12]; for (int i = 0; i &lt; H-&gt;TableSize; i++){ P = H-&gt;TheLists[i]-&gt;Next; while (P != NULL){ if (P-&gt;cnt &gt; maxcnt){ strcpy(MinPhone, P-&gt;PhoneNum); maxcnt = P-&gt;cnt; maxSame = 1; } else if (P-&gt;cnt == maxcnt){ if (strcmp(MinPhone, P-&gt;PhoneNum) &gt; 0) strcpy(MinPhone, P-&gt;PhoneNum); maxSame++; } P = P-&gt;Next; } } printf(\"%s %d\", MinPhone, maxcnt); if (maxSame &gt; 1) printf(\" %d\", maxSame);}","link":"/posts/20191216a1.html"},{"title":"第K个数","text":"题目链接 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n, k;int quick_sort(int q[], int l, int r, int k){ if(l == r) return q[l]; int x = q[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while(i &lt; j) { while(q[++i] &lt; x) ; while(q[--j] &gt; x) ; if(i &lt; j) swap(q[i], q[j]); } int sl = j - l + 1; if(sl &gt;= k) return quick_sort(q, l, j, k); else return quick_sort(q, j + 1, r, k - sl);}int main(){ cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); cout &lt;&lt; quick_sort(q, 0, n-1, k); //quick_sort直接返回第K个数 return 0;} asssdfdfsdfs sdfsfejdfdsdgsdg dg ff ffffff dgd dgdfgdf","link":"/posts/20191107a1.html"},{"title":"空间限制xxMB","text":"一般题目中不会卡空间，但是还是需要会计算。 首先看一下，各种数据类型的长度。 在K&amp;R的The C Programming Language中写道：char占用一个字节，int通常代表特定机器中整数的自然长度。short类型通常为16位，long类型通常为32位，int类型可以为16位或32位。各编译器可以根据硬件特性自主选择合适的类型长度，但要遵循以下限制：short与int类型至少为16位，而long类型至少为32位，并且short类型不得长于int类型，int类型不得长于long类型。 在我电脑（win10，64位）中实测各种数据类型的长度如下： 一般题目中的空间限制为64MB，假设都用来开int数组： 一个int为4个Byte，1MB为1024*1024个Byte，所以64MB最多可以开16777216个int（$1.67 * 10^7$个int）。但是y总说过，操作系统会为我们做优化，只有真正用到时才会开这么大，emmmmm~😅等我学的更深入了再看一下吧。 参考文献： The C Programming Language","link":"/posts/20200227a1.html"},{"title":"等差数列","text":"题目题目链接 题目描述数学老师给小明出了一道等差数列求和的题目。 但是粗心的小明忘记了一部分的数列，只记得其中$N$个整数。 现在给出这$N$个整数，小明想知道包含这$N$个整数的最短的等差数列有几项？ 输入格式输入的第一行包含一个整数$N$。 第二行包含$N$个整数$A_1$,$A_2$,⋅⋅⋅,$A_N$。(注意$A_1$∼$A_N$并不一定是按等差数列中的顺序给出) 输出格式输出一个整数表示答案。 数据范围2\\le$N$\\le100000,0\\le$A_i$\\le10^9 输入样例： 52 6 4 10 20 输出样例： 10 样例解释:包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、18、20。 分析等差数列的任意两项之差为公差的倍数。($a_n-a_1=(n-1)d, n\\ge2$) 拿样例来说，2, 6, 4, 10, 20，排序之后为2, 4, 6, 10, 20，与首项的差为2, 4, 8, 18。 要使得等差数列最短就要使公差尽可能的大，就是要求差的最大公约数。 n个数的最大公约数为求前两个的gcd，再用求出gcd与后面的数依次求。证明？不会😁 等差数列需要注意公差为0的情况 用到的知识1.等差数列的通项公式，注意公差为0的情况。 2.欧几里得算法又称辗转相除法。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int a[N];int ans;int gcd(int a, int b){ return b ? gcd(b, a % b) : a;}int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); sort(a, a + n); for (int i = 1; i &lt; n; i++) ans = gcd(ans, a[i] - a[0]); if (ans == 0) cout &lt;&lt; n &lt;&lt; endl; else cout &lt;&lt; (a[n - 1] - a[0]) / ans + 1&lt;&lt; endl; return 0;}","link":"/posts/20200210a2.html"},{"title":"糖果","text":"题目题目链接 题目描述由于在维护世界和平的事务中做出巨大贡献，Dzx被赠予糖果公司2010年5月23日当天无限量糖果免费优惠券。 在这一天，Dzx可以从糖果公司的$N$件产品中任意选择若干件带回家享用。 糖果公司的$N$件产品每件都包含数量不同的糖果。 Dzx希望他选择的产品包含的糖果总数是$K$的整数倍，这样他才能平均地将糖果分给帮助他维护世界和平的伙伴们。 当然，在满足这一条件的基础上，糖果总数越多越好。 Dzx最多能带走多少糖果呢？ 注意：Dzx只能将糖果公司的产品整件带走。 输入格式第一行包含两个整数$N$和$K$。 以下$N$行每行$1$个整数，表示糖果公司该件产品中包含的糖果数目，不超过$1000000$。 输出格式符合要求的最多能达到的糖果总数，如果不能达到$K$的倍数这一要求，输出$0$。 数据范围$1\\le N\\le 100,$$1\\le K\\le 100$ 输入样例： 5 712345 输出样例： 14 样例解释Dzx的选择是2+3+4+5=14，这样糖果总数是7的倍数，并且是总数最多的选择。 分析 用到的知识背包问题 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110, inf = 0x3f3f3f3f;int n, k;int a[N];int f[N][N];int main(){ cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; memset(f, -0x3f, sizeof(f)); f[0][0] = 0; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; k; j++) { f[i][j] = -inf; f[i][j] = max(f[i][j], f[i - 1][j]); f[i][j] = max(f[i][j], f[i - 1][(j + k - a[i] % k) % k] + a[i]); } cout &lt;&lt; f[n][0] &lt;&lt; endl; return 0;}","link":"/posts/20200217a2.html"},{"title":"糖果传递","text":"题目链接 分析过程123456789101112131415161718192021221-&gt;2-&gt;3-&gt;4-&gt;...-&gt;n-&gt;1 构成一个环x1 x2 x3 x4 .... xn xi表示xi给xi+1糖果的个数，xi可正可负可为零。本题要求|x1|+|x2|+|x3|+.....+|xn|的最小值。 限制条件：最后每个人获得均等糖果。av表示平均值，a数组表示每个人初始糖果的数量。a[1] - x1 + xn = av; a[1] - x1 + xn = av;a[2] - x2 + x1 = av; a[2] - x2 + x1 = av;a[3] - x3 + x2 = av; a[2] + a[3] - x3 + x1 = 2 * av;a[4] - x4 + x3 = av; . . ==========&gt; . 等价成cn。 cn = cn-1 + an - av; (n &gt;= 2) . . ^ c1 = 0; . . | . . 通项公式 ----------------------a[n-1] - xn-1 + xn-2 = av; a[2] + ... + a[n - 1] - xn-1 + x1 = (n - 2) * av; | n |a[n] - xn + xn-1 = av; a[2] + ... + a[n] - xn + x1 = (n - 1) * av; =========&gt; xn = x1 +| ∑ an - (n - 1) * av; | (n &gt;= 2) |n=2 | ----------------------经过上面的等价推导，所以： |x1|+|x2|+|x3|+.....+|xn| ==&gt; |x1 + c1|+|x1 + c2|+|x1 + c3|+.....+|xn + cn| 到这里就转换成AcWing 104.货仓选址这道题了。(链接在下方) AcWing 104.货仓选址 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1000010;int n;LL a[N], c[N];LL sum, ans;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); sum += a[i]; } LL avg = sum / n; // 因为题目保证有解，因此平均数必为整数。 c[1] = 0; for (int i = 2; i &lt;= n; i++) c[i] = c[i - 1] + a[i] - avg; sort(c + 1, c + 1 + n); int mid = c[(1 + n) / 2]; for (int i = 1; i &lt;= n; i++) ans += (LL)abs(mid - c[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/posts/20200203a1.html"},{"title":"背包问题","text":"01背包问题给定物品的数量n（每一种物品只有一件）以及每件物品的价值，一个容量为v的背包，问怎样装物品使总价值最大。 朴素算法1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N]; // v 代表体积 w 代表权重 y总写的和其他人正好反着。 其他人 w 代表weight v 代表 value int f[N][N];int n, m;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;v[i], &amp;w[i]); for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (v[i] &lt;= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化优化之前先看一下滚动数组。使用滚动数组可以大大减少空间复杂度。 二维变一维，最终优化结果： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m, f[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = m; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} 完全背包问题给定n种物品（每一种物品有无限个）以及每一种物品的价值，一个容量为v的背包，问怎样装物品使价值最大。 朴素算法1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) for (int k = 0; k * v[i] &lt;= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化123456/* * f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, ....,f[i - 1][j - x * v] + x * w) * f[i][j - v] = max( f[i - 1][j - v] , f[i - 1][j - 2v] + w, .....,f[i - 1][j - x * v] + (x - 1) * w) * * f[i][j] = max(f[i - 1][j], f[i][j - v] + w); */ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化成一维12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = v[i]; j &lt;= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} 多重背包问题朴素算法","link":"/posts/20191206a1.html"},{"title":"蓝桥杯官网练习题","text":"习题链接 考前集中把蓝桥杯官网上的算法提高里的习题做一做，希望有备战的小伙伴与我一起刷题😄，上面的题都不难，比y总的课简单多了😂。 学算法不到半年时间，假如有小伙伴做的方法比我的更简单或者我的代码有bug，欢迎在下方评论，谢谢啦。 ADV-306 输出三个整数的最大数1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 3;int a[3];int main(){ for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; sort(a, a + N); cout &lt;&lt; a[2] &lt;&lt; endl; return 0;} ADV-305 输出二进制表示123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;char s[10];int n;int main(){ cin &gt;&gt; n; itoa(n, s, 2); int end = 0; while (s[end] != '\\0') end++; end--; if (n &gt;= 0) cout &lt;&lt; 0; else cout &lt;&lt; 1; int mask = 1, num = 0; for (int i = end; i &gt;= 0 &amp;&amp; i &gt;= end - 6; i--) { num += (s[i] - '0') * mask; mask *= 10; } printf(\"%07d\", num); return 0;} ADV-304 矩阵转置123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 25;int n, m;int a[N][N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf(\"%d\", &amp;a[i][j]); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) printf(\"%d \", a[j][i]); puts(\"\"); } return 0;} ADV-303 数组求和数据范围较小，暴力$O(n^2)$就可以了。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int a[N * 2];int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); a[i + n] = a[i]; } int ans = 0; for (int i = 1; i &lt;= n; i++) { int sum = 0; for (int j = i; j &lt;= i + m - 1; j++) sum += a[j]; ans = max(ans, sum); } printf(\"%d\\n\", ans); return 0;} ADV-302 秘密行动1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int n;int a[N];int f[N][2]; // 第二维为0的话表示到达某一层是跳上来的，为1表示爬上来的。 // 一开始做时根本没想第二维，但是怎么做也做不对，所以又想了一下，其实上楼的过程是有限制的， // 比如这一层是跳上来的话，上一层一定是爬上来的，这一层是爬上来的，那么上一层既可以是跳上来的，也可以是爬上来的。int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; f[1][0] = 0; f[1][1] = a[1]; for (int i = 2; i &lt;= n; i++) { f[i][0] = min(f[i - 1][1], f[i - 2][1]); f[i][1] = min(f[i - 1][0], f[i - 1][1]) + a[i]; // 这个不应该是a[i]-a[i-1]吗？但是因为样例没过，所以改了一下，居然才对了。。。 } cout &lt;&lt; min(f[n][0], f[n][1]) &lt;&lt; endl; return 0;} ADV-301 字符串压缩123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;int main(){ map&lt;char, int&gt; m; string s, s1; getline(cin, s); for (string::iterator it = s.begin(); it != s.end(); it++) { m[*it]++; if (*it == ' ') s1.push_back(*it); if (m[*it] == 1 || m[*it] == 3 || m[*it] == 6) s1.push_back(*it); } cout &lt;&lt; s1 &lt;&lt; endl; return 0;} ADV-300 字符串生成器不会啊。。 ADV-299 宰羊题解链接，之前我在问答区问过，这是胡图图大佬写的。 ADV-298 和谐宿舍21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, m;int h[N]; // 代表高度int f[N][N]; // f[i][k]代表 用k块木板 从把前i个作品盖住的集合的最小值int maxh[N][N]; // maxh[i][j]代表 i~j 个作品中 高度的最大值int main(){ scanf(\"%d%d\", &amp;n, &amp;m); int sum = 0; for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]); // 找每个区间中最高的作品，由于数据范围很小直接暴力 for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) { int s = 0; for (int k = i; k &lt;= j; k++) s = max(s, h[k]); maxh[i][j] = s; } for (int i = 1; i &lt;= n; i++) for (int k = 1; k &lt;= m &amp;&amp; k &lt;= i; k++) { if (k == 1) f[i][k] = i * maxh[1][i]; // 只有一块木板 else if (k == i) // 木板与作品的个数相同，则最小值为高度之和 { int sum = 0; for (int u = 1; u &lt;= i; u++) sum += h[u]; f[i][k] = sum; } else { f[i][k] = 0x3f3f3f3f; // 这里的u代表的是最后一块木板的起始位置 for (int u = i; u &gt;= k; u--) f[i][k] = min(f[i][k], f[u - 1][k - 1] + maxh[u][i] * (i - u + 1)); } } int ans = 0x3f3f3f3f; for (int i = 1; i &lt;= m; i++) ans = min(ans, f[n][i]); printf(\"%d\", ans); return 0;} ADV-297 快速排序12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 15;int a[N];void quick_sort(int l, int r){ if (l == r) return; int x = a[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while (i &lt; j) { while (a[++i] &lt; x) ; while (a[--j] &gt; x) ; if (i &lt; j) swap(a[i], a[j]); } quick_sort(l, j); quick_sort(j + 1, r);}int main(){ int x, cnt = 0; while (cin &gt;&gt; x, x) a[cnt++] = x; quick_sort(0, cnt - 1); for (int i = 0; i &lt; cnt; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; return 0;}","link":"/posts/20200225a1.html"},{"title":"迷宫问题","text":"定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,}; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 Input一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 Output左上角到右下角的最短路径，格式如样例所示。 Sample Input123450 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 Sample Output123456789(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4) 代码c99中不能{ x, y }要make_pair(x, y) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 10;int g[N][N];bool vis[N][N];PII pre[N][N];void bfs(){ queue&lt;PII&gt; q; q.push({ 0, 0 }); vis[0][0] = true; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; while (q.size()) { PII k = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int x = k.first + dx[i], y = k.second + dy[i]; if(x &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 5 &amp;&amp; g[x][y] == 0 &amp;&amp; !vis[x][y]) { vis[x][y] = true; pre[x][y] = k; q.push({ x, y }); } } }}int main(){ for (int i = 0; i &lt; 5; i++) for (int j = 0; j &lt; 5; j++) scanf(\"%d\", &amp;g[i][j]); bfs(); pre[0][0] = { -1, -1 }; stack&lt;PII&gt; s; s.push({ 4, 4 }); PII Pre = pre[4][4]; while (Pre.first != -1 &amp;&amp; Pre.second != -1) { s.push(Pre); Pre = pre[Pre.first][Pre.second]; } while (!s.empty()) { printf(\"(%d, %d)\\n\", s.top().first, s.top().second); s.pop(); } return 0;}","link":"/posts/20191209a1.html"},{"title":"逆序对的数量","text":"题目链接 暴力 时间复杂度为O(n^2)12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); int cnt = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { if (q[j] &gt; q[i]) cnt++; } } cout &lt;&lt; cnt; return 0;} 归并 时间复杂度为O(nlogn)，又印证了陈越姥姥的那句话了。归并的思想也是分而治之。递归不能忘了写递归出口啊。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N], tmp[N];int n;long long res;void merge_sort(int q[], int l, int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else { res += mid - i + 1; tmp[k++] = q[j++]; } } while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); merge_sort(q, 0, n - 1); cout &lt;&lt; res; system(\"pause\"); return 0;}","link":"/posts/20191108a2.html"},{"title":"递增三元组","text":"题目题目链接 分析直接暴力$O(N^3)$，显然超时。 将三个数组排序，遍历$b$数组，二分找到$a$中小于$b[i]$的个数$A$，找到$c$中大于$b[i]$的个数$C$，$ans$+=$A*C$。 时间复杂度，排序$O(N \\log N)$，查找$O(N \\log N)$，总体$O(N \\log N)$。 代码自己写二分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010;int n;int a[N], b[N], c[N];LL ans;int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;b[i]); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;c[i]); sort(a, a + n); sort(b, b + n); sort(c, c + n); /* 二分： * 1. 找边界 * 2. 求mid，写check函数 * 3. 若l = mid则 +1，r = mid不用 +1 * * 需要注意的是，二分出来的点若在边界则需要特判。 */ for (int i = 0; i &lt; n; i++) { int A = 0, C = 0; int l = 0, r = n - 1; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (a[mid] &lt; b[i]) l = mid; else r = mid - 1; } if (a[l] &lt; b[i]) A = l + 1; l = 0, r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (c[mid] &gt; b[i]) r = mid; else l = mid + 1; } if (c[l] &gt; b[i]) C = n - l; ans += (LL)A * C; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} lower_bound(), upper_bound();","link":"/posts/20200221a2.html"},{"title":"鸣人的影分身","text":"题目题目链接 题目描述在火影忍者的世界里，令敌人捉摸不透是非常关键的。 我们的主角漩涡鸣人所拥有的一个招数——多重影分身之术——就是一个很好的例子。 影分身是由鸣人身体的查克拉能量制造的，使用的查克拉越多，制造出的影分身越强。 针对不同的作战情况，鸣人可以选择制造出各种强度的影分身，有的用来佯攻，有的用来发起致命一击。 那么问题来了，假设鸣人的查克拉能量为$M$，他影分身的个数最多为$N$，那么制造影分身时有多少种不同的分配方法？ 注意： 影分身可以分配0点能量。分配方案不考虑顺序，例如$M$=7,$N$=3，那么 (2,2,3) 和 (2,3,2) 被视为同一种方案。 输入格式第一行是测试数据的数目$t$。 以下每行均包含二个整数$M$和$N$，以空格分开。 输出格式对输入的每组数据$M$和$N$，用一行输出分配的方法数。 数据范围$0\\le t\\le 20$,$1\\le M, N\\le 10$ 输入样例： 17 3 输出样例： 8 分析 用到的知识1.dfs2.Dp状态计算中很奇怪的分法。 代码dfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 15;int f[N];int n, m;LL ans;// u代表dfs到了哪一位，s代表已经用了多少查克拉，st就是start的缩写代表着从多少开始，因为本题总不考虑顺序，所以我们自己规定一个不减小的顺序void dfs(int u, int s, int st){ if (s &gt; n) return; // 剪枝，如果大于查克拉总量 return if (u == m + 1) // 找完所有位 { if (s == n) ans++; return; } for (int i = st; i &lt;= n; i++) { f[u] = i; dfs(u + 1, s + i, i); }}int main(){ int t; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; m; dfs(1, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; ans = 0; } return 0;} Dp1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 15;int m, n;int f[N][N];int main(){ int t; cin &gt;&gt; t; while (t--) { cin &gt;&gt; m &gt;&gt; n; // 这里的初始化很烦，因为本题中可以分配0，所以总量为0时分成任意非负份的方案数均为1 for (int i = 0; i &lt;= n; i++) f[0][i] = 1; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) { f[i][j] = f[i][j - 1]; if (i &gt;= j) f[i][j] += f[i - j][j]; } cout &lt;&lt; f[m][n] &lt;&lt; endl; memset(f, 0, sizeof(f)); } return 0;}","link":"/posts/20200217a1.html"},{"title":"二级指针做输入输出","text":"本文将介绍二级指针做函数输出以及做函数输入的三种内存模型从内存四区的角度对程序执行的过程进行剖析，通过这中方式来加深对指针的理解。 二级指针做输出（在被调函数中分配内存）模型：主函数：123456789int main(){ char *p = NULL; int len = 0; getMem(&amp;p, &amp;len); printf(\"p=%s\\n\", p); FreeMem(&amp;p); return 0;} getMem函数：12345678910111213int getMem(char **myp,int *mylen){ char *temp = NULL; temp = (char*)malloc(100); if (temp == NULL) { return -1; } strcpy(temp, \"abcdefg\"); *mylen = strlen(temp); *myp = temp; return 0;} 犯的错误：*myp = temp; 最初写成了*myp = *temp; 而该表达式赋值两端根本不是一种数据类型。 *myp = temp1; 这句话与*mylen = 某一数值 本质上是一样的，都是*加上指针变量来改变主调用函数中的内容只不过，myp为二级指针因此赋值的右端应为一级指针。 补充： &quot;abcdefg&quot;在常量区中，strcpy(temp, &quot;abcdefg&quot;); 这一句使得temp指向&quot;abcdefg&quot;，其值为字符'a'的地址。 总结：想要在被调用函数中修改主调用函数中的值，必须使用指针，例如在getMem函数中，修改变量的值使用一级指针，修改一级指针需要用到二级指针。 FreeMem函数：1234567891011void FreeMem(char **myp){ if (myp == NULL) { return; } char *tmp = NULL; tmp = *myp; free(tmp); tmp = NULL;} 12345678void FreeMem(char *myp){ if(myp = NULL) { return ; } free(myp);} 这两种FreeMem函数都可以释放p指向的内存，但第一个函数的好处在于使用了二级指针，可在FreeMem函数中将主调用函数中的p的值改为NULL避免 野指针的出现，而第二个函数则要在FreeMem后加上一句p=NULL。 调试结果： 二级指针做输入（在主调用函数中分配内存）模型一：指针数组：1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char *myArray[] = { \"xcccc\",\"ybbbb\",\"zaaaa\" }; int len = sizeof(myArray) / sizeof(myArray[0]); int i = 0; for (i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); //printf(\"%s\\n\", *(myArray+i)); 效果相同 } int j, k; j = k = 0; char *temp = NULL; for (j = 0; j &lt; len - 1; j++) { for (k = 0; k &lt; len - j - 1; k++) { if (strcmp(myArray[k], myArray[k + 1]) &gt; 0) { temp = myArray[k]; myArray[k] = myArray[k + 1]; myArray[k + 1] = temp; } } } for (i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); //printf(\"%s\\n\", *(myArray+i)); 效果相同 } return 0;} 总结：1.在32位操作系统下指针变量的长度为4，在64位下为8。 2.指针数组为元素为指针的数组，myArray数组中有三个元素，sizeof(myArray) / sizeof(myArray[0])可以求出数组长度。 3.排序使用的为最简单的冒泡排序。排序过程中交换的是指针而不是内存块。 二级指针做输入模型一封装函数：主函数：123456789101112int main(){ char *myArray[] = { \"zzz\",\"yyyyyyy\",\"xxxxxxxxx\" }; int len = sizeof(myArray) / sizeof(myArray[0]); printArray(myArray, len); SortArray(myArray, len); printArray(myArray, len); return 0;} 打印函数：1234567void printArray(char **myArray, int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} 排序函数：12345678910111213141516void SortArray(char **myArray, int len){ char *temp = NULL; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { temp = myArray[j]; myArray[j] = myArray[j + 1]; myArray[j + 1] = temp; } } }} 总结：数组在做函数参数是退化为指针，数组名指向数组的第一个元素，即数组名中存放的是数组中第一个元素的地址。指针数组也是如此，char *myArray[];中定义了一个名为myArray的指针数组，根据上面的说明，myArray为第一个元素的地址，而数组元素为指向char类型的指针，即为char *类型，因此myArray为char **类型，所以在函数中第一个参数，均为char **myArray。 二级指针做输入（在主调用函数中分配内存）模型二：二维数组：123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char myArray[10][30] = { \"ddddd\",\"ccccc\",\"bbbbb\",\"aaaaa\" }; int num = 4; for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", myArray[i]); } char temp[30]; for (int i = 0; i &lt; num - 1; i++) { for (int j = 0; j &lt; num - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { strcpy(temp, myArray[j]); strcpy(myArray[j], myArray[j + 1]); strcpy(myArray[j + 1], temp); } } } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", myArray[i]); } return 0;} 二级指针做输入模型二封装函数：主函数：123456789int main(){ char myArray[10][30] = { \"ddddd\",\"ccccc\",\"bbbbb\",\"aaaaa\" }; int num = 4; printArray(myArray, num); SortArray(myArray, num); printArray(myArray, num); return 0;} 打印函数：1234567void printArray(char (*myArray)[30], int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} 排序函数：12345678910111213141516void SortArray(char (*myArray)[30], int len){ char temp[30]; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { strcpy(temp, myArray[j]); strcpy(myArray[j], myArray[j + 1]); strcpy(myArray[j + 1], temp); } } }} 总结：二维数组在做函数参数的时候会退化成为一个指针数组。 二维数组中重要的两个点： 1.二维数组名为第一维首元素的地址。 2.一维数组名为首元素的地址。 有了这两点下面将演示如何用数组名打印某一个元素： 1234567 ==&gt; 表示等价myArray ==&gt; &amp;myArray[0] //上面的第一点 myArray + 2 ==&gt; &amp;myArray[2]*(myArray + 2) ==&gt; myArray[2] ==&gt; &amp;myArray[2][0] //上面的第二点*(myArray + 2) + 1 ==&gt; &amp;myArray[2][1]*(myArray + 2) + 4 ==&gt; &amp;myArray[2][4]*(*(myArray + 2) + 4) ==&gt; myArray[2][4] 二级指针做输入（在主调用函数中分配内存）模型三：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char **p = NULL; int num = 4; p = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { p[i] = (char*)malloc(sizeof(char) * 100); sprintf(p[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", p[i]); } char *temp = NULL; for (int i = 0; i &lt; num - 1; i++) { for (int j = 0; j &lt; num - i - 1; j++) { if (strcmp(p[j], p[j + 1]) &gt; 0) { temp = p[j]; p[j] = p[j + 1]; p[j + 1] = temp; } } } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", p[i]); } for (int i = 0; i &lt; num; i++) { if (p[i] != NULL) { free(p[i]); p[i] = NULL; } } if (p != NULL) { free(p); p = NULL; } return 0;} 二级指针做输入模型三封装函数：主函数：123456789101112int main(){ int num = 4; char **p = NULL; //p = getMem(num); getMem_1(&amp;p, num); //两种方式 printArray(p, num); SortArray(p, num); printArray(p, num); myArrayFree(p, num); return 0;} getMem函数:123456789101112131415161718192021222324252627char **getMem(int num){ char **p = NULL; p = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { p[i] = (char*)malloc(sizeof(char) * 100); sprintf(p[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } return p;}int getMem_1(char ***p, int num){ if (p == NULL) { return -1; } char **temp = NULL; temp = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { temp[i] = (char*)malloc(sizeof(char) * 100); sprintf(temp[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } *p = temp; return 0;} 打印函数：1234567void printArray(char **myArray, int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} 排序函数：12345678910111213141516void SortArray(char **myArray, int len){ char *temp = NULL; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { temp = myArray[j]; myArray[j] = myArray[j + 1]; myArray[j + 1] = temp; } } }} Free函数：12345678910111213141516void myArrayFree(char **p,int len){ for (int i = 0; i &lt; len; i++) { if (p[i] != NULL) { free(p[i]); p[i] = NULL; } } if (p != NULL) { free(p); p = NULL; }}","link":"/posts/20190911a1.html"},{"title":"最短路模板","text":"最短路问题中有很多的算法，dijkstra bellman_ford spfa floyd初学真的好难记（更不用说去看算法导论的详细证明了）。y总也总结了很多模板链接，自己再来总结一下加深记忆。另外安利y总算法课，讲的真的很好，我觉得收获很大，而且价格也很良心😂😂。 Dijkstra算法朴素版dijkstra适合稠密图思路1234集合S为已经确定最短路径的点集。1. 初始化距离一号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。2. 循环n次，每一次将集合S之外距离最短X的点加入到S中去（这里的距离最短指的是距离1号点最近。点X的路径一定最短，基于贪心，严格证明待看）。然后用点X更新X邻接点的距离。 时间复杂度分析寻找路径最短的点：O(n^2) 加入集合S：O(n) 更新距离：O(m) 所以总的时间复杂度为O(n^2) 具体题目稠密图用邻接矩阵存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 510, M = 10010;int g[N][N], dist[N];bool visited[N];int n, m;int dijkstra(){ memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 1; i &lt;= n; i++) { int t = -1; for(int j = 1; j &lt;= n; j++) { if(!visited[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } visited[t] = true; for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); memset(g, 0x3f, sizeof(g)); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); g[x][y] = min(g[x][y], c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;} 堆优化版dijkstra适合稀疏图思路123456堆优化版的dijkstra是对朴素版dijkstra进行了优化，在朴素版dijkstra中时间复杂度最高的寻找距离最短的点O(n^2)可以使用最小堆优化。1. 一号点的距离初始化为零，其他点初始化成无穷大。2. 将一号点放入堆中。3. 不断循环，直到堆空。每一次循环中执行的操作为： 弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。 用该点更新临界点的距离，若更新成功就加入到堆中。 时间复杂度分析寻找路径最短的点：O(n) 加入集合S：O(n) 更新距离：O(mlogn) 具体题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100010;// 稀疏图用邻接表来存int h[N], e[N], ne[N], idx;int w[N]; // 用来存权重int dist[N];bool st[N]; // 如果为true说明这个点的最短路径已经确定int n, m;void add(int x, int y, int c){ w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++;}int dijkstra(){ memset(dist, 0x3f, sizeof(dist)); dist[0] = 1; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(heap.size()) { PII k = heap.top(); // 取不在集合S中距离最短的点 heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n];}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;} Bellman_ford算法Bellman_ford可以解决有负权的图 思路12循环n次，在每一次的循环当中，遍历所有的边 a-&gt;b 权重为 w ，dist[b] = min(dist[b], dist[a] + w)。严格证明待看循环的次数是有实际的意义的，假如循环k次则 dist[x] 代表着从一号点不超过k条边（&lt;=k）的最短距离。 时间复杂度分析循环n次，每一次遍历m条边，所以时间复杂度为：O(nm) 具体题目 因为这道题在每一次迭代的过程中需要遍历所有的边，所以y总直接用的结构体数组存的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 510, M = 10010;struct Edge{ int x, y, c;}edges[M];int dist[N], backup[N];int n, m, k;int bellman_ford(){ memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 0; i &lt; k; i++) { memcpy(backup, dist, sizeof(dist)); for(int j = 1; j &lt;= m; j++) { int x = edges[j].x, y = edges[j].y, c = edges[j].c; if(dist[y] &gt; backup[x] + c) dist[y] = backup[x] + c; } } if(dist[n] &gt; 0x3f3f3f3f / 2) return -1; // 极端情况 dist[n] = 10000*498; else return dist[n];}int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= m; i++) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); //edges[i] = {x, y, c}; c++11 edges[i].x = x; edges[i].y = y; edges[i].c = c; } int ret = bellman_ford(); if(ret == -1) puts(\"impossible\"); else cout &lt;&lt; ret &lt;&lt; endl; return 0;} spfa算法思路12345678spfa算法实际上是对bellman_ford算法的优化。在bellman_ford当中会将所有的边进行松弛操作，但其实没有必要，其实只需用已经更新过距离的点去更新其他的点就好了。1. 初始化距离一号点距离为零，其他点设为无穷大2. 循环将一号点加入到队列中;while(队列不空) 取点;弹出;更新; 时间复杂度最好：O(m) 最坏：O(nm) 具体题目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 100010, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], idx;int w[N];int dist[N];bool st[N];int n, m;void add(int x, int y, int c){ e[idx] = y; w[idx] = c; ne[idx] = h[x]; h[x] = idx++;}int spfa(){ queue&lt;int&gt; q; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push(1); st[1] = true; while(q.size()) { int k = q.front(); q.pop(); st[k] = false; for(int i = h[k]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] &gt; dist[k] + w[i]) { dist[j] = dist[k] + w[i]; if(!st[j]) { st[j] = true; q.push(j); } } } } return dist[n];}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } int t = spfa(); if(t == INF) puts(\"impossible\"); else cout &lt;&lt; t; return 0;} spfa判断负环思路12","link":"/posts/20191124a1.html"}],"tags":[{"name":"c/c++","slug":"c-c","link":"/tags/c-c/"},{"name":"POJ","slug":"POJ","link":"/tags/POJ/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"哈希","slug":"哈希","link":"/tags/哈希/"},{"name":"蓝桥杯","slug":"蓝桥杯","link":"/tags/蓝桥杯/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"滚动数组","slug":"滚动数组","link":"/tags/滚动数组/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"}],"categories":[{"name":"浙大数据结构","slug":"浙大数据结构","link":"/categories/浙大数据结构/"},{"name":"c/c++","slug":"c-c","link":"/categories/c-c/"},{"name":"POJ","slug":"POJ","link":"/categories/POJ/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"PTA","slug":"PTA","link":"/categories/PTA/"},{"name":"AcWing蓝桥杯","slug":"AcWing蓝桥杯","link":"/categories/AcWing蓝桥杯/"},{"name":"AcWing算法基础","slug":"AcWing算法基础","link":"/categories/AcWing算法基础/"},{"name":"总结","slug":"总结","link":"/categories/总结/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"bug记录","slug":"bug记录","link":"/categories/bug记录/"},{"name":"刷题","slug":"刷题","link":"/categories/刷题/"},{"name":"蓝桥杯官网","slug":"刷题/蓝桥杯官网","link":"/categories/刷题/蓝桥杯官网/"}]}