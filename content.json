{"pages":[{"title":"about","text":"算法初学者","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"03-树2 List Leaves","text":"这道题花费了我四个小时，但是很开心一次AC，记录一下。花这么长时间的主要原因是，在第一次想的时候在构造树的结点的时候，没有加入结点的下标，导致后面越做越麻烦，好在及时修改，只花了4个小时😁😁。 题目描述Given a tree, you are supposed to list all the leaves in the order of top down, and left to right. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space. Output Specification:For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input:12345678981 -- -0 -2 7- -- -5 -4 6 Sample Output:14 1 5 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define Null -1#define MAXSIZE 10typedef struct BiTNode{ int lchild; int rchild; int index;}BiTNode;typedef BiTNode QElemType;typedef struct SqQueue{ QElemType Data[MAXSIZE]; int front; int rear;}SqQueue;int CreateBiTree(vector&lt;BiTNode&gt; &amp;v, int n, int &amp;leaves);void InitQueue(SqQueue &amp;Q);void AddQueue(SqQueue &amp;Q, BiTNode e);void DeleteQueue(SqQueue &amp;Q);bool QueueEmpty(SqQueue Q);bool QueueFull(SqQueue Q);int main(){ int n; cin &gt;&gt; n; int root; vector&lt;BiTNode&gt; v; int leaves = 0; root = CreateBiTree(v, n, leaves); SqQueue Q; InitQueue(Q); AddQueue(Q, v[root]); int cnt = 0; while (!QueueEmpty(Q)) { if (Q.Data[Q.front].lchild == Null &amp;&amp; Q.Data[Q.front].rchild == Null) { cnt++; if (cnt == leaves) cout &lt;&lt; Q.Data[Q.front].index; else cout &lt;&lt; Q.Data[Q.front].index &lt;&lt; \" \"; } int t = Q.Data[Q.front].index; DeleteQueue(Q); if (v[t].lchild != Null) AddQueue(Q, v[v[t].lchild]); if (v[t].rchild != Null) AddQueue(Q, v[v[t].rchild]); } return 0;}int CreateBiTree(vector&lt;BiTNode&gt; &amp;v, int n, int &amp;leaves){ char l, r; BiTNode tmp; vector&lt;int&gt; arr(n, 1); for (int i = 0; i &lt; n; i++) { tmp.index = i; cin &gt;&gt; l &gt;&gt; r; if (l == '-') tmp.lchild = Null; else { tmp.lchild = l - '0'; arr[tmp.lchild] = 0; } if (r == '-') tmp.rchild = Null; else { tmp.rchild = r - '0'; arr[tmp.rchild] = 0; } if (tmp.lchild == Null &amp;&amp; tmp.rchild == Null) leaves++; v.push_back(tmp); } int i = 0; for (; i &lt; n; i++) { if (arr[i] != 0) break; } return i;}void InitQueue(SqQueue &amp;Q){ Q.front = 0; Q.rear = 0;}void AddQueue(SqQueue &amp;Q, BiTNode e){ if (!QueueFull(Q)) { Q.Data[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXSIZE; }}void DeleteQueue(SqQueue &amp;Q){ if (!QueueEmpty(Q)) { Q.front = (Q.front + 1) % MAXSIZE; }}bool QueueEmpty(SqQueue Q){ if (Q.front == Q.rear) return true; return false;}bool QueueFull(SqQueue Q){ if ((Q.front + MAXSIZE - Q.rear) % MAXSIZE == 1) return true; return false;}","link":"/2019/10/24/03-树2-List-Leaves/"},{"title":"Cpp中成员函数与全局函数以及构造函数与析构函数的调用过程","text":"","link":"/2019/09/22/Cpp中成员函数与全局函数以及构造函数与析构函数的调用过程/"},{"title":"Cpp中数组类的实现以及操作符的重载","text":"Cpp中数组类的实现以及操作符的重载。。 Array.h12345678910111213141516171819202122#pragma onceclass Array{public: int mLength; int* mSpace;public: Array(int length); Array(const Array&amp; obj); int&amp; operator[](int i); Array&amp; operator=(Array &amp;obj); bool operator==(Array &amp;obj); bool operator!=(Array &amp;obj); int length(); void setData(int index, int value); int getData(int index); ~Array();}; main.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int main(){ //定义一个Array类型的啊对象并调用Array类的有参构造函数 Array a1(10); //对数组的元素进行初始化 for (int i = 0; i &lt; a1.length(); i++) { //a1.setData(i, i); //初步 a1[i] = i; //提升 []重载 } //对数组的元素进行输出 for (int i = 0; i &lt; a1.length(); i++) { //printf(\"array %d: %d\\n\", i, a1.getData(i)); //初步 cout &lt;&lt; a1[i]; } cout &lt;&lt; a1; // &lt;&lt;重载 //用a1对象初始化a2对象，调用a2对象的拷贝构造函数 //总结1 Array a2 = a1; for (int i = 0; i &lt; a2.length(); i++) { //printf(\"array %d: %d\\n\", i, a2.getData(i)); cout &lt;&lt; a1[i]; } Array a3(5); a3 = a1; //c++编译器提供的等号操作符为浅拷贝需重载 = //总结2 cout &lt;&lt; \"a3:\" &lt;&lt; a3; if (a1 == a3) { cout &lt;&lt; \"相等\" &lt;&lt; endl; } else { cout &lt;&lt; \"不相等\" &lt;&lt; endl; } if (a1 != a3) { cout &lt;&lt; \"不相等\" &lt;&lt; endl; } else { cout &lt;&lt; \"相等\" &lt;&lt; endl; } return 0;} 重载&lt;&lt;函数123456789ostream&amp; operator&lt;&lt;(ostream &amp;out, Array &amp;obj){ for (int i = 0; i &lt; obj.length(); i++) { //out &lt;&lt; obj.mSpace[i] &lt;&lt; \" \"; out &lt;&lt; obj[i] &lt;&lt; \" \"; } return out;} 成员函数实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768Array::Array(int length){ mLength = length; mSpace = new int[mLength];}Array::Array(const Array&amp; obj){ mLength = obj.mLength; mSpace = new int [mLength]; for (int i = 0; i &lt; mLength; i++) { mSpace[i] = obj.mSpace[i]; }}int Array::length(){ return mLength;}void Array::setData(int index, int value){ mSpace[index] = value;}int Array::getData(int index){ return mSpace[index];}Array::~Array(){ delete[] mSpace; mSpace = NULL; mLength = 0; }int&amp; Array::operator[](int i){ return this-&gt;mSpace[i];}Array&amp; Array::operator=(Array &amp;obj){ delete[] this-&gt;mSpace; this-&gt;mLength = 0; this-&gt;mLength = obj.mLength; this-&gt;mSpace = new int[mLength]; for (int i = 0; i &lt; mLength; i++) { mSpace[i] = obj[i]; } return *this;}bool Array::operator==(Array &amp;obj){ if (this-&gt;mLength != obj.mLength) { return false; } for (int i = 0; i &lt; mLength; i++) { if (mSpace[i] != obj[i]) { return false; } } return true;}bool Array::operator!=(Array &amp;obj){ return !(*this == obj);} 总结：拷贝构造函数的四种调用方法：1.Array a1(a2); 2.Array a1 = a2; 3.函数调用过程中，例如：main函数中调用f函数f(a1);，其中a1为Array类型的一个对象，f函数的声明为void f(Array a);这时函数的调用过程中会调用a对象的拷贝构造函数。 4.被调用函数的返回值是一个对象的时候，这时c++编译器会创建一个匿名对象，然后调用匿名对象的拷贝构造函数。而这个匿名对象的生命周期取决于主调用函数的接法，如果是类的初始化那么匿名对象转正，直到程序运行完成时才会调用析构函数，若是类的赋值，则在赋值完以后立马调用匿名对象的析构函数。 重载&lt;&lt;C++Primer第六页中说，&lt;&lt;运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象（也就是说cout是一个ostream类型的对象），右侧的运算对象是要打印的值。 使用过程中我们的输出语句可以使用多次&lt;&lt;运算符，因此&lt;&lt;运算符返回其左侧的运算对象（即ostream类型），这样才能保证第一次的运算结果能作为第二次&lt;&lt;运算符的左侧运算对象。有了这个前提之后我们在写&lt;&lt;运算符重载函数的时候，函数应返回本身（即返回一个引用），因此函数的声明应为ostream&amp; operator&lt;&lt;(ostream &amp;out, Array &amp;obj)。 运算符重载函数可以为全局函数也可以为成员函数，大部分情况下二者可以相互转换，以二元运算符为例，全局函数需要两个参数，左操作数与右操作数，而成员函数可通过this指针“隐藏”一个参数。但也有例外，在重载&lt;&lt;时必须使用成员函数，因为我们不能进入到ostream类中写成员函数。","link":"/2019/09/24/Cpp中数组类的实现以及操作符的重载/"},{"title":"Cpp类的基础练习：商店货物","text":"某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;using namespace std;class Goods{private: int weight; static int total_weight;public: Goods *pNext; Goods(int weight) { this-&gt;weight = weight; total_weight += weight; } //使用delete释放内存时会调用析构函数 ~Goods() { total_weight -= weight; } int GetWeight() { return weight; } static int GetTotalWeight() { return total_weight; }};int Goods::total_weight = 0;void menu(){ cout &lt;&lt; \"============================\" &lt;&lt; endl; cout &lt;&lt; \" 商店货物系统\" &lt;&lt; endl; cout &lt;&lt; \" 输入1购进\" &lt;&lt; endl; cout &lt;&lt; \" 输入2卖出\" &lt;&lt; endl; cout &lt;&lt; \" 输入0退出\" &lt;&lt; endl; cout &lt;&lt; \"============================\" &lt;&lt; endl;}//某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，//商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。void Purchase(Goods * &amp;Head, Goods * &amp;Tail,int weight){ Goods *pNew = new Goods(weight);//这个时候会调用pNew这个指针变量指向的对象的构造函数啊 pNew-&gt;pNext = NULL; if (Head == NULL &amp;&amp; Tail == NULL) { Head = Tail = pNew; } else { Tail-&gt;pNext = pNew; Tail = pNew; }}void Sale(Goods * &amp;Head){ if (Head == NULL) { cout &lt;&lt; \"没有货物!\" &lt;&lt; endl; return; } Goods *Temp = Head-&gt;pNext; delete Head; Head = Temp;}int main(){ Goods *Head = NULL; Goods *Tail = NULL; int choice = -1; int weight = 0; do { menu(); cin &gt;&gt; choice; //scanf(\"%d\", &amp;choice); ? ? ? switch (choice) { case 1: { cout &lt;&lt; \"请输入重量:\"; cin &gt;&gt; weight; Purchase(Head, Tail, weight); break; } case 2: { Sale(Head); break; } case 0:exit(0); break; default:cout &lt;&lt; \"输入错误,请重新输入!\" &lt;&lt; endl; break; } cout &lt;&lt; \"总重量为:\" &lt;&lt; Goods::GetTotalWeight() &lt;&lt; endl &lt;&lt; endl; } while (1); return 0;}","link":"/2019/09/20/Cpp类的基础练习：商店货物/"},{"title":"PTA数据结构与算法题目集(中文)6-5","text":"本题为无头结点的链表操作集","link":"/2019/09/08/PTA数据结构与算法题目集(中文)6-5/"},{"title":"Dungeon Master","text":"You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an escape possible? If yes, how long will it take? InputThe input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C. OutputEach maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the line Trapped! Sample Input123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample Output12Escaped in 11 minute(s).Trapped! 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, pair&lt;int, int&gt;&gt; PIII;const int N = 35;char g[N][N][N];bool vis[N][N][N];int l, r, c; // level row columnint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};int main(){ while (scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;c), l != 0 &amp;&amp; r != 0 &amp;&amp; c != 0) { // 输入地图 for (int i = 0; i &lt; l; i++) for (int j = 0; j &lt; r; j++) scanf(\"%s\", g[i][j]); queue&lt;PIII&gt; q; int step = 0; q.push({ 0, { 0, 0 } }); vis[0][0][0] = true; bool success = false; while (q.size()) { PIII k = q.front(); if (g[k.first][k.second.first][k.second.second] == 'E') { success = true; break; } q.pop(); for (int i = 0; i &lt; 4; i++) { int x = k.second.first + dx[i], y = k.second.first + dy[i]; if ((x == r || y == -1 || y == c) &amp;&amp; k.first &lt; l - 1) { int next_level = k.first + 1; if (x == r || g[next_level][x][y] == '.') { vis[next_level][0][y] = true; q.push({ next_level, { 0, y } }); step++; } else if (y == -1 || g[next_level][x][0] == '.') { vis[next_level][x][0] = true; q.push({ next_level, { x, 0 } }); step++; } else if (y == c || g[next_level][x][c - 1] == '.') { vis[next_level][x][0] = true; q.push({ next_level, { x, c - 1 } }); step++; } } else if (x &gt;= 0 &amp;&amp; g[k.first][k.second.first][k.second.second] == '.' &amp;&amp; !vis[k.first][k.second.first][k.second.second]) { vis[k.first][k.second.first][k.second.second] = true; q.push({ k.first, { k.second.first, k.second.second } }); step++; } } } if (success) cout &lt;&lt; step &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; } return 0;}","link":"/2019/12/09/Dungeon-Master/"},{"title":"X的因子链","text":"题目题目描述输入正整数$X$，求$X$的大于$1$的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，以及满足最大长度的序列的个数。 输入格式输入包含多组数据，每组数据占一行，包含一个正整数表示$X$。 输出格式对于每组数据，输出序列的最大长度以及满足最大长度的序列的个数。 每个结果占一行。 数据范围$1 \\le X \\le 2^{20}$ 输入样例： 23410100 输出样例： 1 11 12 12 24 6 题目链接 分析算数基本定理：任何一个大于$1$的自然数$N$,如果$N$不为质数，那么$N$可以唯一分解成有限个质数的乘积$N=P_1^{a_1}P_2^{a_2}P_3^{a_3}……P_n^{a_n}$，这里$P1&lt;P2&lt;P3……&lt;Pn$均为质数，其中指数$a_i$是正整数。 后一项能整除前一项，即后一项为前一项乘任意一个质因子$P_i$。最大长度由分解质因数可得，即$maxLength=\\sum\\limits_{n=1}^na_n$。 本题还问到了满足最长序列的个数，即求所有质因子的全排列，但由于其中有重复的元素，所以转换成多冲击组合数问题。（多重集组合数：一共有$k$种物品，每一种有$n_i$个，$1\\le i\\le k$，总共有$n$个物品，则$n$个物品的全排列为$\\frac{n!}{n_1!n_2!n_3!…n_k!}$） 用到的知识1.算数基本定理以及质因数分解 2.多重集组合数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = (1 &lt;&lt; 20) + 10;int x;int fact[30], sum[30];LL f(int n){ LL res = 1; for (int i = 1; i &lt;= n; i++) res *= i; return res;}int main(){ while (scanf(\"%d\", &amp;x) != EOF) { int k = 0; for (int i = 2; i &lt;= x / i; i++) { if (x % i == 0) fact[++k] = i; while (x % i == 0) { sum[k]++; x /= i; } } if (x != 1) fact[++k] = x, sum[k]++; int tot = 0; for (int i = 1; i &lt;= k; i++) tot += sum[i]; LL res = f(tot); for (int i = 1; i &lt;= k; i++) res /= f(sum[i]); cout &lt;&lt; tot &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl; memset(sum, 0, sizeof(sum)); } return 0;}","link":"/2020/02/10/X的因子链/"},{"title":"六度空间","text":"“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图所示。 “六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。 假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。 输入格式:输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤103，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。 输出格式:对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。 输入样例:1234567891010 91 22 33 44 55 66 77 88 99 10 输出样例：123456789101: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00% AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1010;int G[N][N], n, m;bool visited[N];int SDS(int i){ int cnt = 0; int level = 0, last = i, tail = -1; queue&lt;int&gt; q; visited[i] = true; q.push(i); cnt++; while (!q.empty()) { int k = q.front(); q.pop(); for (int j = 1; j &lt;= n; j++) { if (j == k) continue; if (!visited[j] &amp;&amp; G[k][j]) { q.push(j); tail = j; visited[j] = true; cnt++; } } if (k == last) { level++; last = tail; } if (level == 6) break; } return cnt;}int main(){ cin &gt;&gt; n &gt;&gt; m; while (m--) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); G[a][b] = 1; G[b][a] = 1; } for (int i = 1; i &lt;= n; i++) { int ret = SDS(i); printf(\"%d: %.2f\", i, (double)ret / n * 100); puts(\"%\"); memset(visited, false, sizeof(visited)); } return 0;}","link":"/2019/11/16/六度空间/"},{"title":"刷题总结1","text":"刷题总结第一篇。 乒乓球题目链接 很简单的一道题，但是从细节中也能看出很大的差距。 自己的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main(){ string s; string str; s += 'e'; bool flag = true; while(flag) { cin &gt;&gt; str; for(int i = 0; i &lt; str.size(); i++) { s += str[i]; if(str[i] == 'E') { flag = false; break; } } } int win = 0, lose = 0; for(int i = 1; i &lt; s.size() + 1; i++) { if(s[i] == 'W') win++; else if(s[i] == 'L') lose++; else ; int a = max(lose, win); int b = min(lose, win); if((a == 11 &amp;&amp; b &lt;= 9) || (b &gt;= 10 &amp;&amp; a &gt;= b + 2) || s[i] == 'E') { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } puts(\"\"); win = 0, lose = 0; for(int i = 1; i &lt; s.size() + 1; i++) { if(s[i] == 'W') win++; else if(s[i] == 'L') lose++; else ; int a = max(lose, win); int b = min(lose, win); if((a == 21 &amp;&amp; b &lt;= 19) || (b &gt;= 20 &amp;&amp; a &gt;= b + 2) || s[i] == 'E') { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } return 0;} y总的代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;void solve(string s, int score){ int win = 0, lose = 0; for(int i = 0; i &lt; s.size(); i++) { if(s[i] == 'W') win++; else lose++; if (max(win, lose) &gt;= score &amp;&amp; abs(win - lose) &gt;= 2) { printf(\"%d:%d\\n\", win, lose); win = lose = 0; } } printf(\"%d:%d\\n\", win, lose);}int main(){ string s; char c; while(cin &gt;&gt; c, c != 'E') s += c; solve(s, 11); puts(\"\"); solve(s, 21); return 0;} 总结while(cin &gt;&gt; c, c != 'E') s += c;这句话挺好的，以后可用。清晰的思路：遍历每一个字符，按照条件给某个变量++，直到这局结束，结束的条件，达到分制且分差大于2。 公交换乘简单的模拟题。 题目链接 自己的代码没写出来。。。 y总的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 100010;struct Point{ int price, time; bool used;}q[N];int n, res;int main(){ scanf(\"%d\", &amp;n); int Type, Price, Time; int hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) { scanf(\"%d%d%d\", &amp;Type, &amp;Price, &amp;Time); if(Type == 0) { res += Price; ++tt; q[tt].price = Price, q[tt].time = Time; } else { while(hh &lt;= tt &amp;&amp; Time - q[hh].time &gt; 45) hh++; bool success = false; for(int j = hh; j &lt;= tt; j++) { if(!q[j].used &amp;&amp; q[j].price &gt;= Price) { q[j].used = true; success = true; break; } } if(!success) res += Price; } } cout &lt;&lt; res &lt;&lt; endl; return 0;} 总结删掉某个结点不一定真的要删掉，可以开一个bool数组在对应的位置上标记。清晰的思路：要算总的花费，只有两种情况，要么坐地铁，要么坐公交。地铁一定会花钱，公交看有没有优惠券，能使用优惠券的条件：1.时间间隔小于等于45分钟，这个时候就应该想到滑动窗口。2.优惠券大于公交票钱。如有多张能用的优惠券用早的，想到队列。","link":"/2019/11/30/刷题总结1/"},{"title":"各种排序算法","text":"各种排序算法的总结 规定一个统一的接口: 123456template &lt;typename T&gt;void xxxx_sort(T *arr, int l, int r){ /* * 函数具体实现 */} 时间复杂度：O(n^2)冒泡排序123456789101112template &lt;typename T&gt;void bubble_sort(T *arr, int l, int r){ for (int i = r - 1; i &gt;= l; i--){ bool Swap = false; for (int j = l; j &lt;= i; j++) if (arr[j] &gt; arr[j + 1]){ swap(arr[j], arr[j + 1]); Swap = true; } if (!Swap) break; }} 插入排序1234template &lt;typename T&gt;void insert_sort(T *arr, int l, int r){} 选择排序12 时间复杂度：O(nlogn)快速排序1234567891011121314151617181920template &lt;typename T&gt;void quick_sort(T *arr, int l, int r){ if (l &gt;= r) return; int x = arr[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while (i &lt; j){ while (arr[++i] &lt; x) ; while (arr[--j] &gt; x) ; if (i &lt; j) swap(arr[i], arr[j]); } quick_sort&lt;int&gt;(arr, l, j); quick_sort&lt;int&gt;(arr, j + 1, r);} 归并排序123456789101112131415161718192021222324252627282930template &lt;typename T&gt;void merge_sort(T *arr, int l, int r){ T *tmp = new T[r - l + 1]; m_sort&lt;int&gt;(arr, tmp, l, r); delete tmp;}template &lt;typename T&gt;void m_sort(T *arr, T *tmp, int l ,int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; m_sort&lt;T&gt;(arr, tmp, l, mid); m_sort&lt;T&gt;(arr, tmp, mid + 1, r); int k = l; int i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r){ if (arr[i] &lt;= arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while (i &lt;= mid) tmp[k++] = arr[i++]; while (j &lt;= r) tmp[k++] = arr[j++]; for (int i = l; i &lt;= r; i++) arr[i] = tmp[i];}","link":"/2019/12/17/各种排序算法/"},{"title":"匈牙利算法","text":"匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。美国数学家哈罗德·库恩于1955年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家Dénes Kőnig和Jenő Egerváry的工作之上创建起来的。 —————百度百科 思路12 时间复杂夫具体题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, M = 100010;int n1, n2, m, res;int h[N], e[M], ne[M], idx;int match[N]; // 配对bool st[N];void add(int x, int y){ e[idx] = y; ne[idx] = h[x]; h[x] = idx++;}bool find(int x){ for(int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if(!st[j]) { st[j] = true; if(!match[j] || find(match[j])) { match[j] = x; return true; } } } return false;}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d%d\", &amp;n1, &amp;n2, &amp;m); while (m--) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); } for(int i = 1; i &lt;= n1; i++) { memset(st, false, sizeof(st)); if(find(i)) res++; } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2019/11/27/匈牙利算法/"},{"title":"归并排序","text":"题目链接 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N], tmp[N];int n;void merge_sort(int q[], int l, int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; } while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];}int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); merge_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0;}","link":"/2019/11/08/归并排序/"},{"title":"循环队列的操作","text":"​ 为充分利用向量空间，克服假溢出现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10#define ERROR 1#define OK 0typedef int Status;typedef int QueueElemType;typedef enum { false, true } bool;typedef struct{ QueueElemType *data; int front; int rear;}SqQueue;Status InitQueue(SqQueue **pQ);Status DestoryQueue(SqQueue *Q);Status ClearQueue(SqQueue *Q);bool QueueEmpty(SqQueue *Q);bool QueueFull(SqQueue *Q);Status GetHead(SqQueue *Q, QueueElemType *e);Status EnQueue(SqQueue *Q, QueueElemType e);Status DeQueue(SqQueue *Q, QueueElemType *e);void PrintALLQueue(SqQueue *Q);void PrintQueue(SqQueue *Q);int main() { int status = -1; SqQueue *Q = NULL; status = InitQueue(&amp;Q); if (status == ERROR) { printf(\"func InitQueue() error!\\n\"); } PrintALLQueue(Q); PrintQueue(Q); int choice = -1; int e = 0; while (1) { printf(\"1 添加 2 删除 0 退出\\n\"); scanf(\"%d\", &amp;choice); switch (choice) { case 1: printf(\"Please enter e:\"); scanf(\"%d\", &amp;e); status = EnQueue(Q, e); if (status == ERROR) { printf(\"FULL!\\n\"); } PrintALLQueue(Q); PrintQueue(Q); break; case 2: status = DeQueue(Q, &amp;e); if (status == ERROR) { printf(\"EMPTY!\\n\"); } else printf(\"The number is %d.\\n\", e); PrintALLQueue(Q); PrintQueue(Q); break; case 0:exit(0); } } DestoryQueue(Q); Q = NULL; return 0;}Status InitQueue(SqQueue **pQ){ SqQueue *Q; Q = (SqQueue*)malloc(sizeof(SqQueue)); if(Q == NULL) { printf(\"分配内存失败!\\n\"); return ERROR; } Q-&gt;data = (QueueElemType*)malloc(MAXSIZE * sizeof(QueueElemType)); if (Q-&gt;data == NULL) { printf(\"分配内存失败!\\n\"); return ERROR; } Q-&gt;front = 0; Q-&gt;rear = 0; *pQ = Q; return OK;} Status DestoryQueue(SqQueue *Q){ if (Q-&gt;data != NULL) { free(Q-&gt;data); Q-&gt;data = NULL; return OK; } else return ERROR;}Status ClearQueue(SqQueue *Q){ Q-&gt;front = 0; Q-&gt;rear = 0; return OK;}bool QueueEmpty(SqQueue *Q){ if (Q-&gt;front == Q-&gt;rear) return true; else return false;}bool QueueFull(SqQueue *Q){ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) return true; else return false;}Status GetHead(SqQueue *Q, QueueElemType *e){ if (QueueEmpty(Q) == true) { return ERROR; } else *e = Q-&gt;data[Q-&gt;front]; return OK;}Status EnQueue(SqQueue *Q, QueueElemType e){ if (QueueFull(Q) == true) return ERROR; Q-&gt;data[Q-&gt;rear] = e; Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; return OK;}Status DeQueue(SqQueue *Q, QueueElemType *e){ if (QueueEmpty(Q) == true) { return ERROR; } *e = Q-&gt;data[Q-&gt;front]; Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; return OK;}Status QueueLength(SqQueue *Q, int *length){ *length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE; return OK;}void PrintALLQueue(SqQueue *Q){ for (int i = 0; i &lt; MAXSIZE; i++) { printf(\"%d \", Q-&gt;data[i]); } putchar('\\n');}void PrintQueue(SqQueue *Q){ int status = -1; int length = 0; QueueLength(Q, &amp;length); for (int i = 0; i &lt; length; i++) { printf(\"%d \", (Q-&gt;data[(Q-&gt;front + i) % MAXSIZE])); } putchar('\\n');}","link":"/2019/09/06/循环队列的操作/"},{"title":"快速排序","text":"题目链接 快速排序的模板： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 1e5;int q[N];int n;void quick_sort(int q[], int l, int r){ if(l &gt;= r) return; int x = q[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while(i &lt; j) { while(q[++i] &lt; x) ; while(q[--j] &gt; x) ; if(i &lt; j) swap(q[i], q[j]); } quick_sort(q, l ,j); quick_sort(q, j + 1, r);}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); quick_sort(q, 0, n - 1); for(int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0;}","link":"/2019/10/28/快速排序/"},{"title":"bug记录","text":"本文将记录以后遇到的bug及解决的方法（因为我觉得这个东西很有必要写，有的时候就简单的一个地方就要debug好久😭😭） CRT detected that the application wrote to memory after end of heap buffer我服了看了这么长时间竟然是数组越界，我从下标1开始了。😂 Stack overflow递归时没有写递归出口。 result_pointer!=nullptrscanf &amp;&amp;&amp;&amp;&amp;&amp; if else写了这么多的if else没想到居然还会再这种地方出现问题😱。写成了： 1234if(true) if(true) func();else if(true) func1(); 呆呆呆呆 二维字符数组的初始化定义了一个全局的二维数组g[5][5]。 在函数中初始化时写成了g[5][5] = .......","link":"/2019/10/06/报错记录/"},{"title":"拯救007","text":"Saving James Bond - Easy Version This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape. Input Specification:Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position. Output Specification:For each test case, print in a line “Yes” if James can escape, or “No” if not. Sample Input 1:12345678910111213141514 2025 -15-25 288 4929 15-35 -25 2827 -29-8 -28-20 -35-25 -20-13 29-30 15-35 4012 12 Sample Output 1:1Yes Sample Input 2:123454 13-12 1212 12-12 -1212 -12 Sample Output 2:1No AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100;PII vertex[N];bool visited[N], flag;int n, D;bool isSafe(PII v){ if (v.first == 0 &amp;&amp; v.second == 0) return D &gt; 50 - 7.5; return D &gt;= 50 - abs(v.first) || D &gt;= 50 - abs(v.second);}double distance(PII a, PII b) { return sqrt((a.first-b.first)*(a.first - b.first)+(a.second-b.second)*(a.second - b.second));}bool canJump(PII a, PII b){ if (a.first == 0 &amp;&amp; a.second == 0) return D + 7.5 &gt;= distance(a, b); else return D &gt;= distance(a, b);}bool DFS(PII v){ if (isSafe(v)) return true; for (int i = 0; i &lt; n; i++) { if (!visited[i] &amp;&amp; canJump(v, vertex[i])) { visited[i] = true; // return DFS(vertex[i]); flag = DFS(vertex[i]); if (flag) return true; } } return false;}int main(){ cin &gt;&gt; n &gt;&gt; D; for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;vertex[i].first, &amp;vertex[i].second); if (DFS({ 0, 0 })) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; system(\"pause\"); return 0;}","link":"/2019/11/16/拯救007/"},{"title":"数的范围","text":"题目链接 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); while (m--) { int x; scanf(\"%d\", &amp;x); int l = 0, r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (q[mid] &gt;= x) r = mid; else l = mid + 1; } if (q[l] != x) cout &lt;&lt; \"-1 -1\" &lt;&lt; endl; else { cout &lt;&lt; l &lt;&lt; \" \"; l = 0, r = n - 1; while (l &lt; r) { int mid = l + r + 1&gt;&gt; 1; if (q[mid] &lt;= x) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; } } return 0;}","link":"/2019/11/08/数的范围/"},{"title":"数组指针类型与函数指针类型","text":"由于数组类型与函数类型的定义方法很类似，因此放到一起。 数组指针数组类型的定义12345678910typedef int (myArrayType)[10];int main(){ int a[10]; myArrayType b;//等价于int b[10]; a[0] = 1; b[0] = 1; cout &lt;&lt; a[0] &lt;&lt; \" \" &lt;&lt; b[0] &lt;&lt; endl; return 0;} 输出结果： 数组指针类型的定义12345678910typedef int(*myPArrayType)[10];int main(){ int a[10]; a[0] = 1; myPArrayType p; p = &amp;a; cout &lt;&lt; (*p)[0] &lt;&lt; endl; return 0;} 输出结果： myPArrayType是数组的地址，而a是数组首元素的地址，因此myPArrayType相当于一个二级指针。 说到数组指针就不得不提一下指针数组，初学指针与数组时很容易混淆这两个概念，但其实也很好理解。数组指针可以念成数组的指针，也就是说本质上是一个指针，只是该指针指向的是一个数组罢了，也就是上面这个例子。而指针数组又可以念成指针的数组，顾名思义本质上是一个数组，只不过数组的元素是指针。 另外值得注意的是a+1与&amp;a+1完全不同，指针+1的步长取决于指针所指的数据类型，a指的是int类型因此向后移动四个字节，而&amp;a指向的是一个数组因此向后移动四十个字节。 函数指针通过函数类型定义函数指针123456789typedef int (myFuncType)(int);int main(){ int a = 5; myFuncType *Func; Func = &amp;add; cout &lt;&lt; Func(a) &lt;&lt; endl; return 0;} 输出结果： 直接定义函数指针类型12345678910typedef int (*myPFuncType)(int);int main(){ int a = 5; myPFuncType Func; //Func = &amp;add; //加不加取地址号都可以 为什么呢？？？？？？ Func = add; cout &lt;&lt; Func(a) &lt;&lt; endl; return 0;} 输出结果：","link":"/2019/10/02/数组指针类型与函数指针类型/"},{"title":"数组模板类(MyVector)","text":"实现非常简单的数组模板类（MyVector）中用到了泛型编程（模板类编程）、运算符重载、友元函数等知识，最重要的是加深了对内存分配的理解。 所有容器提供的都是值（value）语意，而非引用（reference）语意。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（必须提供拷贝构造函数）。 开始的时候不理解这句话，然后自己敲代码就理解了。我们在往容器里存数据的时候，是进行拷贝动作，也就是说将外部变量的值拷贝给容器中的值。要进行拷贝就必须分配内存，没有分配内存的话往哪拷数据呢？？？？而基础数据类型的变量是不用担心这些问题的，因为当我们写下int a时编译器已经为a分配了内存，但是如果是指针变量就必须考虑深拷贝与浅拷贝的问题（其实这个地方第一次的时候我想的是，MyVector不是已经分配了内存了吗，为什么还要分配呢？其实在MyVector中是给类分配了内存说白了就是给类中的成员变量分配了内存，而成员变量若有指针的话，它只是为指针分配了内存，而我们所需要的是分配指针所指向的内存空间分配内存）。 MyVector.h12345678910111213141516171819#pragma once#include&lt;iostream&gt;using namespace std;template &lt;typename Type&gt;class MyVector{ friend ostream&amp; operator&lt;&lt; &lt;Type&gt; (ostream &amp;out, const MyVector &amp;obj); //在泛型编程当中，类模板中避免使用友元函数，除了重载 \"&lt;&lt;\" \"&gt;&gt;\" 左移右移运输算符，其他的函数都写成成 //员函数public: MyVector(int len); MyVector(const MyVector &amp;obj); ~MyVector();public: MyVector&amp; operator=(const MyVector &amp;obj); Type&amp; operator[](int index);private: Type *mSpace; int len;}; MyVector.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;#include\"MyVector.h\"template &lt;typename Type&gt;MyVector&lt;Type&gt;::MyVector(int len){ this-&gt;len = len; mSpace = new Type[len];}template &lt;typename Type&gt;MyVector&lt;Type&gt;::MyVector(const MyVector &amp;obj){ this-&gt;len = obj.len; mSpace = new Type[len]; for (int i = 0; i &lt; len; i++) { mSpace[i] = obj.mSpace[i]; }}template &lt;typename Type&gt;MyVector&lt;Type&gt;::~MyVector(){ if (mSpace != NULL) { delete[] mSpace; mSpace = NULL; len = 0; }}template &lt;typename Type&gt;MyVector&lt;Type&gt;&amp; MyVector&lt;Type&gt;::operator=(const MyVector&lt;Type&gt; &amp;obj){ if (mSpace != NULL) { delete[] mSpace; mSpace = NULL; len = 0; } this-&gt;len = obj.len; mSpace = new Type[len]; for (int i = 0; i &lt; len; i++) { mSpace[i] = obj.mSpace[i]; } return *this;}template &lt;typename Type&gt;Type&amp; MyVector&lt;Type&gt;::operator[](int index){ return mSpace[index];}template &lt;typename Type&gt;ostream&amp; operator&lt;&lt;(ostream &amp;out, const MyVector&lt;Type&gt; &amp;obj){ for (int i = 0; i &lt; obj.len; i++) { cout &lt;&lt; obj.mSpace[i]; } cout &lt;&lt; endl; return out;} main.cpp测试int型 123456789101112int main(){ MyVector&lt;int&gt; arr1(10); for (int i = 0; i &lt; 10; i++) { arr1[i] = i + 1; } cout &lt;&lt; arr1 &lt;&lt; endl; MyVector&lt;int&gt; arr2 = arr1; cout &lt;&lt; arr2 &lt;&lt; endl; return 0;} 测试char 型 123456789101112int main02(){ MyVector&lt;char&gt; str1(10); for (int i = 0; i &lt; 10; i++) { str1[i] = 'a' + i; } cout &lt;&lt; str1 &lt;&lt; endl; MyVector&lt;char&gt; str2 = str1; cout &lt;&lt; str2 &lt;&lt; endl; return 0;} 测试Teacher类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//Teacher类中名字是字符数组，即在栈上分配内存。class Teacher{ friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Teacher &amp;obj);public: Teacher() { age = 0; strcpy(name, \"\"); } Teacher(const char *name,int age) { strcpy(this-&gt;name, name); this-&gt;age = age; } void printT() { cout &lt;&lt; \"name:\" &lt;&lt; name &lt;&lt; \" age:\" &lt;&lt; age &lt;&lt; endl; } //栈上分配的内存还用我去释放？ 我傻了 -_- //~Teacher() //{ // if (name != NULL) // { // delete name; // name = NULL; // age = 0; // } //}private: char name[16]; char *name; int age;};ostream&amp; operator&lt;&lt;(ostream&amp; out, Teacher &amp;obj){ out &lt;&lt; obj.name &lt;&lt; \" \" &lt;&lt; obj.age &lt;&lt; endl; return out;}//Teacher中名字是一个指针，即需要我们手动分配内存否则会出现程序宕掉的情况。class Teacher{ friend ostream&amp; operator&lt;&lt;(ostream &amp;out, Teacher &amp;obj) { out &lt;&lt; \"name:\" &lt;&lt; obj.name &lt;&lt; \" age:\" &lt;&lt; obj.age &lt;&lt; endl; return out; }public: //这样的话可以不写无参构造函数吗 经测试可以 那还要无参构造函数干嘛呢？？？ Teacher(const char *name = \"\", int age = 0) { //这个地方要吗？ this-&gt;age = age; this-&gt;name = new char[strlen(name) + 1];//还有\\0 strcpy(this-&gt;name, name); } Teacher(const Teacher &amp;obj) { this-&gt;age = obj.age; name = new char[strlen(obj.name) + 1]; strcpy(name, obj.name); } ~Teacher() { if (name != NULL) { delete[] name; name = NULL; age = 0; } }public: Teacher&amp; operator=(const Teacher &amp;obj) { this-&gt;age = obj.age; this-&gt;name = new char[strlen(obj.name) + 1]; strcpy(name, obj.name); return *this; } void printT() { cout &lt;&lt; \"name:\" &lt;&lt; name &lt;&lt; \" age:\" &lt;&lt; age &lt;&lt; endl; }private: char *name; int age;};int main(){ MyVector&lt;Teacher&gt; tArray(3); Teacher t1(\"123\", 30); Teacher t2(\"456\", 31); Teacher t3(\"789\", 32); tArray[0] = t1; tArray[1] = t2; tArray[2] = t3; Teacher t4; for (int i = 0; i &lt; 3; i++) { Teacher tmp = tArray[i]; tmp.printT(); } cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; tArray &lt;&lt; endl; return 0;}","link":"/2019/10/05/数组模板类-MyVector/"},{"title":"最小生成树模板","text":"最小生成树也是图论中的一类问题。最小生成树问题最终要求出使所有点连通的最短距离，典型问题为修公路问题。 Prim算法适合稠密图 思路12345Prim算法与Dijkstra算法有很多相似之处。1. 初始化距离，与Dijkstra算法不同的是Prim算法要将所有点的距离初始化正无穷。2. 循环n次 每一次找到不在生成树中距离最小的点（这里的距离指的是距离集合的距离而Dijkstra指的是到一号点的距离） 再用这个点更新临界点的距离。 时间复杂度具体题目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int g[N][N], dist[N];bool st[N];int n, m, res;int prim(){ memset(dist, 0x3f, sizeof(dist)); // 循环n次 for(int i = 0; i &lt; n; i++) { // 寻找集合以外距离最小的点 int t = -1; for(int j = 1; j &lt;= n; j++) { if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; } st[t] = true; // 如果这个点不是第一个点并且距离最短的点为正无穷 则不连通 直接返回false if (i &amp;&amp; dist[t] == INF) return INF; // 如果这个点不是第一个点则加到最终的答案中 if (i) res += dist[t]; for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]); } return res;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if (i == j) g[i][j] = 0; else g[i][j] = INF; while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); g[x][y] = g[y][x] = min(g[x][y], c); } int ret = prim(); if(ret == INF) puts(\"impossible\"); else cout &lt;&lt; ret; return 0;} Kruskal算法思路12341. 排序 将所有的边按照权重排序2. 遍历所有的边 a-&gt;b 权重为 w 如果 a b 不在同一个集合 则合并 考察并查集的知识 时间复杂度主要在排序的过程：O(mlogm) 具体题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100010, M = 200010;// 因为只需遍历所有的边所以可以用一个简单的结构体数组，来存储边struct Edge{ int x, y, c; // 运算符重载 据我的我猜测sort内部实现的时候用的是 &lt; 然后结构体不是基本数据类型 所以要重载 // c++中 class与struct 定义类可以互换 只是 在默认情况下 struct为public class为private // 这个东西估计要看侯捷的《STL源码剖析》吧。 bool operator&lt; (const Edge &amp;obj) const { return c &lt; obj.c; }}edges[M];int p[N];int n, m, cnt, res;int find(int x){ // 路径压缩 if(x != p[x]) p[x] = find(p[x]); return p[x];}bool kruskal(){ sort(edges, edges + m); // 初始化并查集 for(int i = 1; i &lt;= n; i++) p[i] = i; for(int i = 0; i &lt; m; i++) { int x = edges[i].x, y = edges[i].y, c = edges[i].c; int a = find(x), b = find(y); if(a != b) { p[a] = b; res += c; cnt++; } } if(cnt &lt; n - 1) return false; return true;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); //edges[i] = {x, y, c}; c11 edges[i].x = x; edges[i].y = y; edges[i].c = c; } if(kruskal()) cout &lt;&lt; res &lt;&lt; endl; else puts(\"impossible\"); return 0;}","link":"/2019/11/26/最小生成树模板/"},{"title":"染色法判定二分图","text":"二分图： 一个无向图，使得顶点集V可以分割为两个互不相交的子集A,B，使得所有边两端分别属于两个子集A,B。 思路1遍历每一个点，从每一个点开始进行深搜，深搜的过程中进行染色。 时间复杂度具体题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N = 100010, M = 200010;int h[N], e[M], ne[M], idx;int color[N]; // 0代表还没染色 染成 1和2int n, m;void add(int x, int y){ e[idx] = y; ne[idx] = h[x]; h[x] = idx++;}bool dfs(int u, int c){ color[u] = c; // 染色 for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if(!color[j]) { if(!dfs(j, 3 - c)) return false; } else if(color[j] == c) return false; } return true;}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y), add(y, x); } bool success = true; for(int i = 0; i &lt; n; i++) { if(!color[i]) if(!dfs(i, 1)) // 如果从i开始染色的过程中出现了矛盾 那么失败 { success = false; break; } } if(success) puts(\"Yes\"); else puts(\"No\"); return 0;}","link":"/2019/11/27/染色法判定二分图/"},{"title":"树的同构","text":"每次做课后布置的题就要做好久，这个题老师讲的时候用的是C语言，我想用C++中的vector做发现做的过程中遇到了许多的问题，老是出现程序宕掉的问题，但让我十分开心的是，改完以后居然一次就AC了别提有多激动了，不过这代码只是完成了功能，可读性做的很差，尤其是判断同构的函数，但是以后回过头来看还是很有意思的吧😂😂。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define Null -1typedef char ElemType;struct TreeNode{ ElemType Data; int lchild; int rchild;};int TreeCreate(vector&lt;TreeNode&gt; &amp;t, int n);bool isomorphic(vector&lt;TreeNode&gt; &amp;t1, int t1Root, vector&lt;TreeNode&gt; &amp;t2, int t2Root);int t1Root;int t2Root;int main(){ int n; cin &gt;&gt; n; vector&lt;TreeNode&gt; t1(n); t1Root = TreeCreate(t1, n); cin &gt;&gt; n; vector&lt;TreeNode&gt; t2(n); t2Root = TreeCreate(t2, n); if (isomorphic(t1, t1Root, t2, t2Root)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;}int TreeCreate(vector&lt;TreeNode&gt; &amp;t, int n){ int root = -1; vector&lt;int&gt; arr(n, 1); for (int i = 0; i &lt; n; i++) { char cl, cr; cin &gt;&gt; t[i].Data &gt;&gt; cl &gt;&gt; cr; if (cl == '-') t[i].lchild = Null; else { t[i].lchild = cl - '0'; arr[t[i].lchild] = 0; } if (cr == '-') t[i].rchild = Null; else { t[i].rchild = cr - '0'; arr[t[i].rchild] = 0; } } for (int i = 0; i &lt; n; i++) { if (arr[i] != 0) { root = i; break; } } return root;}//要明确的一点是Null指的是树的存储结构为数组的下标 下标是从零开始 所以左儿子或者右儿子 为Null 即没有bool isomorphic(vector&lt;TreeNode&gt; &amp;t1, int t1Root, vector&lt;TreeNode&gt; &amp;t2, int t2Root){ if (t1Root == Null &amp;&amp; t2Root == Null) return true; else if ((t1Root != Null &amp;&amp; t2Root == Null) || (t1Root == Null &amp;&amp; t2Root != Null)) return false; else if (t1[t1Root].Data != t2[t2Root].Data) return false; else if (t1[t1Root].lchild == Null &amp;&amp; t2[t2Root].lchild == Null) return isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].rchild); else if ((t1[t1Root].lchild != Null &amp;&amp; t2[t2Root].lchild != Null) &amp;&amp; (t1[t1[t1Root].lchild].Data == t2[t2[t2Root].lchild].Data)) return isomorphic(t1, t1[t1Root].lchild, t2, t2[t2Root].lchild) &amp;&amp; isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].rchild); else return isomorphic(t1, t1[t1Root].rchild, t2, t2[t2Root].lchild)&amp;&amp; isomorphic(t1, t1[t1Root].lchild, t2, t2[t2Root].rchild);}","link":"/2019/10/23/树的同构/"},{"title":"棋盘问题","text":"在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 Input输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output1221 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10;char g[N][N];bool rows[N], cols[N];int n, k, ans;void dfs(int x, int y, int s){ if (y == n) y = 0, x++; if (x == n) { if (s == k) ans++; return; } // 不选 dfs(x, y + 1, s); // 选 if (!rows[x] &amp;&amp; !cols[y] &amp;&amp; g[x][y] == '#') { rows[x] = cols[y] = true; dfs(x, y + 1, s + 1); rows[x] = cols[y] = false; }}int main(){ while (scanf(\"%d%d\", &amp;n, &amp;k), n != -1 &amp;&amp;k != -1) { for (int i = 0; i &lt; n; i++) scanf(\"%s\", g[i]); dfs(0, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; memset(g, 0, sizeof(g)); ans = 0; } return 0;}","link":"/2019/12/07/棋盘问题/"},{"title":"滚动数组","text":"一维数组老生常谈的斐波那契数列。 1 1 2 3 5 8 13 21 ….编写一个函数，输入n，返回第n个数(n &lt;= 50)。(实测当 n = 47 爆int) 12345678910111213// 不使用滚动数组LL fib(int n){ LL fibnacci[55]; fibnacci[0] = fibnacci[1] = 1; if (n == 0 || n == 1) return 1; for (int i = 2; i &lt;= n; i++) fibnacci[i] = fibnacci[i - 1] + fibnacci[i - 2]; return fibnacci[n];} 12345678910111213141516171819// 使用滚动数组// 在求第n个数时，只用到了前面两个值，所以只需开一个长度为三的数组。LL fib(int n){ LL fibnacci[3]; fibnacci[0] = fibnacci[1] = 1; if (n == 0 || n == 1) return 1; while (n - 1) { n--; fibnacci[2] = fibnacci[0] + fibnacci[1]; fibnacci[0] = fibnacci[1]; fibnacci[1] = fibnacci[2]; } return fibnacci[2];} 二维数组递推关系f[i][j] = f[i - 1][j] + f[i - 1][j - x] (其中 x &gt; 0) 编写一个函数，输入a，b，输出f[a][b]。(i, j &lt;= 50) 123456789101112131415161718// 不使用滚动数组// 第0行与第0列为递推的出口int f[50][50], x = 2;void init(){ for (int i = 0; i &lt; 50; i++) f[0][i] = 1;}int func(int a, int b){ init(); for (int i = 1; i &lt;= a; i++) for (int j = 1; j &lt;= b; j++) if (j &gt;= x) f[i][j] = f[i - 1][j] + f[i - 1][j - x]; return f[a][b];} 123456789101112131415161718192021// 使用滚动数组// 在求f[i][j]时只用到了前面一行所以可以使用滚动数组int f[2][50];void init(){ for(int i = 0; i &lt; 50; i++) f[0][i] = 1;}int func(int a, int b){ init(); for (int i = 1; i &lt;= a; i++) { for (int j = 0; j &lt; 50; j++) f[i % 2][j] = 0; // 这个地方很重要 一开始我没有想到 打印时才发现问题 for (int j = 1; j &lt;= b; j++) if (j &gt;= x) f[i % 2][j] = f[1 - i % 2][j] + f[1 - i % 2][j - x]; // 第1行使用第0行，第0行使用第1行 } return f[a % 2][b];}","link":"/2019/12/15/滚动数组/"},{"title":"电话聊天狂人","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/*#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 400009, null = -1;LL h[N];int sum[N];int n, ans, cnt;LL ansNum[N];void insert(LL x){ int a = x % N; while (h[a] != null &amp;&amp; h[a] != x) { a++; if (a == N) a = 0; } sum[a]++; if (sum[a] == ans) ansNum[cnt++] = x; else if (sum[a] &gt; ans) { ans = sum[a]; if (ans == 0) ansNum[cnt++] = x; else { memset(ansNum, 0, sizeof(ansNum)); cnt = 0; ansNum[cnt++] = x; } } h[a] = x;}int main(){ memset(h, -1, sizeof(h)); cin &gt;&gt; n; while (n--) { LL from, to; scanf(\"%lld%lld\", &amp;from, &amp;to); insert(from), insert(to); } if (cnt == 1) printf(\"%lld %d\\n\", ansNum[0], ans); else { LL min = 1e12; for (int i = 0; i &lt; cnt; i++) if (ansNum[i] &lt; min) min = ansNum[i]; printf(\"%lld %d %d\", min, ans, cnt); } return 0;}*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; typedef struct ListNode *Position;typedef struct ListNode{ char PhoneNum[12]; int cnt; Position Next;} *List; typedef struct HashTbl{ int TableSize; List *TheLists;//建立一个ListNode的指针数组} *HashTable; int NextPrime(int x);HashTable InitializeTable(int TableSize);void DestroyTable(HashTable H);Position Find(char Key[], HashTable H);void Insert(char Key[], HashTable H);int Hash(int Key, int TableSize);void FindMax(HashTable H); int main(int argc, char const *argv[]){ // freopen(\"test.txt\", \"r\", stdin); int N; scanf(\"%d\", &amp;N); HashTable H = InitializeTable(2 * N); char send[12], rec[12]; for (int i = 0; i &lt; N; i++){ scanf(\"%s %s\\n\", send, rec); Insert(send, H), Insert(rec, H); } FindMax(H); DestroyTable(H); return 0;} int NextPrime(int x){ int i; for (int Next = x; ; Next++){ for (i = 2; i * i &lt;= Next; i++) if (Next % i == 0) break; if (i * i &gt; Next) return Next; }} HashTable InitializeTable(int TableSize){ HashTable H; H = (HashTable)malloc(sizeof(struct HashTbl)); H-&gt;TableSize = NextPrime(TableSize); H-&gt;TheLists = (List*)malloc(sizeof(List)*H-&gt;TableSize); for (int i = 0; i != H-&gt;TableSize; i++){ H-&gt;TheLists[i] = (List)malloc(sizeof(struct ListNode)); H-&gt;TheLists[i]-&gt;Next = NULL; } return H;} void DestroyTable(HashTable H){ for (int i = 0; i &lt; H-&gt;TableSize; i++) free(H-&gt;TheLists[i]); free(H-&gt;TheLists); free(H);} Position Find(char Key[], HashTable H){ Position P; List L; L = H-&gt;TheLists[Hash(atoi(Key + 6), H-&gt;TableSize)]; P = L-&gt;Next; while (P != NULL &amp;&amp; strcmp(P-&gt;PhoneNum, Key)) P = P-&gt;Next; return P;} void Insert(char Key[], HashTable H){ Position Pos, Tmp; List L = H-&gt;TheLists[Hash(atoi(Key + 6), H-&gt;TableSize)]; Pos = Find(Key, H); if (Pos == NULL){ Tmp = (List)malloc(sizeof(struct ListNode)); strcpy(Tmp-&gt;PhoneNum, Key); Tmp-&gt;cnt = 1; Tmp-&gt;Next = L-&gt;Next; L-&gt;Next = Tmp; } else { (Pos-&gt;cnt)++; }} int Hash(int Key, int TableSize){ return (Key % TableSize);} void FindMax(HashTable H){ Position P; int maxcnt = 0, maxSame = 1; char MinPhone[12]; for (int i = 0; i &lt; H-&gt;TableSize; i++){ P = H-&gt;TheLists[i]-&gt;Next; while (P != NULL){ if (P-&gt;cnt &gt; maxcnt){ strcpy(MinPhone, P-&gt;PhoneNum); maxcnt = P-&gt;cnt; maxSame = 1; } else if (P-&gt;cnt == maxcnt){ if (strcmp(MinPhone, P-&gt;PhoneNum) &gt; 0) strcpy(MinPhone, P-&gt;PhoneNum); maxSame++; } P = P-&gt;Next; } } printf(\"%s %d\", MinPhone, maxcnt); if (maxSame &gt; 1) printf(\" %d\", maxSame);}","link":"/2019/12/16/电话聊天狂人/"},{"title":"电影","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define N 200010using namespace std;map&lt;int,int&gt;s;int a[N];int b[N];struct zz{ int a; int b;}p[N];int main(){ int n,m,i,j,k; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); //s用来统计a[i]的个数 s[a[i]]++; } scanf(\"%d\",&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d\",&amp;p[i].a); for(i=1;i&lt;=m;i++) scanf(\"%d\",&amp;p[i].b); int mm=0;k=1; for(i=1;i&lt;=m;i++) { //统计出现次数最多的语言的个数,并记录其在语音列表中---第一次出现-----的位置 if(mm&lt;s[p[i].a]) { mm=s[p[i].a]; k=i; } } //统计 int kk=0; for(i=1;i&lt;=m;i++) { //在mm相等的情况下，比较s[p[i].b]。记录s[p[i].b]最大的位置 if(s[p[i].a]==mm) { if(kk&lt;s[p[i].b]) { kk=s[p[i].b]; k=i; } } } printf(\"%d\\n\",k); return 0;}","link":"/2020/02/07/电影/"},{"title":"第K个数","text":"题目链接 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n, k;int quick_sort(int q[], int l, int r, int k){ if(l == r) return q[l]; int x = q[l + r &gt;&gt; 1]; int i = l - 1, j = r + 1; while(i &lt; j) { while(q[++i] &lt; x) ; while(q[--j] &gt; x) ; if(i &lt; j) swap(q[i], q[j]); } int sl = j - l + 1; if(sl &gt;= k) return quick_sort(q, l, j, k); else return quick_sort(q, j + 1, r, k - sl);}int main(){ cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); cout &lt;&lt; quick_sort(q, 0, n-1, k); //quick_sort直接返回第K个数 return 0;} asssdfdfsdfs sdfsfejdfdsdgsdg dg ff ffffff dgd dgdfgdf","link":"/2019/11/07/第K个数/"},{"title":"等差数列","text":"题目题目描述数学老师给小明出了一道等差数列求和的题目。 但是粗心的小明忘记了一部分的数列，只记得其中$N$个整数。 现在给出这$N$个整数，小明想知道包含这$N$个整数的最短的等差数列有几项？ 输入格式输入的第一行包含一个整数$N$。 第二行包含$N$个整数$A_1$,$A_2$,⋅⋅⋅,$A_N$。(注意$A_1$∼$A_N$并不一定是按等差数列中的顺序给出) 输出格式输出一个整数表示答案。 数据范围2\\le$N$\\le100000,0\\le$A_i$\\le10^9 输入样例： 52 6 4 10 20 输出样例： 10 样例解释:包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、18、20。 题目链接 分析等差数列的任意两项之差为公差的倍数。($a_n-a_1=(n-1)d, n\\ge2$) 拿样例来说，2, 6, 4, 10, 20，排序之后为2, 4, 6, 10, 20，与首项的差为2, 4, 8, 18。 要使得等差数列最短就要使公差尽可能的大，就是要求差的最大公约数。 n个数的最大公约数为求前两个的gcd，再用求出gcd与后面的数依次求。证明？不会😁 等差数列需要注意公差为0的情况 用到的知识1.等差数列的通项公式，注意公差为0的情况。 2.欧几里得算法又称辗转相除法。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int a[N];int ans;int gcd(int a, int b){ return b ? gcd(b, a % b) : a;}int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); sort(a, a + n); for (int i = 1; i &lt; n; i++) ans = gcd(ans, a[i] - a[0]); if (ans == 0) cout &lt;&lt; n &lt;&lt; endl; else cout &lt;&lt; (a[n - 1] - a[0]) / ans + 1&lt;&lt; endl; return 0;}","link":"/2020/02/10/等差数列/"},{"title":"背包问题","text":"01背包问题给定物品的数量n（每一种物品只有一件）以及每件物品的价值，一个容量为v的背包，问怎样装物品使总价值最大。 朴素算法1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N]; // v 代表体积 w 代表权重 y总写的和其他人正好反着。 其他人 w 代表weight v 代表 value int f[N][N];int n, m;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;v[i], &amp;w[i]); for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (v[i] &lt;= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化优化之前先看一下滚动数组。使用滚动数组可以大大减少空间复杂度。 二维变一维，最终优化结果： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m, f[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = m; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} 完全背包问题给定n种物品（每一种物品有无限个）以及每一种物品的价值，一个容量为v的背包，问怎样装物品使价值最大。 朴素算法1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) for (int k = 0; k * v[i] &lt;= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化123456/* * f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, ....,f[i - 1][j - x * v] + x * w) * f[i][j - v] = max( f[i - 1][j - v] , f[i - 1][j - 2v] + w, .....,f[i - 1][j - x * v] + (x - 1) * w) * * f[i][j] = max(f[i - 1][j], f[i][j - v] + w); */ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化成一维12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) for (int j = v[i]; j &lt;= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} 多重背包问题朴素算法","link":"/2019/12/06/背包问题/"},{"title":"糖果传递","text":"分析过程123456789101112131415161718192021221-&gt;2-&gt;3-&gt;4-&gt;...-&gt;n-&gt;1 构成一个环x1 x2 x3 x4 .... xn xi表示xi给xi+1糖果的个数，xi可正可负可为零。本题要求|x1|+|x2|+|x3|+.....+|xn|的最小值。 限制条件：最后每个人获得均等糖果。av表示平均值，a数组表示每个人初始糖果的数量。a[1] - x1 + xn = av; a[1] - x1 + xn = av;a[2] - x2 + x1 = av; a[2] - x2 + x1 = av;a[3] - x3 + x2 = av; a[2] + a[3] - x3 + x1 = 2 * av;a[4] - x4 + x3 = av; . . ==========&gt; . 等价成cn。 cn = cn-1 + an - av; (n &gt;= 2) . . ^ c1 = 0; . . | . . 通项公式 ----------------------a[n-1] - xn-1 + xn-2 = av; a[2] + ... + a[n - 1] - xn-1 + x1 = (n - 2) * av; | n |a[n] - xn + xn-1 = av; a[2] + ... + a[n] - xn + x1 = (n - 1) * av; =========&gt; xn = x1 +| ∑ an - (n - 1) * av; | (n &gt;= 2) |n=2 | ----------------------经过上面的等价推导，所以： |x1|+|x2|+|x3|+.....+|xn| ==&gt; |x1 + c1|+|x1 + c2|+|x1 + c3|+.....+|xn + cn| 到这里就转换成AcWing 104.货仓选址这道题了。(链接在下方) AcWing 104.货仓选址代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1000010;int n;LL a[N], c[N];LL sum, ans;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); sum += a[i]; } LL avg = sum / n; // 因为题目保证有解，因此平均数必为整数。 c[1] = 0; for (int i = 2; i &lt;= n; i++) c[i] = c[i - 1] + a[i] - avg; sort(c + 1, c + 1 + n); int mid = c[(1 + n) / 2]; for (int i = 1; i &lt;= n; i++) ans += (LL)abs(mid - c[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2020/02/03/糖果传递/"},{"title":"迷宫问题","text":"定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,}; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 Input一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 Output左上角到右下角的最短路径，格式如样例所示。 Sample Input123450 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 Sample Output123456789(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4) 代码c99中不能{ x, y }要make_pair(x, y) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 10;int g[N][N];bool vis[N][N];PII pre[N][N];void bfs(){ queue&lt;PII&gt; q; q.push({ 0, 0 }); vis[0][0] = true; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; while (q.size()) { PII k = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int x = k.first + dx[i], y = k.second + dy[i]; if(x &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 5 &amp;&amp; g[x][y] == 0 &amp;&amp; !vis[x][y]) { vis[x][y] = true; pre[x][y] = k; q.push({ x, y }); } } }}int main(){ for (int i = 0; i &lt; 5; i++) for (int j = 0; j &lt; 5; j++) scanf(\"%d\", &amp;g[i][j]); bfs(); pre[0][0] = { -1, -1 }; stack&lt;PII&gt; s; s.push({ 4, 4 }); PII Pre = pre[4][4]; while (Pre.first != -1 &amp;&amp; Pre.second != -1) { s.push(Pre); Pre = pre[Pre.first][Pre.second]; } while (!s.empty()) { printf(\"(%d, %d)\\n\", s.top().first, s.top().second); s.pop(); } return 0;}","link":"/2019/12/09/迷宫问题/"},{"title":"逆序对的数量","text":"题目链接 暴力 时间复杂度为O(n^2)12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N];int n;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); int cnt = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { if (q[j] &gt; q[i]) cnt++; } } cout &lt;&lt; cnt; return 0;} 归并 时间复杂度为O(nlogn)，又印证了陈越姥姥的那句话了。归并的思想也是分而治之。递归不能忘了写递归出口啊。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int N = 100010;int q[N], tmp[N];int n;long long res;void merge_sort(int q[], int l, int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else { res += mid - i + 1; tmp[k++] = q[j++]; } } while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; for (int i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); merge_sort(q, 0, n - 1); cout &lt;&lt; res; system(\"pause\"); return 0;}","link":"/2019/11/08/逆序对的数量/"},{"title":"二级指针做输入输出","text":"本文将介绍二级指针做函数输出以及做函数输入的三种内存模型从内存四区的角度对程序执行的过程进行剖析，通过这中方式来加深对指针的理解。 二级指针做输出（在被调函数中分配内存）模型：主函数：123456789int main(){ char *p = NULL; int len = 0; getMem(&amp;p, &amp;len); printf(\"p=%s\\n\", p); FreeMem(&amp;p); return 0;} getMem函数：12345678910111213int getMem(char **myp,int *mylen){ char *temp = NULL; temp = (char*)malloc(100); if (temp == NULL) { return -1; } strcpy(temp, \"abcdefg\"); *mylen = strlen(temp); *myp = temp; return 0;} 犯的错误：*myp = temp; 最初写成了*myp = *temp; 而该表达式赋值两端根本不是一种数据类型。 *myp = temp1; 这句话与*mylen = 某一数值 本质上是一样的，都是*加上指针变量来改变主调用函数中的内容只不过，myp为二级指针因此赋值的右端应为一级指针。 补充： &quot;abcdefg&quot;在常量区中，strcpy(temp, &quot;abcdefg&quot;); 这一句使得temp指向&quot;abcdefg&quot;，其值为字符'a'的地址。 总结：想要在被调用函数中修改主调用函数中的值，必须使用指针，例如在getMem函数中，修改变量的值使用一级指针，修改一级指针需要用到二级指针。 FreeMem函数：1234567891011void FreeMem(char **myp){ if (myp == NULL) { return; } char *tmp = NULL; tmp = *myp; free(tmp); tmp = NULL;} 12345678void FreeMem(char *myp){ if(myp = NULL) { return ; } free(myp);} 这两种FreeMem函数都可以释放p指向的内存，但第一个函数的好处在于使用了二级指针，可在FreeMem函数中将主调用函数中的p的值改为NULL避免 野指针的出现，而第二个函数则要在FreeMem后加上一句p=NULL。 调试结果： 二级指针做输入（在主调用函数中分配内存）模型一：指针数组：1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char *myArray[] = { \"xcccc\",\"ybbbb\",\"zaaaa\" }; int len = sizeof(myArray) / sizeof(myArray[0]); int i = 0; for (i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); //printf(\"%s\\n\", *(myArray+i)); 效果相同 } int j, k; j = k = 0; char *temp = NULL; for (j = 0; j &lt; len - 1; j++) { for (k = 0; k &lt; len - j - 1; k++) { if (strcmp(myArray[k], myArray[k + 1]) &gt; 0) { temp = myArray[k]; myArray[k] = myArray[k + 1]; myArray[k + 1] = temp; } } } for (i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); //printf(\"%s\\n\", *(myArray+i)); 效果相同 } return 0;} 总结：1.在32位操作系统下指针变量的长度为4，在64位下为8。 2.指针数组为元素为指针的数组，myArray数组中有三个元素，sizeof(myArray) / sizeof(myArray[0])可以求出数组长度。 3.排序使用的为最简单的冒泡排序。排序过程中交换的是指针而不是内存块。 二级指针做输入模型一封装函数：主函数：123456789101112int main(){ char *myArray[] = { \"zzz\",\"yyyyyyy\",\"xxxxxxxxx\" }; int len = sizeof(myArray) / sizeof(myArray[0]); printArray(myArray, len); SortArray(myArray, len); printArray(myArray, len); return 0;} 打印函数：1234567void printArray(char **myArray, int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} 排序函数：12345678910111213141516void SortArray(char **myArray, int len){ char *temp = NULL; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { temp = myArray[j]; myArray[j] = myArray[j + 1]; myArray[j + 1] = temp; } } }} 总结：数组在做函数参数是退化为指针，数组名指向数组的第一个元素，即数组名中存放的是数组中第一个元素的地址。指针数组也是如此，char *myArray[];中定义了一个名为myArray的指针数组，根据上面的说明，myArray为第一个元素的地址，而数组元素为指向char类型的指针，即为char *类型，因此myArray为char **类型，所以在函数中第一个参数，均为char **myArray。 二级指针做输入（在主调用函数中分配内存）模型二：二维数组：123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char myArray[10][30] = { \"ddddd\",\"ccccc\",\"bbbbb\",\"aaaaa\" }; int num = 4; for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", myArray[i]); } char temp[30]; for (int i = 0; i &lt; num - 1; i++) { for (int j = 0; j &lt; num - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { strcpy(temp, myArray[j]); strcpy(myArray[j], myArray[j + 1]); strcpy(myArray[j + 1], temp); } } } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", myArray[i]); } return 0;} 二级指针做输入模型二封装函数：主函数：123456789int main(){ char myArray[10][30] = { \"ddddd\",\"ccccc\",\"bbbbb\",\"aaaaa\" }; int num = 4; printArray(myArray, num); SortArray(myArray, num); printArray(myArray, num); return 0;} 打印函数：1234567void printArray(char (*myArray)[30], int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} 排序函数：12345678910111213141516void SortArray(char (*myArray)[30], int len){ char temp[30]; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { strcpy(temp, myArray[j]); strcpy(myArray[j], myArray[j + 1]); strcpy(myArray[j + 1], temp); } } }} 总结：二维数组在做函数参数的时候会退化成为一个指针数组。 二维数组中重要的两个点： 1.二维数组名为第一维首元素的地址。 2.一维数组名为首元素的地址。 有了这两点下面将演示如何用数组名打印某一个元素： 1234567 ==&gt; 表示等价myArray ==&gt; &amp;myArray[0] //上面的第一点 myArray + 2 ==&gt; &amp;myArray[2]*(myArray + 2) ==&gt; myArray[2] ==&gt; &amp;myArray[2][0] //上面的第二点*(myArray + 2) + 1 ==&gt; &amp;myArray[2][1]*(myArray + 2) + 4 ==&gt; &amp;myArray[2][4]*(*(myArray + 2) + 4) ==&gt; myArray[2][4] 二级指针做输入（在主调用函数中分配内存）模型三：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char **p = NULL; int num = 4; p = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { p[i] = (char*)malloc(sizeof(char) * 100); sprintf(p[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", p[i]); } char *temp = NULL; for (int i = 0; i &lt; num - 1; i++) { for (int j = 0; j &lt; num - i - 1; j++) { if (strcmp(p[j], p[j + 1]) &gt; 0) { temp = p[j]; p[j] = p[j + 1]; p[j + 1] = temp; } } } for (int i = 0; i &lt; num; i++) { printf(\"%s\\n\", p[i]); } for (int i = 0; i &lt; num; i++) { if (p[i] != NULL) { free(p[i]); p[i] = NULL; } } if (p != NULL) { free(p); p = NULL; } return 0;} 二级指针做输入模型三封装函数：主函数：123456789101112int main(){ int num = 4; char **p = NULL; //p = getMem(num); getMem_1(&amp;p, num); //两种方式 printArray(p, num); SortArray(p, num); printArray(p, num); myArrayFree(p, num); return 0;} getMem函数:123456789101112131415161718192021222324252627char **getMem(int num){ char **p = NULL; p = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { p[i] = (char*)malloc(sizeof(char) * 100); sprintf(p[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } return p;}int getMem_1(char ***p, int num){ if (p == NULL) { return -1; } char **temp = NULL; temp = (char**)malloc(sizeof(char*)*num); for (int i = 0; i &lt; num; i++) { temp[i] = (char*)malloc(sizeof(char) * 100); sprintf(temp[i], \"%d%d%d\", 4 - i, 4 - i, 4 - i); } *p = temp; return 0;} 打印函数：1234567void printArray(char **myArray, int len){ for (int i = 0; i &lt; len; i++) { printf(\"%s\\n\", myArray[i]); }} 排序函数：12345678910111213141516void SortArray(char **myArray, int len){ char *temp = NULL; for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (strcmp(myArray[j], myArray[j + 1]) &gt; 0) { temp = myArray[j]; myArray[j] = myArray[j + 1]; myArray[j + 1] = temp; } } }} Free函数：12345678910111213141516void myArrayFree(char **p,int len){ for (int i = 0; i &lt; len; i++) { if (p[i] != NULL) { free(p[i]); p[i] = NULL; } } if (p != NULL) { free(p); p = NULL; }}","link":"/2019/09/13/二级指针做函数参数/"},{"title":"最短路模板","text":"最短路问题中有很多的算法，dijkstra bellman_ford spfa floyd初学真的好难记（更不用说去看算法导论的详细证明了）。y总也总结了很多模板链接，自己再来总结一下加深记忆。另外安利y总算法课，讲的真的很好，我觉得收获很大，而且价格也很良心😂😂。 Dijkstra算法朴素版dijkstra适合稠密图思路1234集合S为已经确定最短路径的点集。1. 初始化距离一号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。2. 循环n次，每一次将集合S之外距离最短X的点加入到S中去（这里的距离最短指的是距离1号点最近。点X的路径一定最短，基于贪心，严格证明待看）。然后用点X更新X邻接点的距离。 时间复杂度分析寻找路径最短的点：O(n^2) 加入集合S：O(n) 更新距离：O(m) 所以总的时间复杂度为O(n^2) 具体题目稠密图用邻接矩阵存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 510, M = 10010;int g[N][N], dist[N];bool visited[N];int n, m;int dijkstra(){ memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 1; i &lt;= n; i++) { int t = -1; for(int j = 1; j &lt;= n; j++) { if(!visited[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } visited[t] = true; for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); memset(g, 0x3f, sizeof(g)); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); g[x][y] = min(g[x][y], c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;} 堆优化版dijkstra适合稀疏图思路123456堆优化版的dijkstra是对朴素版dijkstra进行了优化，在朴素版dijkstra中时间复杂度最高的寻找距离最短的点O(n^2)可以使用最小堆优化。1. 一号点的距离初始化为零，其他点初始化成无穷大。2. 将一号点放入堆中。3. 不断循环，直到堆空。每一次循环中执行的操作为： 弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。 用该点更新临界点的距离，若更新成功就加入到堆中。 时间复杂度分析寻找路径最短的点：O(n) 加入集合S：O(n) 更新距离：O(mlogn) 具体题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100010;// 稀疏图用邻接表来存int h[N], e[N], ne[N], idx;int w[N]; // 用来存权重int dist[N];bool st[N]; // 如果为true说明这个点的最短路径已经确定int n, m;void add(int x, int y, int c){ w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++;}int dijkstra(){ memset(dist, 0x3f, sizeof(dist)); dist[0] = 1; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(heap.size()) { PII k = heap.top(); // 取不在集合S中距离最短的点 heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n];}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;} Bellman_ford算法Bellman_ford可以解决有负权的图 思路12循环n次，在每一次的循环当中，遍历所有的边 a-&gt;b 权重为 w ，dist[b] = min(dist[b], dist[a] + w)。严格证明待看循环的次数是有实际的意义的，假如循环k次则 dist[x] 代表着从一号点不超过k条边（&lt;=k）的最短距离。 时间复杂度分析循环n次，每一次遍历m条边，所以时间复杂度为：O(nm) 具体题目 因为这道题在每一次迭代的过程中需要遍历所有的边，所以y总直接用的结构体数组存的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int N = 510, M = 10010;struct Edge{ int x, y, c;}edges[M];int dist[N], backup[N];int n, m, k;int bellman_ford(){ memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 0; i &lt; k; i++) { memcpy(backup, dist, sizeof(dist)); for(int j = 1; j &lt;= m; j++) { int x = edges[j].x, y = edges[j].y, c = edges[j].c; if(dist[y] &gt; backup[x] + c) dist[y] = backup[x] + c; } } if(dist[n] &gt; 0x3f3f3f3f / 2) return -1; // 极端情况 dist[n] = 10000*498; else return dist[n];}int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= m; i++) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); //edges[i] = {x, y, c}; c++11 edges[i].x = x; edges[i].y = y; edges[i].c = c; } int ret = bellman_ford(); if(ret == -1) puts(\"impossible\"); else cout &lt;&lt; ret &lt;&lt; endl; return 0;} spfa算法思路12345678spfa算法实际上是对bellman_ford算法的优化。在bellman_ford当中会将所有的边进行松弛操作，但其实没有必要，其实只需用已经更新过距离的点去更新其他的点就好了。1. 初始化距离一号点距离为零，其他点设为无穷大2. 循环将一号点加入到队列中;while(队列不空) 取点;弹出;更新; 时间复杂度最好：O(m) 最坏：O(nm) 具体题目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 100010, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], idx;int w[N];int dist[N];bool st[N];int n, m;void add(int x, int y, int c){ e[idx] = y; w[idx] = c; ne[idx] = h[x]; h[x] = idx++;}int spfa(){ queue&lt;int&gt; q; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push(1); st[1] = true; while(q.size()) { int k = q.front(); q.pop(); st[k] = false; for(int i = h[k]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] &gt; dist[k] + w[i]) { dist[j] = dist[k] + w[i]; if(!st[j]) { st[j] = true; q.push(j); } } } } return dist[n];}int main(){ memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } int t = spfa(); if(t == INF) puts(\"impossible\"); else cout &lt;&lt; t; return 0;} spfa判断负环思路12","link":"/2019/11/24/最短路模板/"}],"tags":[{"name":"POJ","slug":"POJ","link":"/tags/POJ/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"蓝桥杯","slug":"蓝桥杯","link":"/tags/蓝桥杯/"},{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"AcWing算法模板","slug":"AcWing算法模板","link":"/tags/AcWing算法模板/"},{"name":"哈希","slug":"哈希","link":"/tags/哈希/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"AcWing算法题","slug":"AcWing算法题","link":"/tags/AcWing算法题/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"}],"categories":[{"name":"浙大数据结构","slug":"浙大数据结构","link":"/categories/浙大数据结构/"},{"name":"传智播客扫地僧c/c++学习笔记","slug":"传智播客扫地僧c-c-学习笔记","link":"/categories/传智播客扫地僧c-c-学习笔记/"},{"name":"PTA","slug":"PTA","link":"/categories/PTA/"},{"name":"POJ","slug":"POJ","link":"/categories/POJ/"},{"name":"AcWing蓝桥杯","slug":"AcWing蓝桥杯","link":"/categories/AcWing蓝桥杯/"},{"name":"总结","slug":"总结","link":"/categories/总结/"},{"name":"AcWing基础课","slug":"AcWing基础课","link":"/categories/AcWing基础课/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"bug记录","slug":"bug记录","link":"/categories/bug记录/"},{"name":"数论","slug":"AcWing蓝桥杯/数论","link":"/categories/AcWing蓝桥杯/数论/"}]}